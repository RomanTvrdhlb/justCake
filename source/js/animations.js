(() => {
    var __webpack_modules__ = {
            "./node_modules/gsap/CSSPlugin.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    CSSPlugin: () => CSSPlugin,
                    _createElement: () => _createElement,
                    _getBBox: () => _getBBox,
                    checkPrefix: () => _checkPropPrefix,
                    default: () => CSSPlugin
                });
                var _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _supports3D, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/gsap/gsap-core.js"),
                    _transformProps = {},
                    _RAD2DEG = 180 / Math.PI,
                    _DEG2RAD = Math.PI / 180,
                    _atan2 = Math.atan2,
                    _capsExp = /([A-Z])/g,
                    _horizontalExp = /(left|right|width|margin|padding|x)/i,
                    _complexExp = /[\s,\(]\S/,
                    _propertyAliases = {
                        autoAlpha: "opacity,visibility",
                        scale: "scaleX,scaleY",
                        alpha: "opacity"
                    },
                    _renderCSSProp = function _renderCSSProp(ratio, data) {
                        return data.set(data.t, data.p, Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u, data)
                    },
                    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
                        return data.set(data.t, data.p, 1 === ratio ? data.e : Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u, data)
                    },
                    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
                        return data.set(data.t, data.p, ratio ? Math.round(1e4 * (data.s + data.c * ratio)) / 1e4 + data.u : data.b, data)
                    },
                    _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
                        var value = data.s + data.c * ratio;
                        data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data)
                    },
                    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
                        return data.set(data.t, data.p, ratio ? data.e : data.b, data)
                    },
                    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
                        return data.set(data.t, data.p, 1 !== ratio ? data.b : data.e, data)
                    },
                    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
                        return target.style[property] = value
                    },
                    _setterCSSProp = function _setterCSSProp(target, property, value) {
                        return target.style.setProperty(property, value)
                    },
                    _setterTransform = function _setterTransform(target, property, value) {
                        return target._gsap[property] = value
                    },
                    _setterScale = function _setterScale(target, property, value) {
                        return target._gsap.scaleX = target._gsap.scaleY = value
                    },
                    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache.scaleX = cache.scaleY = value, cache.renderTransform(ratio, cache)
                    },
                    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache[property] = value, cache.renderTransform(ratio, cache)
                    },
                    _transformProp = "transform",
                    _transformOriginProp = _transformProp + "Origin",
                    _saveStyle = function _saveStyle(property, isNotCSS) {
                        var _this = this,
                            target = this.target,
                            style = target.style;
                        if (property in _transformProps && style) {
                            if (this.tfm = this.tfm || {}, "transform" === property) return _propertyAliases.transform.split(",").forEach((function(p) {
                                return _saveStyle.call(_this, p, isNotCSS)
                            }));
                            if (~(property = _propertyAliases[property] || property).indexOf(",") ? property.split(",").forEach((function(a) {
                                    return _this.tfm[a] = _get(target, a)
                                })) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property), this.props.indexOf(_transformProp) >= 0) return;
                            target._gsap.svg && (this.svgo = target.getAttribute("data-svg-origin"), this.props.push(_transformOriginProp, isNotCSS, "")), property = _transformProp
                        }(style || isNotCSS) && this.props.push(property, isNotCSS, style[property])
                    },
                    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
                        style.translate && (style.removeProperty("translate"), style.removeProperty("scale"), style.removeProperty("rotate"))
                    },
                    _revertStyle = function _revertStyle() {
                        var i, p, props = this.props,
                            target = this.target,
                            style = target.style,
                            cache = target._gsap;
                        for (i = 0; i < props.length; i += 3) props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty("--" === props[i].substr(0, 2) ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
                        if (this.tfm) {
                            for (p in this.tfm) cache[p] = this.tfm[p];
                            cache.svg && (cache.renderTransform(), target.setAttribute("data-svg-origin", this.svgo || "")), (i = _reverting()) && i.isStart || style[_transformProp] || (_removeIndependentTransforms(style), cache.uncache = 1)
                        }
                    },
                    _getStyleSaver = function _getStyleSaver(target, properties) {
                        var saver = {
                            target: target,
                            props: [],
                            revert: _revertStyle,
                            save: _saveStyle
                        };
                        return target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target), properties && properties.split(",").forEach((function(p) {
                            return saver.save(p)
                        })), saver
                    },
                    _createElement = function _createElement(type, ns) {
                        var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type);
                        return e.style ? e : _doc.createElement(type)
                    },
                    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
                        var cs = getComputedStyle(target);
                        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""
                    },
                    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
                    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
                        var s = (element || _tempDiv).style,
                            i = 5;
                        if (property in s && !preferPrefix) return property;
                        for (property = property.charAt(0).toUpperCase() + property.substr(1); i-- && !(_prefixes[i] + property in s););
                        return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? _prefixes[i] : "") + property
                    },
                    _initCore = function _initCore() {
                        (function _windowExists() {
                            return "undefined" != typeof window
                        })() && window.document && (_win = window, _doc = _win.document, _docElement = _doc.documentElement, _tempDiv = _createElement("div") || {
                            style: {}
                        }, _createElement("div"), _transformProp = _checkPropPrefix(_transformProp), _transformOriginProp = _transformProp + "Origin", _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", _supports3D = !!_checkPropPrefix("perspective"), _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting, _pluginInitted = 1)
                    },
                    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
                        var bbox, svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            oldParent = this.parentNode,
                            oldSibling = this.nextSibling,
                            oldCSS = this.style.cssText;
                        if (_docElement.appendChild(svg), svg.appendChild(this), this.style.display = "block", swapIfPossible) try {
                            bbox = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = _getBBoxHack
                        } catch (e) {} else this._gsapBBox && (bbox = this._gsapBBox());
                        return oldParent && (oldSibling ? oldParent.insertBefore(this, oldSibling) : oldParent.appendChild(this)), _docElement.removeChild(svg), this.style.cssText = oldCSS, bbox
                    },
                    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
                        for (var i = attributesArray.length; i--;)
                            if (target.hasAttribute(attributesArray[i])) return target.getAttribute(attributesArray[i])
                    },
                    _getBBox = function _getBBox(target) {
                        var bounds;
                        try {
                            bounds = target.getBBox()
                        } catch (error) {
                            bounds = _getBBoxHack.call(target, !0)
                        }
                        return bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, !0)), !bounds || bounds.width || bounds.x || bounds.y ? bounds : {
                            x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
                            y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
                            width: 0,
                            height: 0
                        }
                    },
                    _isSVG = function _isSVG(e) {
                        return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !_getBBox(e))
                    },
                    _removeProperty = function _removeProperty(target, property) {
                        if (property) {
                            var style = target.style;
                            property in _transformProps && property !== _transformOriginProp && (property = _transformProp), style.removeProperty ? ("ms" !== property.substr(0, 2) && "webkit" !== property.substr(0, 6) || (property = "-" + property), style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase())) : style.removeAttribute(property)
                        }
                    },
                    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
                        var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
                        return plugin._pt = pt, pt.b = beginning, pt.e = end, plugin._props.push(property), pt
                    },
                    _nonConvertibleUnits = {
                        deg: 1,
                        rad: 1,
                        turn: 1
                    },
                    _nonStandardLayouts = {
                        grid: 1,
                        flex: 1
                    },
                    _convertToUnit = function _convertToUnit(target, property, value, unit) {
                        var px, parent, cache, isSVG, curValue = parseFloat(value) || 0,
                            curUnit = (value + "").trim().substr((curValue + "").length) || "px",
                            style = _tempDiv.style,
                            horizontal = _horizontalExp.test(property),
                            isRootSVG = "svg" === target.tagName.toLowerCase(),
                            measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
                            toPixels = "px" === unit,
                            toPercent = "%" === unit;
                        return unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit] ? curValue : ("px" !== curUnit && !toPixels && (curValue = _convertToUnit(target, property, value, "px")), isSVG = target.getCTM && _isSVG(target), !toPercent && "%" !== curUnit || !_transformProps[property] && !~property.indexOf("adius") ? (style[horizontal ? "width" : "height"] = 100 + (toPixels ? curUnit : unit), parent = ~property.indexOf("adius") || "em" === unit && target.appendChild && !isRootSVG ? target : target.parentNode, isSVG && (parent = (target.ownerSVGElement || {}).parentNode), parent && parent !== _doc && parent.appendChild || (parent = _doc.body), (cache = parent._gsap) && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * 100) : ((toPercent || "%" === curUnit) && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position")), parent === target && (style.position = "static"), parent.appendChild(_tempDiv), px = _tempDiv[measureProperty], parent.removeChild(_tempDiv), style.position = "absolute", horizontal && toPercent && ((cache = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent)).time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time, cache.width = parent[measureProperty]), (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / 100 : px && curValue ? 100 / px * curValue : 0))) : (px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty], (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * 100 : curValue / 100 * px)))
                    },
                    _get = function _get(target, property, unit, uncache) {
                        var value;
                        return _pluginInitted || _initCore(), property in _propertyAliases && "transform" !== property && ~(property = _propertyAliases[property]).indexOf(",") && (property = property.split(",")[0]), _transformProps[property] && "transform" !== property ? (value = _parseTransform(target, uncache), value = "transformOrigin" !== property ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px") : (!(value = target.style[property]) || "auto" === value || uncache || ~(value + "").indexOf("calc(")) && (value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || ("opacity" === property ? 1 : 0)), unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value
                    },
                    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
                        if (!start || "none" === start) {
                            var p = _checkPropPrefix(prop, target, 1),
                                s = p && _getComputedProperty(target, p, 1);
                            s && s !== start ? (prop = p, start = s) : "borderColor" === prop && (start = _getComputedProperty(target, "borderTopColor"))
                        }
                        var a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
                            index = 0,
                            matchIndex = 0;
                        if (pt.b = start, pt.e = end, start += "", "auto" === (end += "") && (target.style[prop] = end, end = _getComputedProperty(target, prop) || end, target.style[prop] = start), a = [start, end], (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a), end = a[1], startValues = (start = a[0]).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [], (end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || []).length) {
                            for (; result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end);) endValue = result[0], chunk = end.substring(index, result.index), color ? color = (color + 1) % 5 : "rgba(" !== chunk.substr(-5) && "hsla(" !== chunk.substr(-5) || (color = 1), endValue !== (startValue = startValues[matchIndex++] || "") && (startNum = parseFloat(startValue) || 0, startUnit = startValue.substr((startNum + "").length), "=" === endValue.charAt(1) && (endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit), endNum = parseFloat(endValue), endUnit = endValue.substr((endNum + "").length), index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length, endUnit || (endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit, index === end.length && (end += endUnit, pt.e += endUnit)), startUnit !== endUnit && (startNum = _convertToUnit(target, prop, startValue, endUnit) || 0), pt._pt = {
                                _next: pt._pt,
                                p: chunk || 1 === matchIndex ? chunk : ",",
                                s: startNum,
                                c: endNum - startNum,
                                m: color && color < 4 || "zIndex" === prop ? Math.round : 0
                            });
                            pt.c = index < end.length ? end.substring(index, end.length) : ""
                        } else pt.r = "display" === prop && "none" === end ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
                        return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0), this._pt = pt, pt
                    },
                    _keywordToPercent = {
                        top: "0%",
                        bottom: "100%",
                        left: "0%",
                        right: "100%",
                        center: "50%"
                    },
                    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
                        var split = value.split(" "),
                            x = split[0],
                            y = split[1] || "50%";
                        return "top" !== x && "bottom" !== x && "left" !== y && "right" !== y || (value = x, x = y, y = value), split[0] = _keywordToPercent[x] || x, split[1] = _keywordToPercent[y] || y, split.join(" ")
                    },
                    _renderClearProps = function _renderClearProps(ratio, data) {
                        if (data.tween && data.tween._time === data.tween._dur) {
                            var prop, clearTransforms, i, target = data.t,
                                style = target.style,
                                props = data.u,
                                cache = target._gsap;
                            if ("all" === props || !0 === props) style.cssText = "", clearTransforms = 1;
                            else
                                for (i = (props = props.split(",")).length; --i > -1;) prop = props[i], _transformProps[prop] && (clearTransforms = 1, prop = "transformOrigin" === prop ? _transformOriginProp : _transformProp), _removeProperty(target, prop);
                            clearTransforms && (_removeProperty(target, _transformProp), cache && (cache.svg && target.removeAttribute("transform"), _parseTransform(target, 1), cache.uncache = 1, _removeIndependentTransforms(style)))
                        }
                    },
                    _specialProps = {
                        clearProps: function clearProps(plugin, target, property, endValue, tween) {
                            if ("isFromStart" !== tween.data) {
                                var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                                return pt.u = endValue, pt.pr = -10, pt.tween = tween, plugin._props.push(property), 1
                            }
                        }
                    },
                    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
                    _rotationalProperties = {},
                    _isNullTransform = function _isNullTransform(value) {
                        return "matrix(1, 0, 0, 1, 0, 0)" === value || "none" === value || !value
                    },
                    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
                        var matrixString = _getComputedProperty(target, _transformProp);
                        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)
                    },
                    _getMatrix = function _getMatrix(target, force2D) {
                        var parent, nextSibling, temp, addedToDOM, cache = target._gsap || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
                            style = target.style,
                            matrix = _getComputedTransformMatrixAsArray(target);
                        return cache.svg && target.getAttribute("transform") ? "1,0,0,1,0,0" === (matrix = [(temp = target.transform.baseVal.consolidate().matrix).a, temp.b, temp.c, temp.d, temp.e, temp.f]).join(",") ? _identity2DMatrix : matrix : (matrix !== _identity2DMatrix || target.offsetParent || target === _docElement || cache.svg || (temp = style.display, style.display = "block", (parent = target.parentNode) && target.offsetParent || (addedToDOM = 1, nextSibling = target.nextElementSibling, _docElement.appendChild(target)), matrix = _getComputedTransformMatrixAsArray(target), temp ? style.display = temp : _removeProperty(target, "display"), addedToDOM && (nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target))), force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix)
                    },
                    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
                        var bounds, determinant, y, cache = target._gsap,
                            matrix = matrixArray || _getMatrix(target, !0),
                            xOriginOld = cache.xOrigin || 0,
                            yOriginOld = cache.yOrigin || 0,
                            xOffsetOld = cache.xOffset || 0,
                            yOffsetOld = cache.yOffset || 0,
                            a = matrix[0],
                            b = matrix[1],
                            c = matrix[2],
                            d = matrix[3],
                            tx = matrix[4],
                            ty = matrix[5],
                            originSplit = origin.split(" "),
                            xOrigin = parseFloat(originSplit[0]) || 0,
                            yOrigin = parseFloat(originSplit[1]) || 0;
                        originIsAbsolute ? matrix !== _identity2DMatrix && (determinant = a * d - b * c) && (y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant, xOrigin = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant, yOrigin = y) : (xOrigin = (bounds = _getBBox(target)).x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin), yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin)), smooth || !1 !== smooth && cache.smooth ? (tx = xOrigin - xOriginOld, ty = yOrigin - yOriginOld, cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx, cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty) : cache.xOffset = cache.yOffset = 0, cache.xOrigin = xOrigin, cache.yOrigin = yOrigin, cache.smooth = !!smooth, cache.origin = origin, cache.originIsAbsolute = !!originIsAbsolute, target.style[_transformOriginProp] = "0px 0px", pluginToAddPropTweensTo && (_addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin), _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin), _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset), _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset)), target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin)
                    },
                    _parseTransform = function _parseTransform(target, uncache) {
                        var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);
                        if ("x" in cache && !uncache && !cache.uncache) return cache;
                        var x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32, style = target.style,
                            invertedScaleX = cache.scaleX < 0,
                            cs = getComputedStyle(target),
                            origin = _getComputedProperty(target, _transformOriginProp) || "0";
                        return x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0, scaleX = scaleY = 1, cache.svg = !(!target.getCTM || !_isSVG(target)), cs.translate && ("none" === cs.translate && "none" === cs.scale && "none" === cs.rotate || (style[_transformProp] = ("none" !== cs.translate ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== cs.rotate ? "rotate(" + cs.rotate + ") " : "") + ("none" !== cs.scale ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + ("none" !== cs[_transformProp] ? cs[_transformProp] : "")), style.scale = style.rotate = style.translate = "none"), matrix = _getMatrix(target, cache.svg), cache.svg && (cache.uncache ? (t2 = target.getBBox(), origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px", t1 = "") : t1 = !uncache && target.getAttribute("data-svg-origin"), _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, !1 !== cache.smooth, matrix)), xOrigin = cache.xOrigin || 0, yOrigin = cache.yOrigin || 0, matrix !== _identity2DMatrix && (a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], x = a12 = matrix[4], y = a22 = matrix[5], 6 === matrix.length ? (scaleX = Math.sqrt(a * a + b * b), scaleY = Math.sqrt(d * d + c * c), rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0, (skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0) && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD))), cache.svg && (x -= xOrigin - (xOrigin * a + yOrigin * c), y -= yOrigin - (xOrigin * b + yOrigin * d))) : (a32 = matrix[6], a42 = matrix[7], a13 = matrix[8], a23 = matrix[9], a33 = matrix[10], a43 = matrix[11], x = matrix[12], y = matrix[13], z = matrix[14], rotationX = (angle = _atan2(a32, a33)) * _RAD2DEG, angle && (t1 = a12 * (cos = Math.cos(-angle)) + a13 * (sin = Math.sin(-angle)), t2 = a22 * cos + a23 * sin, t3 = a32 * cos + a33 * sin, a13 = a12 * -sin + a13 * cos, a23 = a22 * -sin + a23 * cos, a33 = a32 * -sin + a33 * cos, a43 = a42 * -sin + a43 * cos, a12 = t1, a22 = t2, a32 = t3), rotationY = (angle = _atan2(-c, a33)) * _RAD2DEG, angle && (cos = Math.cos(-angle), a43 = d * (sin = Math.sin(-angle)) + a43 * cos, a = t1 = a * cos - a13 * sin, b = t2 = b * cos - a23 * sin, c = t3 = c * cos - a33 * sin), rotation = (angle = _atan2(b, a)) * _RAD2DEG, angle && (t1 = a * (cos = Math.cos(angle)) + b * (sin = Math.sin(angle)), t2 = a12 * cos + a22 * sin, b = b * cos - a * sin, a22 = a22 * cos - a12 * sin, a = t1, a12 = t2), rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9 && (rotationX = rotation = 0, rotationY = 180 - rotationY), scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c)), scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32)), angle = _atan2(a12, a22), skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0, perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0), cache.svg && (t1 = target.getAttribute("transform"), cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp)), t1 && target.setAttribute("transform", t1))), Math.abs(skewX) > 90 && Math.abs(skewX) < 270 && (invertedScaleX ? (scaleX *= -1, skewX += rotation <= 0 ? 180 : -180, rotation += rotation <= 0 ? 180 : -180) : (scaleY *= -1, skewX += skewX <= 0 ? 180 : -180)), uncache = uncache || cache.uncache, cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + "px", cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + "px", cache.z = z + "px", cache.scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX), cache.scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY), cache.rotation = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + "deg", cache.rotationX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + "deg", cache.rotationY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + "deg", cache.skewX = skewX + "deg", cache.skewY = skewY + "deg", cache.transformPerspective = perspective + "px", (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) && (style[_transformOriginProp] = _firstTwoOnly(origin)), cache.xOffset = cache.yOffset = 0, cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D, cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms, cache.uncache = 0, cache
                    },
                    _firstTwoOnly = function _firstTwoOnly(value) {
                        return (value = value.split(" "))[0] + " " + value[1]
                    },
                    _addPxTranslate = function _addPxTranslate(target, start, value) {
                        var unit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
                        return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit
                    },
                    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
                        cache.z = "0px", cache.rotationY = cache.rotationX = "0deg", cache.force3D = 0, _renderCSSTransforms(ratio, cache)
                    },
                    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
                        var _ref = cache || this,
                            xPercent = _ref.xPercent,
                            yPercent = _ref.yPercent,
                            x = _ref.x,
                            y = _ref.y,
                            z = _ref.z,
                            rotation = _ref.rotation,
                            rotationY = _ref.rotationY,
                            rotationX = _ref.rotationX,
                            skewX = _ref.skewX,
                            skewY = _ref.skewY,
                            scaleX = _ref.scaleX,
                            scaleY = _ref.scaleY,
                            transformPerspective = _ref.transformPerspective,
                            force3D = _ref.force3D,
                            target = _ref.target,
                            zOrigin = _ref.zOrigin,
                            transforms = "",
                            use3D = "auto" === force3D && ratio && 1 !== ratio || !0 === force3D;
                        if (zOrigin && ("0deg" !== rotationX || "0deg" !== rotationY)) {
                            var cos, angle = parseFloat(rotationY) * _DEG2RAD,
                                a13 = Math.sin(angle),
                                a33 = Math.cos(angle);
                            angle = parseFloat(rotationX) * _DEG2RAD, cos = Math.cos(angle), x = _addPxTranslate(target, x, a13 * cos * -zOrigin), y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin), z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin)
                        }
                        "0px" !== transformPerspective && (transforms += "perspective(" + transformPerspective + ") "), (xPercent || yPercent) && (transforms += "translate(" + xPercent + "%, " + yPercent + "%) "), (use3D || "0px" !== x || "0px" !== y || "0px" !== z) && (transforms += "0px" !== z || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + ") "), "0deg" !== rotation && (transforms += "rotate(" + rotation + ") "), "0deg" !== rotationY && (transforms += "rotateY(" + rotationY + ") "), "0deg" !== rotationX && (transforms += "rotateX(" + rotationX + ") "), "0deg" === skewX && "0deg" === skewY || (transforms += "skew(" + skewX + ", " + skewY + ") "), 1 === scaleX && 1 === scaleY || (transforms += "scale(" + scaleX + ", " + scaleY + ") "), target.style[_transformProp] = transforms || "translate(0, 0)"
                    },
                    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
                        var a11, a21, a12, a22, temp, _ref2 = cache || this,
                            xPercent = _ref2.xPercent,
                            yPercent = _ref2.yPercent,
                            x = _ref2.x,
                            y = _ref2.y,
                            rotation = _ref2.rotation,
                            skewX = _ref2.skewX,
                            skewY = _ref2.skewY,
                            scaleX = _ref2.scaleX,
                            scaleY = _ref2.scaleY,
                            target = _ref2.target,
                            xOrigin = _ref2.xOrigin,
                            yOrigin = _ref2.yOrigin,
                            xOffset = _ref2.xOffset,
                            yOffset = _ref2.yOffset,
                            forceCSS = _ref2.forceCSS,
                            tx = parseFloat(x),
                            ty = parseFloat(y);
                        rotation = parseFloat(rotation), skewX = parseFloat(skewX), (skewY = parseFloat(skewY)) && (skewX += skewY = parseFloat(skewY), rotation += skewY), rotation || skewX ? (rotation *= _DEG2RAD, skewX *= _DEG2RAD, a11 = Math.cos(rotation) * scaleX, a21 = Math.sin(rotation) * scaleX, a12 = Math.sin(rotation - skewX) * -scaleY, a22 = Math.cos(rotation - skewX) * scaleY, skewX && (skewY *= _DEG2RAD, temp = Math.tan(skewX - skewY), a12 *= temp = Math.sqrt(1 + temp * temp), a22 *= temp, skewY && (temp = Math.tan(skewY), a11 *= temp = Math.sqrt(1 + temp * temp), a21 *= temp)), a11 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11), a21 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21), a12 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12), a22 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22)) : (a11 = scaleX, a22 = scaleY, a21 = a12 = 0), (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) && (tx = _convertToUnit(target, "x", x, "px"), ty = _convertToUnit(target, "y", y, "px")), (xOrigin || yOrigin || xOffset || yOffset) && (tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset), ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset)), (xPercent || yPercent) && (temp = target.getBBox(), tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width), ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height)), temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")", target.setAttribute("transform", temp), forceCSS && (target.style[_transformProp] = temp)
                    },
                    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
                        var direction, pt, isString = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
                            change = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1) - startNum,
                            finalValue = startNum + change + "deg";
                        return isString && ("short" === (direction = endValue.split("_")[1]) && (change %= 360) !== change % 180 && (change += change < 0 ? 360 : -360), "cw" === direction && change < 0 ? change = (change + 36e9) % 360 - 360 * ~~(change / 360) : "ccw" === direction && change > 0 && (change = (change - 36e9) % 360 - 360 * ~~(change / 360))), plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd), pt.e = finalValue, pt.u = "deg", plugin._props.push(property), pt
                    },
                    _assign = function _assign(target, source) {
                        for (var p in source) target[p] = source[p];
                        return target
                    },
                    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
                        var endCache, p, startValue, endValue, startNum, endNum, endUnit, startCache = _assign({}, target._gsap),
                            style = target.style;
                        for (p in startCache.svg ? (startValue = target.getAttribute("transform"), target.setAttribute("transform", ""), style[_transformProp] = transforms, endCache = _parseTransform(target, 1), _removeProperty(target, _transformProp), target.setAttribute("transform", startValue)) : (startValue = getComputedStyle(target)[_transformProp], style[_transformProp] = transforms, endCache = _parseTransform(target, 1), style[_transformProp] = startValue), _transformProps)(startValue = startCache[p]) !== (endValue = endCache[p]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(p) < 0 && (startNum = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue) !== (endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue)) ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue), endNum = parseFloat(endValue), plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp), plugin._pt.u = endUnit || 0, plugin._props.push(p));
                        _assign(endCache, startCache)
                    };
                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", (function(name, index) {
                    var t = "Top",
                        r = "Right",
                        b = "Bottom",
                        l = "Left",
                        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map((function(side) {
                            return index < 2 ? name + side : "border" + side + name
                        }));
                    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                        var a, vars;
                        if (arguments.length < 4) return a = props.map((function(prop) {
                            return _get(plugin, prop, property)
                        })), 5 === (vars = a.join(" ")).split(a[0]).length ? a[0] : vars;
                        a = (endValue + "").split(" "), vars = {}, props.forEach((function(prop, i) {
                            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0]
                        })), plugin.init(target, vars, tween)
                    }
                }));
                var rotation, all, CSSPlugin = {
                    name: "css",
                    register: _initCore,
                    targetTest: function targetTest(target) {
                        return target.style && target.nodeType
                    },
                    init: function init(target, vars, tween, index, targets) {
                        var startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps, props = this._props,
                            style = target.style,
                            startAt = tween.vars.startAt;
                        for (p in _pluginInitted || _initCore(), this.styles = this.styles || _getStyleSaver(target), inlineProps = this.styles.props, this.tween = tween, vars)
                            if ("autoRound" !== p && (endValue = vars[p], !_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] || !(0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)))
                                if (type = typeof endValue, specialProp = _specialProps[p], "function" === type && (type = typeof(endValue = endValue.call(tween, index, target, targets))), "string" === type && ~endValue.indexOf("random(") && (endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue)), specialProp) specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
                                else if ("--" === p.substr(0, 2)) startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim(), endValue += "", _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue) || (startUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue), endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue)), endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit), this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p), props.push(p), inlineProps.push(p, 0, style[p]);
                        else if ("undefined" !== type) {
                            if (startAt && p in startAt ? (startValue = "function" == typeof startAt[p] ? startAt[p].call(tween, index, target, targets) : startAt[p], (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue)), (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""), "=" === (startValue + "").charAt(1) && (startValue = _get(target, p))) : startValue = _get(target, p), startNum = parseFloat(startValue), (relative = "string" === type && "=" === endValue.charAt(1) && endValue.substr(0, 2)) && (endValue = endValue.substr(2)), endNum = parseFloat(endValue), p in _propertyAliases && ("autoAlpha" === p && (1 === startNum && "hidden" === _get(target, "visibility") && endNum && (startNum = 0), inlineProps.push("visibility", 0, style.visibility), _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum)), "scale" !== p && "transform" !== p && ~(p = _propertyAliases[p]).indexOf(",") && (p = p.split(",")[0])), isTransformRelated = p in _transformProps)
                                if (this.styles.save(p), transformPropTween || ((cache = target._gsap).renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform), smooth = !1 !== vars.smoothOrigin && cache.smooth, (transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1)).dep = 1), "scale" === p) this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp), this._pt.u = 0, props.push("scaleY", p), p += "X";
                                else {
                                    if ("transformOrigin" === p) {
                                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]), endValue = _convertKeywordsToPercentages(endValue), cache.svg ? _applySVGOrigin(target, endValue, 0, smooth, 0, this) : ((endUnit = parseFloat(endValue.split(" ")[2]) || 0) !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit), _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue)));
                                        continue
                                    }
                                    if ("svgOrigin" === p) {
                                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                                        continue
                                    }
                                    if (p in _rotationalProperties) {
                                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);
                                        continue
                                    }
                                    if ("smoothOrigin" === p) {
                                        _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                                        continue
                                    }
                                    if ("force3D" === p) {
                                        cache[p] = endValue;
                                        continue
                                    }
                                    if ("transform" === p) {
                                        _addRawTransformPTs(this, endValue, target);
                                        continue
                                    }
                                }
                            else p in style || (p = _checkPropPrefix(p) || p);
                            if (isTransformRelated || (endNum || 0 === endNum) && (startNum || 0 === startNum) && !_complexExp.test(endValue) && p in style) endNum || (endNum = 0), (startUnit = (startValue + "").substr((startNum + "").length)) !== (endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit)) && (startNum = _convertToUnit(target, p, startValue, endUnit)), this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, isTransformRelated || "px" !== endUnit && "zIndex" !== p || !1 === vars.autoRound ? _renderCSSProp : _renderRoundedCSSProp), this._pt.u = endUnit || 0, startUnit !== endUnit && "%" !== endUnit && (this._pt.b = startValue, this._pt.r = _renderCSSPropWithBeginning);
                            else if (p in style) _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
                            else if (p in target) this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
                            else if ("parseTransform" !== p) {
                                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);
                                continue
                            }
                            isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p])), props.push(p)
                        }
                        hasPriority && (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this)
                    },
                    render: function render(ratio, data) {
                        if (data.tween._time || !_reverting())
                            for (var pt = data._pt; pt;) pt.r(ratio, pt.d), pt = pt._next;
                        else data.styles.revert()
                    },
                    get: _get,
                    aliases: _propertyAliases,
                    getSetter: function getSetter(target, property, plugin) {
                        var p = _propertyAliases[property];
                        return p && p.indexOf(",") < 0 && (property = p), property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? "scale" === property ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && ("scale" === property ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property)
                    },
                    core: {
                        _removeProperty: _removeProperty,
                        _getMatrix: _getMatrix
                    }
                };
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver, rotation = "rotation,rotationX,rotationY,skewX,skewY", all = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + rotation + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(name) {
                    _transformProps[name] = 1
                })), (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, (function(name) {
                    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg", _rotationalProperties[name] = 1
                })), _propertyAliases[all[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + rotation, (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(name) {
                    var split = name.split(":");
                    _propertyAliases[split[1]] = all[split[0]]
                })), (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(name) {
                    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px"
                })), _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin)
            },
            "./node_modules/gsap/gsap-core.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";

                function _assertThisInitialized(self) {
                    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return self
                }

                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, subClass.__proto__ = superClass
                }
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    Animation: () => Animation,
                    Back: () => Back,
                    Bounce: () => Bounce,
                    Circ: () => Circ,
                    Cubic: () => Cubic,
                    Elastic: () => Elastic,
                    Expo: () => Expo,
                    GSCache: () => GSCache,
                    Linear: () => Linear,
                    Power0: () => Power0,
                    Power1: () => Power1,
                    Power2: () => Power2,
                    Power3: () => Power3,
                    Power4: () => Power4,
                    PropTween: () => PropTween,
                    Quad: () => Quad,
                    Quart: () => Quart,
                    Quint: () => Quint,
                    Sine: () => Sine,
                    SteppedEase: () => SteppedEase,
                    Strong: () => Strong,
                    Timeline: () => Timeline,
                    TimelineLite: () => Timeline,
                    TimelineMax: () => Timeline,
                    Tween: () => Tween,
                    TweenLite: () => Tween,
                    TweenMax: () => Tween,
                    _checkPlugin: () => _checkPlugin,
                    _colorExp: () => _colorExp,
                    _colorStringFilter: () => _colorStringFilter,
                    _config: () => _config,
                    _forEachName: () => _forEachName,
                    _getCache: () => _getCache,
                    _getProperty: () => _getProperty,
                    _getSetter: () => _getSetter,
                    _isString: () => _isString,
                    _isUndefined: () => _isUndefined,
                    _missingPlugin: () => _missingPlugin,
                    _numExp: () => _numExp,
                    _numWithUnitExp: () => _numWithUnitExp,
                    _parseRelative: () => _parseRelative,
                    _plugins: () => _plugins,
                    _relExp: () => _relExp,
                    _removeLinkedListItem: () => _removeLinkedListItem,
                    _renderComplexString: () => _renderComplexString,
                    _replaceRandom: () => _replaceRandom,
                    _round: () => _round,
                    _roundModifier: () => _roundModifier,
                    _setDefaults: () => _setDefaults,
                    _sortPropTweensByPriority: () => _sortPropTweensByPriority,
                    _ticker: () => _ticker,
                    clamp: () => clamp,
                    default: () => gsap,
                    distribute: () => distribute,
                    getUnit: () => getUnit,
                    gsap: () => gsap,
                    interpolate: () => interpolate,
                    mapRange: () => mapRange,
                    normalize: () => normalize,
                    pipe: () => pipe,
                    random: () => random,
                    selector: () => selector,
                    shuffle: () => shuffle,
                    snap: () => snap,
                    splitColor: () => splitColor,
                    toArray: () => toArray,
                    unitize: () => unitize,
                    wrap: () => wrap,
                    wrapYoyo: () => wrapYoyo
                });
                var _suppressOverwrites, _reverting, _context, _globalTimeline, _win, _coreInitted, _doc, _coreReady, _lastRenderedFrame, _quickTween, _tickerActive, n, c, n1, easeOut, _config = {
                        autoSleep: 120,
                        force3D: "auto",
                        nullTargetWarn: 1,
                        units: {
                            lineHeight: ""
                        }
                    },
                    _defaults = {
                        duration: .5,
                        overwrite: !1,
                        delay: 0
                    },
                    _bigNum = 1e8,
                    _2PI = 2 * Math.PI,
                    _HALF_PI = _2PI / 4,
                    _gsID = 0,
                    _sqrt = Math.sqrt,
                    _cos = Math.cos,
                    _sin = Math.sin,
                    _isString = function _isString(value) {
                        return "string" == typeof value
                    },
                    _isFunction = function _isFunction(value) {
                        return "function" == typeof value
                    },
                    _isNumber = function _isNumber(value) {
                        return "number" == typeof value
                    },
                    _isUndefined = function _isUndefined(value) {
                        return void 0 === value
                    },
                    _isObject = function _isObject(value) {
                        return "object" == typeof value
                    },
                    _isNotFalse = function _isNotFalse(value) {
                        return !1 !== value
                    },
                    _windowExists = function _windowExists() {
                        return "undefined" != typeof window
                    },
                    _isFuncOrString = function _isFuncOrString(value) {
                        return _isFunction(value) || _isString(value)
                    },
                    _isTypedArray = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                    _isArray = Array.isArray,
                    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
                    _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                    _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                    _relExp = /[+-]=-?[.\d]+/,
                    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
                    _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                    _globals = {},
                    _installScope = {},
                    _install = function _install(scope) {
                        return (_installScope = _merge(scope, _globals)) && gsap
                    },
                    _missingPlugin = function _missingPlugin(property, value) {
                        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()")
                    },
                    _warn = function _warn(message, suppress) {
                        return !suppress && console.warn(message)
                    },
                    _addGlobal = function _addGlobal(name, obj) {
                        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals
                    },
                    _emptyFunc = function _emptyFunc() {
                        return 0
                    },
                    _startAtRevertConfig = {
                        suppressEvents: !0,
                        isStart: !0,
                        kill: !1
                    },
                    _revertConfigNoKill = {
                        suppressEvents: !0,
                        kill: !1
                    },
                    _revertConfig = {
                        suppressEvents: !0
                    },
                    _reservedProps = {},
                    _lazyTweens = [],
                    _lazyLookup = {},
                    _plugins = {},
                    _effects = {},
                    _nextGCFrame = 30,
                    _harnessPlugins = [],
                    _callbackNames = "",
                    _harness = function _harness(targets) {
                        var harnessPlugin, i, target = targets[0];
                        if (_isObject(target) || _isFunction(target) || (targets = [targets]), !(harnessPlugin = (target._gsap || {}).harness)) {
                            for (i = _harnessPlugins.length; i-- && !_harnessPlugins[i].targetTest(target););
                            harnessPlugin = _harnessPlugins[i]
                        }
                        for (i = targets.length; i--;) targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
                        return targets
                    },
                    _getCache = function _getCache(target) {
                        return target._gsap || _harness(toArray(target))[0]._gsap
                    },
                    _getProperty = function _getProperty(target, property, v) {
                        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v
                    },
                    _forEachName = function _forEachName(names, func) {
                        return (names = names.split(",")).forEach(func) || names
                    },
                    _round = function _round(value) {
                        return Math.round(1e5 * value) / 1e5 || 0
                    },
                    _roundPrecise = function _roundPrecise(value) {
                        return Math.round(1e7 * value) / 1e7 || 0
                    },
                    _parseRelative = function _parseRelative(start, value) {
                        var operator = value.charAt(0),
                            end = parseFloat(value.substr(2));
                        return start = parseFloat(start), "+" === operator ? start + end : "-" === operator ? start - end : "*" === operator ? start * end : start / end
                    },
                    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
                        for (var l = toFind.length, i = 0; toSearch.indexOf(toFind[i]) < 0 && ++i < l;);
                        return i < l
                    },
                    _lazyRender = function _lazyRender() {
                        var i, tween, l = _lazyTweens.length,
                            a = _lazyTweens.slice(0);
                        for (_lazyLookup = {}, _lazyTweens.length = 0, i = 0; i < l; i++)(tween = a[i]) && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], !0)._lazy = 0)
                    },
                    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
                        _lazyTweens.length && !_reverting && _lazyRender(), animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt)), _lazyTweens.length && !_reverting && _lazyRender()
                    },
                    _numericIfPossible = function _numericIfPossible(value) {
                        var n = parseFloat(value);
                        return (n || 0 === n) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value
                    },
                    _passThrough = function _passThrough(p) {
                        return p
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) p in obj || (obj[p] = defaults[p]);
                        return obj
                    },
                    _merge = function _merge(base, toMerge) {
                        for (var p in toMerge) base[p] = toMerge[p];
                        return base
                    },
                    _mergeDeep = function _mergeDeep(base, toMerge) {
                        for (var p in toMerge) "__proto__" !== p && "constructor" !== p && "prototype" !== p && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
                        return base
                    },
                    _copyExcluding = function _copyExcluding(obj, excluding) {
                        var p, copy = {};
                        for (p in obj) p in excluding || (copy[p] = obj[p]);
                        return copy
                    },
                    _inheritDefaults = function _inheritDefaults(vars) {
                        var parent = vars.parent || _globalTimeline,
                            func = vars.keyframes ? function _setKeyframeDefaults(excludeDuration) {
                                return function(obj, defaults) {
                                    for (var p in defaults) p in obj || "duration" === p && excludeDuration || "ease" === p || (obj[p] = defaults[p])
                                }
                            }(_isArray(vars.keyframes)) : _setDefaults;
                        if (_isNotFalse(vars.inherit))
                            for (; parent;) func(vars, parent.vars.defaults), parent = parent.parent || parent._dp;
                        return vars
                    },
                    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
                        void 0 === firstProp && (firstProp = "_first"), void 0 === lastProp && (lastProp = "_last");
                        var t, prev = parent[lastProp];
                        if (sortBy)
                            for (t = child[sortBy]; prev && prev[sortBy] > t;) prev = prev._prev;
                        return prev ? (child._next = prev._next, prev._next = child) : (child._next = parent[firstProp], parent[firstProp] = child), child._next ? child._next._prev = child : parent[lastProp] = child, child._prev = prev, child.parent = child._dp = parent, child
                    },
                    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
                        void 0 === firstProp && (firstProp = "_first"), void 0 === lastProp && (lastProp = "_last");
                        var prev = child._prev,
                            next = child._next;
                        prev ? prev._next = next : parent[firstProp] === child && (parent[firstProp] = next), next ? next._prev = prev : parent[lastProp] === child && (parent[lastProp] = prev), child._next = child._prev = child.parent = null
                    },
                    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
                        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child), child._act = 0
                    },
                    _uncache = function _uncache(animation, child) {
                        if (animation && (!child || child._end > animation._dur || child._start < 0))
                            for (var a = animation; a;) a._dirty = 1, a = a.parent;
                        return animation
                    },
                    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
                        return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, !0, force))
                    },
                    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
                        return !animation || animation._ts && _hasNoPausedAncestors(animation.parent)
                    },
                    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
                        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0
                    },
                    _animationCycle = function _animationCycle(tTime, cycleDuration) {
                        var whole = Math.floor(tTime /= cycleDuration);
                        return tTime && whole === tTime ? whole - 1 : whole
                    },
                    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
                        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur)
                    },
                    _setEnd = function _setEnd(animation) {
                        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || 1e-8) || 0))
                    },
                    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
                        var parent = animation._dp;
                        return parent && parent.smoothChildTiming && animation._ts && (animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts)), _setEnd(animation), parent._dirty || _uncache(parent, animation)), animation
                    },
                    _postAddChecks = function _postAddChecks(timeline, child) {
                        var t;
                        if ((child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) && (t = _parentToChildTotalTime(timeline.rawTime(), child), (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > 1e-8) && child.render(t, !0)), _uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
                            if (timeline._dur < timeline.duration())
                                for (t = timeline; t._dp;) t.rawTime() >= 0 && t.totalTime(t._tTime), t = t._dp;
                            timeline._zTime = -1e-8
                        }
                    },
                    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
                        return child.parent && _removeFromParent(child), child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay), child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0)), _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0), _isFromOrFromStart(child) || (timeline._recent = child), skipChecks || _postAddChecks(timeline, child), timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime), timeline
                    },
                    _scrollTrigger = function _scrollTrigger(animation, trigger) {
                        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation)
                    },
                    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
                        return _initTween(tween, time, tTime), tween._initted ? !force && tween._pt && !_reverting && (tween._dur && !1 !== tween.vars.lazy || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame ? (_lazyTweens.push(tween), tween._lazy = [tTime, suppressEvents], 1) : void 0 : 1
                    },
                    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
                        var parent = _ref.parent;
                        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent))
                    },
                    _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
                        var data = _ref2.data;
                        return "isFromStart" === data || "isStart" === data
                    },
                    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
                        var repeat = animation._repeat,
                            dur = _roundPrecise(duration) || 0,
                            totalProgress = animation._tTime / animation._tDur;
                        return totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur), animation._dur = dur, animation._tDur = repeat ? repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat) : dur, totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress), animation.parent && _setEnd(animation), skipUncache || _uncache(animation.parent, animation), animation
                    },
                    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
                        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur)
                    },
                    _zeroPosition = {
                        _start: 0,
                        endTime: _emptyFunc,
                        totalDuration: _emptyFunc
                    },
                    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
                        var i, offset, isPercent, labels = animation.labels,
                            recent = animation._recent || _zeroPosition,
                            clippedDuration = animation.duration() >= _bigNum ? recent.endTime(!1) : animation._dur;
                        return _isString(position) && (isNaN(position) || position in labels) ? (offset = position.charAt(0), isPercent = "%" === position.substr(-1), i = position.indexOf("="), "<" === offset || ">" === offset ? (i >= 0 && (position = position.replace(/=/, "")), ("<" === offset ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1)) : i < 0 ? (position in labels || (labels[position] = clippedDuration), labels[position]) : (offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1)), isPercent && percentAnimation && (offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration()), i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset)) : null == position ? clippedDuration : +position
                    },
                    _createTweenType = function _createTweenType(type, params, timeline) {
                        var irVars, parent, isLegacy = _isNumber(params[1]),
                            varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
                            vars = params[varsIndex];
                        if (isLegacy && (vars.duration = params[1]), vars.parent = timeline, type) {
                            for (irVars = vars, parent = timeline; parent && !("immediateRender" in irVars);) irVars = parent.vars.defaults || {}, parent = _isNotFalse(parent.vars.inherit) && parent.parent;
                            vars.immediateRender = _isNotFalse(irVars.immediateRender), type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]
                        }
                        return new Tween(params[0], vars, params[varsIndex + 1])
                    },
                    _conditionalReturn = function _conditionalReturn(value, func) {
                        return value || 0 === value ? func(value) : func
                    },
                    _clamp = function _clamp(min, max, value) {
                        return value < min ? min : value > max ? max : value
                    },
                    getUnit = function getUnit(value, v) {
                        return _isString(value) && (v = _unitExp.exec(value)) ? v[1] : ""
                    },
                    clamp = function clamp(min, max, value) {
                        return _conditionalReturn(value, (function(v) {
                            return _clamp(min, max, v)
                        }))
                    },
                    _slice = [].slice,
                    _isArrayLike = function _isArrayLike(value, nonEmpty) {
                        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win
                    },
                    _flatten = function _flatten(ar, leaveStrings, accumulator) {
                        return void 0 === accumulator && (accumulator = []), ar.forEach((function(value) {
                            var _accumulator;
                            return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value)
                        })) || accumulator
                    },
                    toArray = function toArray(value, scope, leaveStrings) {
                        return _context && !scope && _context.selector ? _context.selector(value) : !_isString(value) || leaveStrings || !_coreInitted && _wake() ? _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [] : _slice.call((scope || _doc).querySelectorAll(value), 0)
                    },
                    selector = function selector(value) {
                        return value = toArray(value)[0] || _warn("Invalid scope") || {},
                            function(v) {
                                var el = value.current || value.nativeElement || value;
                                return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value)
                            }
                    },
                    shuffle = function shuffle(a) {
                        return a.sort((function() {
                            return .5 - Math.random()
                        }))
                    },
                    distribute = function distribute(v) {
                        if (_isFunction(v)) return v;
                        var vars = _isObject(v) ? v : {
                                each: v
                            },
                            ease = _parseEase(vars.ease),
                            from = vars.from || 0,
                            base = parseFloat(vars.base) || 0,
                            cache = {},
                            isDecimal = from > 0 && from < 1,
                            ratios = isNaN(from) || isDecimal,
                            axis = vars.axis,
                            ratioX = from,
                            ratioY = from;
                        return _isString(from) ? ratioX = ratioY = {
                                center: .5,
                                edges: .5,
                                end: 1
                            } [from] || 0 : !isDecimal && ratios && (ratioX = from[0], ratioY = from[1]),
                            function(i, target, a) {
                                var originX, originY, x, y, d, j, max, min, wrapAt, l = (a || vars).length,
                                    distances = cache[l];
                                if (!distances) {
                                    if (!(wrapAt = "auto" === vars.grid ? 0 : (vars.grid || [1, _bigNum])[1])) {
                                        for (max = -_bigNum; max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l;);
                                        wrapAt--
                                    }
                                    for (distances = cache[l] = [], originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt, originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0, max = 0, min = _bigNum, j = 0; j < l; j++) x = j % wrapAt - originX, y = originY - (j / wrapAt | 0), distances[j] = d = axis ? Math.abs("y" === axis ? y : x) : _sqrt(x * x + y * y), d > max && (max = d), d < min && (min = d);
                                    "random" === from && shuffle(distances), distances.max = max - min, distances.min = min, distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : axis ? "y" === axis ? l / wrapAt : wrapAt : Math.max(wrapAt, l / wrapAt)) || 0) * ("edges" === from ? -1 : 1), distances.b = l < 0 ? base - l : base, distances.u = getUnit(vars.amount || vars.each) || 0, ease = ease && l < 0 ? _invertEase(ease) : ease
                                }
                                return l = (distances[i] - distances.min) / distances.max || 0, _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u
                            }
                    },
                    _roundModifier = function _roundModifier(v) {
                        var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
                        return function(raw) {
                            var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
                            return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw))
                        }
                    },
                    snap = function snap(snapTo, value) {
                        var radius, is2D, isArray = _isArray(snapTo);
                        return !isArray && _isObject(snapTo) && (radius = isArray = snapTo.radius || _bigNum, snapTo.values ? (snapTo = toArray(snapTo.values), (is2D = !_isNumber(snapTo[0])) && (radius *= radius)) : snapTo = _roundModifier(snapTo.increment)), _conditionalReturn(value, isArray ? _isFunction(snapTo) ? function(raw) {
                            return is2D = snapTo(raw), Math.abs(is2D - raw) <= radius ? is2D : raw
                        } : function(raw) {
                            for (var dx, dy, x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length; i--;)(dx = is2D ? (dx = snapTo[i].x - x) * dx + (dy = snapTo[i].y - y) * dy : Math.abs(snapTo[i] - x)) < min && (min = dx, closest = i);
                            return closest = !radius || min <= radius ? snapTo[closest] : raw, is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw)
                        } : _roundModifier(snapTo))
                    },
                    random = function random(min, max, roundingIncrement, returnFunction) {
                        return _conditionalReturn(_isArray(min) ? !max : !0 === roundingIncrement ? !!(roundingIncrement = 0) : !returnFunction, (function() {
                            return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + .99 * roundingIncrement)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction
                        }))
                    },
                    pipe = function pipe() {
                        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) functions[_key] = arguments[_key];
                        return function(value) {
                            return functions.reduce((function(v, f) {
                                return f(v)
                            }), value)
                        }
                    },
                    unitize = function unitize(func, unit) {
                        return function(value) {
                            return func(parseFloat(value)) + (unit || getUnit(value))
                        }
                    },
                    normalize = function normalize(min, max, value) {
                        return mapRange(min, max, 0, 1, value)
                    },
                    _wrapArray = function _wrapArray(a, wrapper, value) {
                        return _conditionalReturn(value, (function(index) {
                            return a[~~wrapper(index)]
                        }))
                    },
                    wrap = function wrap(min, max, value) {
                        var range = max - min;
                        return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, (function(value) {
                            return (range + (value - min) % range) % range + min
                        }))
                    },
                    wrapYoyo = function wrapYoyo(min, max, value) {
                        var range = max - min,
                            total = 2 * range;
                        return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, (function(value) {
                            return min + ((value = (total + (value - min) % total) % total || 0) > range ? total - value : value)
                        }))
                    },
                    _replaceRandom = function _replaceRandom(value) {
                        for (var i, nums, end, isArray, prev = 0, s = ""; ~(i = value.indexOf("random(", prev));) end = value.indexOf(")", i), isArray = "[" === value.charAt(i + 7), nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp), s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5), prev = end + 1;
                        return s + value.substr(prev, value.length - prev)
                    },
                    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
                        var inRange = inMax - inMin,
                            outRange = outMax - outMin;
                        return _conditionalReturn(value, (function(value) {
                            return outMin + ((value - inMin) / inRange * outRange || 0)
                        }))
                    },
                    interpolate = function interpolate(start, end, progress, mutate) {
                        var func = isNaN(start + end) ? 0 : function(p) {
                            return (1 - p) * start + p * end
                        };
                        if (!func) {
                            var p, i, interpolators, l, il, isString = _isString(start),
                                master = {};
                            if (!0 === progress && (mutate = 1) && (progress = null), isString) start = {
                                p: start
                            }, end = {
                                p: end
                            };
                            else if (_isArray(start) && !_isArray(end)) {
                                for (interpolators = [], l = start.length, il = l - 2, i = 1; i < l; i++) interpolators.push(interpolate(start[i - 1], start[i]));
                                l--, func = function func(p) {
                                    p *= l;
                                    var i = Math.min(il, ~~p);
                                    return interpolators[i](p - i)
                                }, progress = end
                            } else mutate || (start = _merge(_isArray(start) ? [] : {}, start));
                            if (!interpolators) {
                                for (p in end) _addPropTween.call(master, start, p, "get", end[p]);
                                func = function func(p) {
                                    return _renderPropTweens(p, master) || (isString ? start.p : start)
                                }
                            }
                        }
                        return _conditionalReturn(progress, func)
                    },
                    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
                        var p, distance, label, labels = timeline.labels,
                            min = _bigNum;
                        for (p in labels)(distance = labels[p] - fromTime) < 0 == !!backward && distance && min > (distance = Math.abs(distance)) && (label = p, min = distance);
                        return label
                    },
                    _callback = function _callback(animation, type, executeLazyFirst) {
                        var params, scope, result, v = animation.vars,
                            callback = v[type],
                            prevContext = _context,
                            context = animation._ctx;
                        if (callback) return params = v[type + "Params"], scope = v.callbackScope || animation, executeLazyFirst && _lazyTweens.length && _lazyRender(), context && (_context = context), result = params ? callback.apply(scope, params) : callback.call(scope), _context = prevContext, result
                    },
                    _interrupt = function _interrupt(animation) {
                        return _removeFromParent(animation), animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting), animation.progress() < 1 && _callback(animation, "onInterrupt"), animation
                    },
                    _registerPluginQueue = [],
                    _createPlugin = function _createPlugin(config) {
                        if (_windowExists() && config) {
                            var name = (config = !config.name && config.default || config).name,
                                isFunc = _isFunction(config),
                                Plugin = name && !isFunc && config.init ? function() {
                                    this._props = []
                                } : config,
                                instanceDefaults = {
                                    init: _emptyFunc,
                                    render: _renderPropTweens,
                                    add: _addPropTween,
                                    kill: _killPropTweensOf,
                                    modifier: _addPluginModifier,
                                    rawVars: 0
                                },
                                statics = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: _getSetter,
                                    aliases: {},
                                    register: 0
                                };
                            if (_wake(), config !== Plugin) {
                                if (_plugins[name]) return;
                                _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)), _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))), _plugins[Plugin.prop = name] = Plugin, config.targetTest && (_harnessPlugins.push(Plugin), _reservedProps[name] = 1), name = ("css" === name ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"
                            }
                            _addGlobal(name, Plugin), config.register && config.register(gsap, Plugin, PropTween)
                        } else config && _registerPluginQueue.push(config)
                    },
                    _colorLookup = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    },
                    _hue = function _hue(h, m1, m2) {
                        return 255 * (6 * (h += h < 0 ? 1 : h > 1 ? -1 : 0) < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : 3 * h < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) + .5 | 0
                    },
                    splitColor = function splitColor(v, toHSL, forceAlpha) {
                        var r, g, b, h, s, l, max, min, d, wasHSL, a = v ? _isNumber(v) ? [v >> 16, v >> 8 & 255, 255 & v] : 0 : _colorLookup.black;
                        if (!a) {
                            if ("," === v.substr(-1) && (v = v.substr(0, v.length - 1)), _colorLookup[v]) a = _colorLookup[v];
                            else if ("#" === v.charAt(0)) {
                                if (v.length < 6 && (r = v.charAt(1), g = v.charAt(2), b = v.charAt(3), v = "#" + r + r + g + g + b + b + (5 === v.length ? v.charAt(4) + v.charAt(4) : "")), 9 === v.length) return [(a = parseInt(v.substr(1, 6), 16)) >> 16, a >> 8 & 255, 255 & a, parseInt(v.substr(7), 16) / 255];
                                a = [(v = parseInt(v.substr(1), 16)) >> 16, v >> 8 & 255, 255 & v]
                            } else if ("hsl" === v.substr(0, 3))
                                if (a = wasHSL = v.match(_strictNumExp), toHSL) {
                                    if (~v.indexOf("=")) return a = v.match(_numExp), forceAlpha && a.length < 4 && (a[3] = 1), a
                                } else h = +a[0] % 360 / 360, s = +a[1] / 100, r = 2 * (l = +a[2] / 100) - (g = l <= .5 ? l * (s + 1) : l + s - l * s), a.length > 3 && (a[3] *= 1), a[0] = _hue(h + 1 / 3, r, g), a[1] = _hue(h, r, g), a[2] = _hue(h - 1 / 3, r, g);
                            else a = v.match(_strictNumExp) || _colorLookup.transparent;
                            a = a.map(Number)
                        }
                        return toHSL && !wasHSL && (r = a[0] / 255, g = a[1] / 255, b = a[2] / 255, l = ((max = Math.max(r, g, b)) + (min = Math.min(r, g, b))) / 2, max === min ? h = s = 0 : (d = max - min, s = l > .5 ? d / (2 - max - min) : d / (max + min), h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4, h *= 60), a[0] = ~~(h + .5), a[1] = ~~(100 * s + .5), a[2] = ~~(100 * l + .5)), forceAlpha && a.length < 4 && (a[3] = 1), a
                    },
                    _colorOrderData = function _colorOrderData(v) {
                        var values = [],
                            c = [],
                            i = -1;
                        return v.split(_colorExp).forEach((function(v) {
                            var a = v.match(_numWithUnitExp) || [];
                            values.push.apply(values, a), c.push(i += a.length + 1)
                        })), values.c = c, values
                    },
                    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
                        var c, shell, d, l, result = "",
                            colors = (s + result).match(_colorExp),
                            type = toHSL ? "hsla(" : "rgba(",
                            i = 0;
                        if (!colors) return s;
                        if (colors = colors.map((function(color) {
                                return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")"
                            })), orderMatchData && (d = _colorOrderData(s), (c = orderMatchData.c).join(result) !== d.c.join(result)))
                            for (l = (shell = s.replace(_colorExp, "1").split(_numWithUnitExp)).length - 1; i < l; i++) result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
                        if (!shell)
                            for (l = (shell = s.split(_colorExp)).length - 1; i < l; i++) result += shell[i] + colors[i];
                        return result + shell[l]
                    },
                    _colorExp = function() {
                        var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                        for (p in _colorLookup) s += "|" + p + "\\b";
                        return new RegExp(s + ")", "gi")
                    }(),
                    _hslExp = /hsl[a]?\(/,
                    _colorStringFilter = function _colorStringFilter(a) {
                        var toHSL, combined = a.join(" ");
                        if (_colorExp.lastIndex = 0, _colorExp.test(combined)) return toHSL = _hslExp.test(combined), a[1] = _formatColors(a[1], toHSL), a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])), !0
                    },
                    _ticker = function() {
                        var _id, _req, _raf, _self, _delta, _i, _getTime = Date.now,
                            _lagThreshold = 500,
                            _adjustedLag = 33,
                            _startTime = _getTime(),
                            _lastUpdate = _startTime,
                            _gap = 1e3 / 240,
                            _nextTime = _gap,
                            _listeners = [],
                            _tick = function _tick(v) {
                                var overlap, dispatch, time, frame, elapsed = _getTime() - _lastUpdate,
                                    manual = !0 === v;
                                if (elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag), ((overlap = (time = (_lastUpdate += elapsed) - _startTime) - _nextTime) > 0 || manual) && (frame = ++_self.frame, _delta = time - 1e3 * _self.time, _self.time = time /= 1e3, _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap), dispatch = 1), manual || (_id = _req(_tick)), dispatch)
                                    for (_i = 0; _i < _listeners.length; _i++) _listeners[_i](time, _delta, frame, v)
                            };
                        return _self = {
                            time: 0,
                            frame: 0,
                            tick: function tick() {
                                _tick(!0)
                            },
                            deltaRatio: function deltaRatio(fps) {
                                return _delta / (1e3 / (fps || 60))
                            },
                            wake: function wake() {
                                _coreReady && (!_coreInitted && _windowExists() && (_win = _coreInitted = window, _doc = _win.document || {}, _globals.gsap = gsap, (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version), _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {}), _raf = _win.requestAnimationFrame, _registerPluginQueue.forEach(_createPlugin)), _id && _self.sleep(), _req = _raf || function(f) {
                                    return setTimeout(f, _nextTime - 1e3 * _self.time + 1 | 0)
                                }, _tickerActive = 1, _tick(2))
                            },
                            sleep: function sleep() {
                                (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id), _tickerActive = 0, _req = _emptyFunc
                            },
                            lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                                _lagThreshold = threshold || 1 / 0, _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold)
                            },
                            fps: function fps(_fps) {
                                _gap = 1e3 / (_fps || 240), _nextTime = 1e3 * _self.time + _gap
                            },
                            add: function add(callback, once, prioritize) {
                                var func = once ? function(t, d, f, v) {
                                    callback(t, d, f, v), _self.remove(func)
                                } : callback;
                                return _self.remove(callback), _listeners[prioritize ? "unshift" : "push"](func), _wake(), func
                            },
                            remove: function remove(callback, i) {
                                ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--
                            },
                            _listeners: _listeners
                        }
                    }(),
                    _wake = function _wake() {
                        return !_tickerActive && _ticker.wake()
                    },
                    _easeMap = {},
                    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
                    _quotesExp = /["']/g,
                    _parseObjectInString = function _parseObjectInString(value) {
                        for (var index, val, parsedVal, obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length; i < l; i++) val = split[i], index = i !== l - 1 ? val.lastIndexOf(",") : val.length, parsedVal = val.substr(0, index), obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal, key = val.substr(index + 1).trim();
                        return obj
                    },
                    _invertEase = function _invertEase(ease) {
                        return function(p) {
                            return 1 - ease(1 - p)
                        }
                    },
                    _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
                        for (var ease, child = timeline._first; child;) child instanceof Timeline ? _propagateYoyoEase(child, isYoyo) : !child.vars.yoyoEase || child._yoyo && child._repeat || child._yoyo === isYoyo || (child.timeline ? _propagateYoyoEase(child.timeline, isYoyo) : (ease = child._ease, child._ease = child._yEase, child._yEase = ease, child._yoyo = isYoyo)), child = child._next
                    },
                    _parseEase = function _parseEase(ease, defaultEase) {
                        return ease && (_isFunction(ease) ? ease : _easeMap[ease] || function _configEaseFromString(name) {
                            var split = (name + "").split("("),
                                ease = _easeMap[split[0]];
                            return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : function _valueInParentheses(value) {
                                var open = value.indexOf("(") + 1,
                                    close = value.indexOf(")"),
                                    nested = value.indexOf("(", open);
                                return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close)
                            }(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease
                        }(ease)) || defaultEase
                    },
                    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
                        void 0 === easeOut && (easeOut = function easeOut(p) {
                            return 1 - easeIn(1 - p)
                        }), void 0 === easeInOut && (easeInOut = function easeInOut(p) {
                            return p < .5 ? easeIn(2 * p) / 2 : 1 - easeIn(2 * (1 - p)) / 2
                        });
                        var lowercaseName, ease = {
                            easeIn: easeIn,
                            easeOut: easeOut,
                            easeInOut: easeInOut
                        };
                        return _forEachName(names, (function(name) {
                            for (var p in _easeMap[name] = _globals[name] = ease, _easeMap[lowercaseName = name.toLowerCase()] = easeOut, ease) _easeMap[lowercaseName + ("easeIn" === p ? ".in" : "easeOut" === p ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p]
                        })), ease
                    },
                    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
                        return function(p) {
                            return p < .5 ? (1 - easeOut(1 - 2 * p)) / 2 : .5 + easeOut(2 * (p - .5)) / 2
                        }
                    },
                    _configElastic = function _configElastic(type, amplitude, period) {
                        var p1 = amplitude >= 1 ? amplitude : 1,
                            p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
                            p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
                            easeOut = function easeOut(p) {
                                return 1 === p ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1
                            },
                            ease = "out" === type ? easeOut : "in" === type ? function(p) {
                                return 1 - easeOut(1 - p)
                            } : _easeInOutFromOut(easeOut);
                        return p2 = _2PI / p2, ease.config = function(amplitude, period) {
                            return _configElastic(type, amplitude, period)
                        }, ease
                    },
                    _configBack = function _configBack(type, overshoot) {
                        void 0 === overshoot && (overshoot = 1.70158);
                        var easeOut = function easeOut(p) {
                                return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0
                            },
                            ease = "out" === type ? easeOut : "in" === type ? function(p) {
                                return 1 - easeOut(1 - p)
                            } : _easeInOutFromOut(easeOut);
                        return ease.config = function(overshoot) {
                            return _configBack(type, overshoot)
                        }, ease
                    };
                _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", (function(name, i) {
                    var power = i < 5 ? i + 1 : i;
                    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
                        return Math.pow(p, power)
                    } : function(p) {
                        return p
                    }, (function(p) {
                        return 1 - Math.pow(1 - p, power)
                    }), (function(p) {
                        return p < .5 ? Math.pow(2 * p, power) / 2 : 1 - Math.pow(2 * (1 - p), power) / 2
                    }))
                })), _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn, _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic()), n = 7.5625, n1 = 1 / (c = 2.75), _insertEase("Bounce", (function(p) {
                    return 1 - easeOut(1 - p)
                }), easeOut = function easeOut(p) {
                    return p < n1 ? n * p * p : p < .7272727272727273 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < .9090909090909092 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375
                }), _insertEase("Expo", (function(p) {
                    return p ? Math.pow(2, 10 * (p - 1)) : 0
                })), _insertEase("Circ", (function(p) {
                    return -(_sqrt(1 - p * p) - 1)
                })), _insertEase("Sine", (function(p) {
                    return 1 === p ? 1 : 1 - _cos(p * _HALF_PI)
                })), _insertEase("Back", _configBack("in"), _configBack("out"), _configBack()), _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
                    config: function config(steps, immediateStart) {
                        void 0 === steps && (steps = 1);
                        var p1 = 1 / steps,
                            p2 = steps + (immediateStart ? 0 : 1),
                            p3 = immediateStart ? 1 : 0;
                        return function(p) {
                            return ((p2 * _clamp(0, .99999999, p) | 0) + p3) * p1
                        }
                    }
                }, _defaults.ease = _easeMap["quad.out"], _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(name) {
                    return _callbackNames += name + "," + name + "Params,"
                }));
                var GSCache = function GSCache(target, harness) {
                        this.id = _gsID++, target._gsap = this, this.target = target, this.harness = harness, this.get = harness ? harness.get : _getProperty, this.set = harness ? harness.getSetter : _getSetter
                    },
                    Animation = function() {
                        function Animation(vars) {
                            this.vars = vars, this._delay = +vars.delay || 0, (this._repeat = vars.repeat === 1 / 0 ? -2 : vars.repeat || 0) && (this._rDelay = vars.repeatDelay || 0, this._yoyo = !!vars.yoyo || !!vars.yoyoEase), this._ts = 1, _setDuration(this, +vars.duration, 1, 1), this.data = vars.data, _context && (this._ctx = _context, _context.data.push(this)), _tickerActive || _ticker.wake()
                        }
                        var _proto = Animation.prototype;
                        return _proto.delay = function delay(value) {
                            return value || 0 === value ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay), this._delay = value, this) : this._delay
                        }, _proto.duration = function duration(value) {
                            return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur
                        }, _proto.totalDuration = function totalDuration(value) {
                            return arguments.length ? (this._dirty = 0, _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                        }, _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
                            if (_wake(), !arguments.length) return this._tTime;
                            var parent = this._dp;
                            if (parent && parent.smoothChildTiming && this._ts) {
                                for (_alignPlayhead(this, _totalTime), !parent._dp || parent.parent || _postAddChecks(parent, this); parent && parent.parent;) parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts) && parent.totalTime(parent._tTime, !0), parent = parent.parent;
                                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime) && _addToTimeline(this._dp, this, this._start - this._delay)
                            }
                            return (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && 1e-8 === Math.abs(this._zTime) || !_totalTime && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = _totalTime), _lazySafeRender(this, _totalTime, suppressEvents)), this
                        }, _proto.time = function time(value, suppressEvents) {
                            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time
                        }, _proto.totalProgress = function totalProgress(value, suppressEvents) {
                            return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                        }, _proto.progress = function progress(value, suppressEvents) {
                            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? value : 1 - value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                        }, _proto.iteration = function iteration(value, suppressEvents) {
                            var cycleDuration = this.duration() + this._rDelay;
                            return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1
                        }, _proto.timeScale = function timeScale(value) {
                            if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                            if (this._rts === value) return this;
                            var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
                            return this._rts = +value || 0, this._ts = this._ps || -1e-8 === value ? 0 : this._rts, this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), !0), _setEnd(this),
                                function _recacheAncestors(animation) {
                                    for (var parent = animation.parent; parent && parent.parent;) parent._dirty = 1, parent.totalDuration(), parent = parent.parent;
                                    return animation
                                }(this)
                        }, _proto.paused = function paused(value) {
                            return arguments.length ? (this._ps !== value && (this._ps = value, value ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_wake(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && 1e-8 !== Math.abs(this._zTime) && (this._tTime -= 1e-8)))), this) : this._ps
                        }, _proto.startTime = function startTime(value) {
                            if (arguments.length) {
                                this._start = value;
                                var parent = this.parent || this._dp;
                                return parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay), this
                            }
                            return this._start
                        }, _proto.endTime = function endTime(includeRepeats) {
                            return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                        }, _proto.rawTime = function rawTime(wrapRepeats) {
                            var parent = this.parent || this._dp;
                            return parent ? wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(parent.rawTime(wrapRepeats), this) : this._tTime : this._tTime
                        }, _proto.revert = function revert(config) {
                            void 0 === config && (config = _revertConfig);
                            var prevIsReverting = _reverting;
                            return _reverting = config, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(config), this.totalTime(-.01, config.suppressEvents)), "nested" !== this.data && !1 !== config.kill && this.kill(), _reverting = prevIsReverting, this
                        }, _proto.globalTime = function globalTime(rawTime) {
                            for (var animation = this, time = arguments.length ? rawTime : animation.rawTime(); animation;) time = animation._start + time / (animation._ts || 1), animation = animation._dp;
                            return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(rawTime) : time
                        }, _proto.repeat = function repeat(value) {
                            return arguments.length ? (this._repeat = value === 1 / 0 ? -2 : value, _onUpdateTotalDuration(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                        }, _proto.repeatDelay = function repeatDelay(value) {
                            if (arguments.length) {
                                var time = this._time;
                                return this._rDelay = value, _onUpdateTotalDuration(this), time ? this.time(time) : this
                            }
                            return this._rDelay
                        }, _proto.yoyo = function yoyo(value) {
                            return arguments.length ? (this._yoyo = value, this) : this._yoyo
                        }, _proto.seek = function seek(position, suppressEvents) {
                            return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents))
                        }, _proto.restart = function restart(includeDelay, suppressEvents) {
                            return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents))
                        }, _proto.play = function play(from, suppressEvents) {
                            return null != from && this.seek(from, suppressEvents), this.reversed(!1).paused(!1)
                        }, _proto.reverse = function reverse(from, suppressEvents) {
                            return null != from && this.seek(from || this.totalDuration(), suppressEvents), this.reversed(!0).paused(!1)
                        }, _proto.pause = function pause(atTime, suppressEvents) {
                            return null != atTime && this.seek(atTime, suppressEvents), this.paused(!0)
                        }, _proto.resume = function resume() {
                            return this.paused(!1)
                        }, _proto.reversed = function reversed(value) {
                            return arguments.length ? (!!value !== this.reversed() && this.timeScale(-this._rts || (value ? -1e-8 : 0)), this) : this._rts < 0
                        }, _proto.invalidate = function invalidate() {
                            return this._initted = this._act = 0, this._zTime = -1e-8, this
                        }, _proto.isActive = function isActive() {
                            var rawTime, parent = this.parent || this._dp,
                                start = this._start;
                            return !(parent && !(this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(!0)) >= start && rawTime < this.endTime(!0) - 1e-8))
                        }, _proto.eventCallback = function eventCallback(type, callback, params) {
                            var vars = this.vars;
                            return arguments.length > 1 ? (callback ? (vars[type] = callback, params && (vars[type + "Params"] = params), "onUpdate" === type && (this._onUpdate = callback)) : delete vars[type], this) : vars[type]
                        }, _proto.then = function then(onFulfilled) {
                            var self = this;
                            return new Promise((function(resolve) {
                                var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
                                    _resolve = function _resolve() {
                                        var _then = self.then;
                                        self.then = null, _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then), resolve(f), self.then = _then
                                    };
                                self._initted && 1 === self.totalProgress() && self._ts >= 0 || !self._tTime && self._ts < 0 ? _resolve() : self._prom = _resolve
                            }))
                        }, _proto.kill = function kill() {
                            _interrupt(this)
                        }, Animation
                    }();
                _setDefaults(Animation.prototype, {
                    _time: 0,
                    _start: 0,
                    _end: 0,
                    _tTime: 0,
                    _tDur: 0,
                    _dirty: 0,
                    _repeat: 0,
                    _yoyo: !1,
                    parent: null,
                    _initted: !1,
                    _rDelay: 0,
                    _ts: 1,
                    _dp: 0,
                    ratio: 0,
                    _zTime: -1e-8,
                    _prom: 0,
                    _ps: !1,
                    _rts: 1
                });
                var Timeline = function(_Animation) {
                    function Timeline(vars, position) {
                        var _this;
                        return void 0 === vars && (vars = {}), (_this = _Animation.call(this, vars) || this).labels = {}, _this.smoothChildTiming = !!vars.smoothChildTiming, _this.autoRemoveChildren = !!vars.autoRemoveChildren, _this._sort = _isNotFalse(vars.sortChildren), _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position), vars.reversed && _this.reverse(), vars.paused && _this.paused(!0), vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger), _this
                    }
                    _inheritsLoose(Timeline, _Animation);
                    var _proto2 = Timeline.prototype;
                    return _proto2.to = function to(targets, vars, position) {
                        return _createTweenType(0, arguments, this), this
                    }, _proto2.from = function from(targets, vars, position) {
                        return _createTweenType(1, arguments, this), this
                    }, _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
                        return _createTweenType(2, arguments, this), this
                    }, _proto2.set = function set(targets, vars, position) {
                        return vars.duration = 0, vars.parent = this, _inheritDefaults(vars).repeatDelay || (vars.repeat = 0), vars.immediateRender = !!vars.immediateRender, new Tween(targets, vars, _parsePosition(this, position), 1), this
                    }, _proto2.call = function call(callback, params, position) {
                        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position)
                    }, _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        return vars.duration = duration, vars.stagger = vars.stagger || stagger, vars.onComplete = onCompleteAll, vars.onCompleteParams = onCompleteAllParams, vars.parent = this, new Tween(targets, vars, _parsePosition(this, position)), this
                    }, _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        return vars.runBackwards = 1, _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender), this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams)
                    }, _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        return toVars.startAt = fromVars, _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender), this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams)
                    }, _proto2.render = function render(totalTime, suppressEvents, force) {
                        var time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo, prevTime = this._time,
                            tDur = this._dirty ? this.totalDuration() : this._tDur,
                            dur = this._dur,
                            tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
                            crossingStart = this._zTime < 0 != totalTime < 0 && (this._initted || !dur);
                        if (this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur), tTime !== this._tTime || force || crossingStart) {
                            if (prevTime !== this._time && dur && (tTime += this._time - prevTime, totalTime += this._time - prevTime), time = tTime, prevStart = this._start, prevPaused = !(timeScale = this._ts), crossingStart && (dur || (prevTime = this._zTime), (totalTime || !suppressEvents) && (this._zTime = totalTime)), this._repeat) {
                                if (yoyo = this._yoyo, cycleDuration = dur + this._rDelay, this._repeat < -1 && totalTime < 0) return this.totalTime(100 * cycleDuration + totalTime, suppressEvents, force);
                                if (time = _roundPrecise(tTime % cycleDuration), tTime === tDur ? (iteration = this._repeat, time = dur) : ((iteration = ~~(tTime / cycleDuration)) && iteration === tTime / cycleDuration && (time = dur, iteration--), time > dur && (time = dur)), prevIteration = _animationCycle(this._tTime, cycleDuration), !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration), yoyo && 1 & iteration && (time = dur - time, isYoyo = 1), iteration !== prevIteration && !this._lock) {
                                    var rewinding = yoyo && 1 & prevIteration,
                                        doesWrap = rewinding === (yoyo && 1 & iteration);
                                    if (iteration < prevIteration && (rewinding = !rewinding), prevTime = rewinding ? 0 : tTime % dur ? dur : tTime, this._lock = 1, this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0, this._tTime = tTime, !suppressEvents && this.parent && _callback(this, "onRepeat"), this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1), prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                                    if (dur = this._dur, tDur = this._tDur, doesWrap && (this._lock = 2, prevTime = rewinding ? dur : -1e-4, this.render(prevTime, !0), this.vars.repeatRefresh && !isYoyo && this.invalidate()), this._lock = 0, !this._ts && !prevPaused) return this;
                                    _propagateYoyoEase(this, isYoyo)
                                }
                            }
                            if (this._hasPause && !this._forcing && this._lock < 2 && (pauseTween = function _findNextPauseTween(animation, prevTime, time) {
                                    var child;
                                    if (time > prevTime)
                                        for (child = animation._first; child && child._start <= time;) {
                                            if ("isPause" === child.data && child._start > prevTime) return child;
                                            child = child._next
                                        } else
                                            for (child = animation._last; child && child._start >= time;) {
                                                if ("isPause" === child.data && child._start < prevTime) return child;
                                                child = child._prev
                                            }
                                }(this, _roundPrecise(prevTime), _roundPrecise(time)), pauseTween && (tTime -= time - (time = pauseTween._start))), this._tTime = tTime, this._time = time, this._act = !timeScale, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = totalTime, prevTime = 0), !prevTime && time && !suppressEvents && !iteration && (_callback(this, "onStart"), this._tTime !== tTime)) return this;
                            if (time >= prevTime && totalTime >= 0)
                                for (child = this._first; child;) {
                                    if (next = child._next, (child._act || time >= child._start) && child._ts && pauseTween !== child) {
                                        if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                        if (child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force), time !== this._time || !this._ts && !prevPaused) {
                                            pauseTween = 0, next && (tTime += this._zTime = -1e-8);
                                            break
                                        }
                                    }
                                    child = next
                                } else {
                                    child = this._last;
                                    for (var adjustedTime = totalTime < 0 ? totalTime : time; child;) {
                                        if (next = child._prev, (child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                                            if (child.parent !== this) return this.render(totalTime, suppressEvents, force);
                                            if (child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)), time !== this._time || !this._ts && !prevPaused) {
                                                pauseTween = 0, next && (tTime += this._zTime = adjustedTime ? -1e-8 : 1e-8);
                                                break
                                            }
                                        }
                                        child = next
                                    }
                                }
                            if (pauseTween && !suppressEvents && (this.pause(), pauseTween.render(time >= prevTime ? 0 : -1e-8)._zTime = time >= prevTime ? 1 : -1, this._ts)) return this._start = prevStart, _setEnd(this), this.render(totalTime, suppressEvents, force);
                            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", !0), (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) && (prevStart !== this._start && Math.abs(timeScale) === Math.abs(this._ts) || this._lock || ((totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1), suppressEvents || totalTime < 0 && !prevTime || !tTime && !prevTime && tDur || (_callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom())))
                        }
                        return this
                    }, _proto2.add = function add(child, position) {
                        var _this2 = this;
                        if (_isNumber(position) || (position = _parsePosition(this, position, child)), !(child instanceof Animation)) {
                            if (_isArray(child)) return child.forEach((function(obj) {
                                return _this2.add(obj, position)
                            })), this;
                            if (_isString(child)) return this.addLabel(child, position);
                            if (!_isFunction(child)) return this;
                            child = Tween.delayedCall(0, child)
                        }
                        return this !== child ? _addToTimeline(this, child, position) : this
                    }, _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
                        void 0 === nested && (nested = !0), void 0 === tweens && (tweens = !0), void 0 === timelines && (timelines = !0), void 0 === ignoreBeforeTime && (ignoreBeforeTime = -_bigNum);
                        for (var a = [], child = this._first; child;) child._start >= ignoreBeforeTime && (child instanceof Tween ? tweens && a.push(child) : (timelines && a.push(child), nested && a.push.apply(a, child.getChildren(!0, tweens, timelines)))), child = child._next;
                        return a
                    }, _proto2.getById = function getById(id) {
                        for (var animations = this.getChildren(1, 1, 1), i = animations.length; i--;)
                            if (animations[i].vars.id === id) return animations[i]
                    }, _proto2.remove = function remove(child) {
                        return _isString(child) ? this.removeLabel(child) : _isFunction(child) ? this.killTweensOf(child) : (_removeLinkedListItem(this, child), child === this._recent && (this._recent = this._last), _uncache(this))
                    }, _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
                        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts))), _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents), this._forcing = 0, this) : this._tTime
                    }, _proto2.addLabel = function addLabel(label, position) {
                        return this.labels[label] = _parsePosition(this, position), this
                    }, _proto2.removeLabel = function removeLabel(label) {
                        return delete this.labels[label], this
                    }, _proto2.addPause = function addPause(position, callback, params) {
                        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
                        return t.data = "isPause", this._hasPause = 1, _addToTimeline(this, t, _parsePosition(this, position))
                    }, _proto2.removePause = function removePause(position) {
                        var child = this._first;
                        for (position = _parsePosition(this, position); child;) child._start === position && "isPause" === child.data && _removeFromParent(child), child = child._next
                    }, _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        for (var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length; i--;) _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
                        return this
                    }, _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                        for (var children, a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive); child;) child instanceof Tween ? _arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive()) && a.push(child) : (children = child.getTweensOf(parsedTargets, onlyActive)).length && a.push.apply(a, children), child = child._next;
                        return a
                    }, _proto2.tweenTo = function tweenTo(position, vars) {
                        vars = vars || {};
                        var initted, tl = this,
                            endTime = _parsePosition(tl, position),
                            _vars = vars,
                            startAt = _vars.startAt,
                            _onStart = _vars.onStart,
                            onStartParams = _vars.onStartParams,
                            immediateRender = _vars.immediateRender,
                            tween = Tween.to(tl, _setDefaults({
                                ease: vars.ease || "none",
                                lazy: !1,
                                immediateRender: !1,
                                time: endTime,
                                overwrite: "auto",
                                duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || 1e-8,
                                onStart: function onStart() {
                                    if (tl.pause(), !initted) {
                                        var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                                        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, !0, !0), initted = 1
                                    }
                                    _onStart && _onStart.apply(tween, onStartParams || [])
                                }
                            }, vars));
                        return immediateRender ? tween.render(0) : tween
                    }, _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
                        return this.tweenTo(toPosition, _setDefaults({
                            startAt: {
                                time: _parsePosition(this, fromPosition)
                            }
                        }, vars))
                    }, _proto2.recent = function recent() {
                        return this._recent
                    }, _proto2.nextLabel = function nextLabel(afterTime) {
                        return void 0 === afterTime && (afterTime = this._time), _getLabelInDirection(this, _parsePosition(this, afterTime))
                    }, _proto2.previousLabel = function previousLabel(beforeTime) {
                        return void 0 === beforeTime && (beforeTime = this._time), _getLabelInDirection(this, _parsePosition(this, beforeTime), 1)
                    }, _proto2.currentLabel = function currentLabel(value) {
                        return arguments.length ? this.seek(value, !0) : this.previousLabel(this._time + 1e-8)
                    }, _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
                        void 0 === ignoreBeforeTime && (ignoreBeforeTime = 0);
                        for (var p, child = this._first, labels = this.labels; child;) child._start >= ignoreBeforeTime && (child._start += amount, child._end += amount), child = child._next;
                        if (adjustLabels)
                            for (p in labels) labels[p] >= ignoreBeforeTime && (labels[p] += amount);
                        return _uncache(this)
                    }, _proto2.invalidate = function invalidate(soft) {
                        var child = this._first;
                        for (this._lock = 0; child;) child.invalidate(soft), child = child._next;
                        return _Animation.prototype.invalidate.call(this, soft)
                    }, _proto2.clear = function clear(includeLabels) {
                        void 0 === includeLabels && (includeLabels = !0);
                        for (var next, child = this._first; child;) next = child._next, this.remove(child), child = next;
                        return this._dp && (this._time = this._tTime = this._pTime = 0), includeLabels && (this.labels = {}), _uncache(this)
                    }, _proto2.totalDuration = function totalDuration(value) {
                        var prev, start, parent, max = 0,
                            child = this._last,
                            prevStart = _bigNum;
                        if (arguments.length) return this.timeScale((this._repeat < 0 ? this.duration() : this.totalDuration()) / (this.reversed() ? -value : value));
                        if (this._dirty) {
                            for (parent = this.parent; child;) prev = child._prev, child._dirty && child.totalDuration(), (start = child._start) > prevStart && this._sort && child._ts && !this._lock ? (this._lock = 1, _addToTimeline(this, child, start - child._delay, 1)._lock = 0) : prevStart = start, start < 0 && child._ts && (max -= start, (!parent && !this._dp || parent && parent.smoothChildTiming) && (this._start += start / this._ts, this._time -= start, this._tTime -= start), this.shiftChildren(-start, !1, -Infinity), prevStart = 0), child._end > max && child._ts && (max = child._end), child = prev;
                            _setDuration(this, this === _globalTimeline && this._time > max ? this._time : max, 1, 1), this._dirty = 0
                        }
                        return this._tDur
                    }, Timeline.updateRoot = function updateRoot(time) {
                        if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline)), _lastRenderedFrame = _ticker.frame), _ticker.frame >= _nextGCFrame) {
                            _nextGCFrame += _config.autoSleep || 120;
                            var child = _globalTimeline._first;
                            if ((!child || !child._ts) && _config.autoSleep && _ticker._listeners.length < 2) {
                                for (; child && !child._ts;) child = child._next;
                                child || _ticker.sleep()
                            }
                        }
                    }, Timeline
                }(Animation);
                _setDefaults(Timeline.prototype, {
                    _lock: 0,
                    _hasPause: 0,
                    _forcing: 0
                });
                var _overwritingTween, _forceAllPropTweens, _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
                        var result, startNums, color, endNum, chunk, startNum, hasRandom, a, pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
                            index = 0,
                            matchIndex = 0;
                        for (pt.b = start, pt.e = end, start += "", (hasRandom = ~(end += "").indexOf("random(")) && (end = _replaceRandom(end)), stringFilter && (stringFilter(a = [start, end], target, prop), start = a[0], end = a[1]), startNums = start.match(_complexStringNumExp) || []; result = _complexStringNumExp.exec(end);) endNum = result[0], chunk = end.substring(index, result.index), color ? color = (color + 1) % 5 : "rgba(" === chunk.substr(-5) && (color = 1), endNum !== startNums[matchIndex++] && (startNum = parseFloat(startNums[matchIndex - 1]) || 0, pt._pt = {
                            _next: pt._pt,
                            p: chunk || 1 === matchIndex ? chunk : ",",
                            s: startNum,
                            c: "=" === endNum.charAt(1) ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                            m: color && color < 4 ? Math.round : 0
                        }, index = _complexStringNumExp.lastIndex);
                        return pt.c = index < end.length ? end.substring(index, end.length) : "", pt.fp = funcParam, (_relExp.test(end) || hasRandom) && (pt.e = 0), this._pt = pt, pt
                    },
                    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
                        _isFunction(end) && (end = end(index || 0, target, targets));
                        var pt, currentValue = target[prop],
                            parsedStart = "get" !== start ? start : _isFunction(currentValue) ? funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop]() : currentValue,
                            setter = _isFunction(currentValue) ? funcParam ? _setterFuncWithParam : _setterFunc : _setterPlain;
                        if (_isString(end) && (~end.indexOf("random(") && (end = _replaceRandom(end)), "=" === end.charAt(1) && ((pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0)) || 0 === pt) && (end = pt)), !optional || parsedStart !== end || _forceAllPropTweens) return isNaN(parsedStart * end) || "" === end ? (!currentValue && !(prop in target) && _missingPlugin(prop, end), _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam)) : (pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), "boolean" == typeof currentValue ? _renderBoolean : _renderPlain, 0, setter), funcParam && (pt.fp = funcParam), modifier && pt.modifier(modifier, this, target), this._pt = pt)
                    },
                    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
                        var plugin, pt, ptLookup, i;
                        if (_plugins[property] && !1 !== (plugin = new _plugins[property]).init(target, plugin.rawVars ? vars[property] : function _processVars(vars, index, target, targets, tween) {
                                if (_isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets)), !_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
                                var p, copy = {};
                                for (p in vars) copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
                                return copy
                            }(vars[property], index, target, targets, tween), tween, index, targets) && (tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority), tween !== _quickTween))
                            for (ptLookup = tween._ptLookup[tween._targets.indexOf(target)], i = plugin._props.length; i--;) ptLookup[plugin._props[i]] = pt;
                        return plugin
                    },
                    _initTween = function _initTween(tween, time, tTime) {
                        var cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten, vars = tween.vars,
                            ease = vars.ease,
                            startAt = vars.startAt,
                            immediateRender = vars.immediateRender,
                            lazy = vars.lazy,
                            onUpdate = vars.onUpdate,
                            onUpdateParams = vars.onUpdateParams,
                            callbackScope = vars.callbackScope,
                            runBackwards = vars.runBackwards,
                            yoyoEase = vars.yoyoEase,
                            keyframes = vars.keyframes,
                            autoRevert = vars.autoRevert,
                            dur = tween._dur,
                            prevStartAt = tween._startAt,
                            targets = tween._targets,
                            parent = tween.parent,
                            fullTargets = parent && "nested" === parent.data ? parent.vars.targets : targets,
                            autoOverwrite = "auto" === tween._overwrite && !_suppressOverwrites,
                            tl = tween.timeline;
                        if (tl && (!keyframes || !ease) && (ease = "none"), tween._ease = _parseEase(ease, _defaults.ease), tween._yEase = yoyoEase ? _invertEase(_parseEase(!0 === yoyoEase ? ease : yoyoEase, _defaults.ease)) : 0, yoyoEase && tween._yoyo && !tween._repeat && (yoyoEase = tween._yEase, tween._yEase = tween._ease, tween._ease = yoyoEase), tween._from = !tl && !!vars.runBackwards, !tl || keyframes && !vars.stagger) {
                            if (harnessVars = (harness = targets[0] ? _getCache(targets[0]).harness : 0) && vars[harness.prop], cleanVars = _copyExcluding(vars, _reservedProps), prevStartAt && (prevStartAt._zTime < 0 && prevStartAt.progress(1), time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, !0) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig), prevStartAt._lazy = 0), startAt) {
                                if (_removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                                        data: "isStart",
                                        overwrite: !1,
                                        parent: parent,
                                        immediateRender: !0,
                                        lazy: !prevStartAt && _isNotFalse(lazy),
                                        startAt: null,
                                        delay: 0,
                                        onUpdate: onUpdate,
                                        onUpdateParams: onUpdateParams,
                                        callbackScope: callbackScope,
                                        stagger: 0
                                    }, startAt))), tween._startAt._dp = 0, tween._startAt._sat = tween, time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill), immediateRender && dur && time <= 0 && tTime <= 0) return void(time && (tween._zTime = time))
                            } else if (runBackwards && dur && !prevStartAt)
                                if (time && (immediateRender = !1), p = _setDefaults({
                                        overwrite: !1,
                                        data: "isFromStart",
                                        lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                                        immediateRender: immediateRender,
                                        stagger: 0,
                                        parent: parent
                                    }, cleanVars), harnessVars && (p[harness.prop] = harnessVars), _removeFromParent(tween._startAt = Tween.set(targets, p)), tween._startAt._dp = 0, tween._startAt._sat = tween, time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, !0)), tween._zTime = time, immediateRender) {
                                    if (!time) return
                                } else _initTween(tween._startAt, 1e-8, 1e-8);
                            for (tween._pt = tween._ptCache = 0, lazy = dur && _isNotFalse(lazy) || lazy && !dur, i = 0; i < targets.length; i++) {
                                if (gsData = (target = targets[i])._gsap || _harness(targets)[i]._gsap, tween._ptLookup[i] = ptLookup = {}, _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(), index = fullTargets === targets ? i : fullTargets.indexOf(target), harness && !1 !== (plugin = new harness).init(target, harnessVars || cleanVars, tween, index, fullTargets) && (tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority), plugin._props.forEach((function(name) {
                                        ptLookup[name] = pt
                                    })), plugin.priority && (hasPriority = 1)), !harness || harnessVars)
                                    for (p in cleanVars) _plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets)) ? plugin.priority && (hasPriority = 1) : ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
                                tween._op && tween._op[i] && tween.kill(target, tween._op[i]), autoOverwrite && tween._pt && (_overwritingTween = tween, _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)), overwritten = !tween.parent, _overwritingTween = 0), tween._pt && lazy && (_lazyLookup[gsData.id] = 1)
                            }
                            hasPriority && _sortPropTweensByPriority(tween), tween._onInit && tween._onInit(tween)
                        }
                        tween._onUpdate = onUpdate, tween._initted = (!tween._op || tween._pt) && !overwritten, keyframes && time <= 0 && tl.render(_bigNum, !0, !0)
                    },
                    _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
                        var p, a, ease = obj.ease || easeEach || "power1.inOut";
                        if (_isArray(obj)) a = allProps[prop] || (allProps[prop] = []), obj.forEach((function(value, i) {
                            return a.push({
                                t: i / (obj.length - 1) * 100,
                                v: value,
                                e: ease
                            })
                        }));
                        else
                            for (p in obj) a = allProps[p] || (allProps[p] = []), "ease" === p || a.push({
                                t: parseFloat(prop),
                                v: obj[p],
                                e: ease
                            })
                    },
                    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
                        return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value
                    },
                    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                    _staggerPropsToSkip = {};
                _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", (function(name) {
                    return _staggerPropsToSkip[name] = 1
                }));
                var Tween = function(_Animation2) {
                    function Tween(targets, vars, position, skipInherit) {
                        var _this3;
                        "number" == typeof vars && (position.duration = vars, vars = position, position = null);
                        var tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge, _this3$vars = (_this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this).vars,
                            duration = _this3$vars.duration,
                            delay = _this3$vars.delay,
                            immediateRender = _this3$vars.immediateRender,
                            stagger = _this3$vars.stagger,
                            overwrite = _this3$vars.overwrite,
                            keyframes = _this3$vars.keyframes,
                            defaults = _this3$vars.defaults,
                            scrollTrigger = _this3$vars.scrollTrigger,
                            yoyoEase = _this3$vars.yoyoEase,
                            parent = vars.parent || _globalTimeline,
                            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets);
                        if (_this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [], _this3._ptLookup = [], _this3._overwrite = overwrite, keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                            if (vars = _this3.vars, (tl = _this3.timeline = new Timeline({
                                    data: "nested",
                                    defaults: defaults || {},
                                    targets: parent && "nested" === parent.data ? parent.vars.targets : parsedTargets
                                })).kill(), tl.parent = tl._dp = _assertThisInitialized(_this3), tl._start = 0, stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                                if (l = parsedTargets.length, staggerFunc = stagger && distribute(stagger), _isObject(stagger))
                                    for (p in stagger) ~_staggerTweenProps.indexOf(p) && (staggerVarsToMerge || (staggerVarsToMerge = {}), staggerVarsToMerge[p] = stagger[p]);
                                for (i = 0; i < l; i++)(copy = _copyExcluding(vars, _staggerPropsToSkip)).stagger = 0, yoyoEase && (copy.yoyoEase = yoyoEase), staggerVarsToMerge && _merge(copy, staggerVarsToMerge), curTarget = parsedTargets[i], copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets), copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay, !stagger && 1 === l && copy.delay && (_this3._delay = delay = copy.delay, _this3._start += delay, copy.delay = 0), tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0), tl._ease = _easeMap.none;
                                tl.duration() ? duration = delay = 0 : _this3.timeline = 0
                            } else if (keyframes) {
                                _inheritDefaults(_setDefaults(tl.vars.defaults, {
                                    ease: "none"
                                })), tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                                var a, kf, v, time = 0;
                                if (_isArray(keyframes)) keyframes.forEach((function(frame) {
                                    return tl.to(parsedTargets, frame, ">")
                                })), tl.duration();
                                else {
                                    for (p in copy = {}, keyframes) "ease" === p || "easeEach" === p || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
                                    for (p in copy)
                                        for (a = copy[p].sort((function(a, b) {
                                                return a.t - b.t
                                            })), time = 0, i = 0; i < a.length; i++)(v = {
                                            ease: (kf = a[i]).e,
                                            duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                                        })[p] = kf.v, tl.to(parsedTargets, v, time), time += v.duration;
                                    tl.duration() < duration && tl.to({}, {
                                        duration: duration - tl.duration()
                                    })
                                }
                            }
                            duration || _this3.duration(duration = tl.duration())
                        } else _this3.timeline = 0;
                        return !0 !== overwrite || _suppressOverwrites || (_overwritingTween = _assertThisInitialized(_this3), _globalTimeline.killTweensOf(parsedTargets), _overwritingTween = 0), _addToTimeline(parent, _assertThisInitialized(_this3), position), vars.reversed && _this3.reverse(), vars.paused && _this3.paused(!0), (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && "nested" !== parent.data) && (_this3._tTime = -1e-8, _this3.render(Math.max(0, -delay) || 0)), scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger), _this3
                    }
                    _inheritsLoose(Tween, _Animation2);
                    var _proto3 = Tween.prototype;
                    return _proto3.render = function render(totalTime, suppressEvents, force) {
                        var time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase, prevTime = this._time,
                            tDur = this._tDur,
                            dur = this._dur,
                            isNegative = totalTime < 0,
                            tTime = totalTime > tDur - 1e-8 && !isNegative ? tDur : totalTime < 1e-8 ? 0 : totalTime;
                        if (dur) {
                            if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
                                if (time = tTime, timeline = this.timeline, this._repeat) {
                                    if (cycleDuration = dur + this._rDelay, this._repeat < -1 && isNegative) return this.totalTime(100 * cycleDuration + totalTime, suppressEvents, force);
                                    if (time = _roundPrecise(tTime % cycleDuration), tTime === tDur ? (iteration = this._repeat, time = dur) : ((iteration = ~~(tTime / cycleDuration)) && iteration === tTime / cycleDuration && (time = dur, iteration--), time > dur && (time = dur)), (isYoyo = this._yoyo && 1 & iteration) && (yoyoEase = this._yEase, time = dur - time), prevIteration = _animationCycle(this._tTime, cycleDuration), time === prevTime && !force && this._initted) return this._tTime = tTime, this;
                                    iteration !== prevIteration && (timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo), !this.vars.repeatRefresh || isYoyo || this._lock || (this._lock = force = 1, this.render(_roundPrecise(cycleDuration * iteration), !0).invalidate()._lock = 0))
                                }
                                if (!this._initted) {
                                    if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) return this._tTime = 0, this;
                                    if (prevTime !== this._time) return this;
                                    if (dur !== this._dur) return this.render(totalTime, suppressEvents, force)
                                }
                                if (this._tTime = tTime, this._time = time, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = ratio = (yoyoEase || this._ease)(time / dur), this._from && (this.ratio = ratio = 1 - ratio), time && !prevTime && !suppressEvents && !iteration && (_callback(this, "onStart"), this._tTime !== tTime)) return this;
                                for (pt = this._pt; pt;) pt.r(ratio, pt.d), pt = pt._next;
                                timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -1e-8 : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime), this._onUpdate && !suppressEvents && (isNegative && _rewindStartAt(this, totalTime, 0, force), _callback(this, "onUpdate")), this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat"), tTime !== this._tDur && tTime || this._tTime !== tTime || (isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, 0, !0), (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1), suppressEvents || isNegative && !prevTime || !(tTime || prevTime || isYoyo) || (_callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", !0), this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom()))
                            }
                        } else ! function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
                            var pt, iteration, prevIteration, prevRatio = tween.ratio,
                                ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && (tween._initted || !_isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
                                repeatDelay = tween._rDelay,
                                tTime = 0;
                            if (repeatDelay && tween._repeat && (tTime = _clamp(0, tween._tDur, totalTime), iteration = _animationCycle(tTime, repeatDelay), tween._yoyo && 1 & iteration && (ratio = 1 - ratio), iteration !== _animationCycle(tween._tTime, repeatDelay) && (prevRatio = 1 - ratio, tween.vars.repeatRefresh && tween._initted && tween.invalidate())), ratio !== prevRatio || _reverting || force || 1e-8 === tween._zTime || !totalTime && tween._zTime) {
                                if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) return;
                                for (prevIteration = tween._zTime, tween._zTime = totalTime || (suppressEvents ? 1e-8 : 0), suppressEvents || (suppressEvents = totalTime && !prevIteration), tween.ratio = ratio, tween._from && (ratio = 1 - ratio), tween._time = 0, tween._tTime = tTime, pt = tween._pt; pt;) pt.r(ratio, pt.d), pt = pt._next;
                                totalTime < 0 && _rewindStartAt(tween, totalTime, 0, !0), tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate"), tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat"), (totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio && (ratio && _removeFromParent(tween, 1), suppressEvents || _reverting || (_callback(tween, ratio ? "onComplete" : "onReverseComplete", !0), tween._prom && tween._prom()))
                            } else tween._zTime || (tween._zTime = totalTime)
                        }(this, totalTime, suppressEvents, force);
                        return this
                    }, _proto3.targets = function targets() {
                        return this._targets
                    }, _proto3.invalidate = function invalidate(soft) {
                        return (!soft || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(soft), _Animation2.prototype.invalidate.call(this, soft)
                    }, _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
                        _tickerActive || _ticker.wake(), this._ts || this.play();
                        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                        return this._initted || _initTween(this, time),
                            function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
                                var pt, rootPT, lookup, i, ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property];
                                if (!ptCache)
                                    for (ptCache = tween._ptCache[property] = [], lookup = tween._ptLookup, i = tween._targets.length; i--;) {
                                        if ((pt = lookup[i][property]) && pt.d && pt.d._pt)
                                            for (pt = pt.d._pt; pt && pt.p !== property && pt.fp !== property;) pt = pt._next;
                                        if (!pt) return _forceAllPropTweens = 1, tween.vars[property] = "+=0", _initTween(tween, time), _forceAllPropTweens = 0, 1;
                                        ptCache.push(pt)
                                    }
                                for (i = ptCache.length; i--;)(pt = (rootPT = ptCache[i])._pt || rootPT).s = !start && 0 !== start || startIsRelative ? pt.s + (start || 0) + ratio * pt.c : start, pt.c = value - pt.s, rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)), rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b))
                            }(this, property, value, start, startIsRelative, this._ease(time / this._dur), time) ? this.resetTo(property, value, start, startIsRelative) : (_alignPlayhead(this, 0), this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                    }, _proto3.kill = function kill(targets, vars) {
                        if (void 0 === vars && (vars = "all"), !(targets || vars && "all" !== vars)) return this._lazy = this._pt = 0, this.parent ? _interrupt(this) : this;
                        if (this.timeline) {
                            var tDur = this.timeline.totalDuration();
                            return this.timeline.killTweensOf(targets, vars, _overwritingTween && !0 !== _overwritingTween.vars.overwrite)._first || _interrupt(this), this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1), this
                        }
                        var overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i, parsedTargets = this._targets,
                            killingTargets = targets ? toArray(targets) : parsedTargets,
                            propTweenLookup = this._ptLookup,
                            firstPT = this._pt;
                        if ((!vars || "all" === vars) && function _arraysMatch(a1, a2) {
                                for (var i = a1.length, match = i === a2.length; match && i-- && a1[i] === a2[i];);
                                return i < 0
                            }(parsedTargets, killingTargets)) return "all" === vars && (this._pt = 0), _interrupt(this);
                        for (overwrittenProps = this._op = this._op || [], "all" !== vars && (_isString(vars) && (p = {}, _forEachName(vars, (function(name) {
                                return p[name] = 1
                            })), vars = p), vars = function _addAliasesToVars(targets, vars) {
                                var copy, p, i, aliases, harness = targets[0] ? _getCache(targets[0]).harness : 0,
                                    propertyAliases = harness && harness.aliases;
                                if (!propertyAliases) return vars;
                                for (p in copy = _merge({}, vars), propertyAliases)
                                    if (p in copy)
                                        for (i = (aliases = propertyAliases[p].split(",")).length; i--;) copy[aliases[i]] = copy[p];
                                return copy
                            }(parsedTargets, vars)), i = parsedTargets.length; i--;)
                            if (~killingTargets.indexOf(parsedTargets[i]))
                                for (p in curLookup = propTweenLookup[i], "all" === vars ? (overwrittenProps[i] = vars, props = curLookup, curOverwriteProps = {}) : (curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {}, props = vars), props)(pt = curLookup && curLookup[p]) && ("kill" in pt.d && !0 !== pt.d.kill(p) || _removeLinkedListItem(this, pt, "_pt"), delete curLookup[p]), "all" !== curOverwriteProps && (curOverwriteProps[p] = 1);
                        return this._initted && !this._pt && firstPT && _interrupt(this), this
                    }, Tween.to = function to(targets, vars) {
                        return new Tween(targets, vars, arguments[2])
                    }, Tween.from = function from(targets, vars) {
                        return _createTweenType(1, arguments)
                    }, Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
                        return new Tween(callback, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: delay,
                            onComplete: callback,
                            onReverseComplete: callback,
                            onCompleteParams: params,
                            onReverseCompleteParams: params,
                            callbackScope: scope
                        })
                    }, Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                        return _createTweenType(2, arguments)
                    }, Tween.set = function set(targets, vars) {
                        return vars.duration = 0, vars.repeatDelay || (vars.repeat = 0), new Tween(targets, vars)
                    }, Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        return _globalTimeline.killTweensOf(targets, props, onlyActive)
                    }, Tween
                }(Animation);
                _setDefaults(Tween.prototype, {
                    _targets: [],
                    _lazy: 0,
                    _startAt: 0,
                    _op: 0,
                    _onInit: 0
                }), _forEachName("staggerTo,staggerFrom,staggerFromTo", (function(name) {
                    Tween[name] = function() {
                        var tl = new Timeline,
                            params = _slice.call(arguments, 0);
                        return params.splice("staggerFromTo" === name ? 5 : 4, 0, 0), tl[name].apply(tl, params)
                    }
                }));
                var _setterPlain = function _setterPlain(target, property, value) {
                        return target[property] = value
                    },
                    _setterFunc = function _setterFunc(target, property, value) {
                        return target[property](value)
                    },
                    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
                        return target[property](data.fp, value)
                    },
                    _setterAttribute = function _setterAttribute(target, property, value) {
                        return target.setAttribute(property, value)
                    },
                    _getSetter = function _getSetter(target, property) {
                        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain
                    },
                    _renderPlain = function _renderPlain(ratio, data) {
                        return data.set(data.t, data.p, Math.round(1e6 * (data.s + data.c * ratio)) / 1e6, data)
                    },
                    _renderBoolean = function _renderBoolean(ratio, data) {
                        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data)
                    },
                    _renderComplexString = function _renderComplexString(ratio, data) {
                        var pt = data._pt,
                            s = "";
                        if (!ratio && data.b) s = data.b;
                        else if (1 === ratio && data.e) s = data.e;
                        else {
                            for (; pt;) s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round(1e4 * (pt.s + pt.c * ratio)) / 1e4) + s, pt = pt._next;
                            s += data.c
                        }
                        data.set(data.t, data.p, s, data)
                    },
                    _renderPropTweens = function _renderPropTweens(ratio, data) {
                        for (var pt = data._pt; pt;) pt.r(ratio, pt.d), pt = pt._next
                    },
                    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
                        for (var next, pt = this._pt; pt;) next = pt._next, pt.p === property && pt.modifier(modifier, tween, target), pt = next
                    },
                    _killPropTweensOf = function _killPropTweensOf(property) {
                        for (var hasNonDependentRemaining, next, pt = this._pt; pt;) next = pt._next, pt.p === property && !pt.op || pt.op === property ? _removeLinkedListItem(this, pt, "_pt") : pt.dep || (hasNonDependentRemaining = 1), pt = next;
                        return !hasNonDependentRemaining
                    },
                    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
                        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data)
                    },
                    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
                        for (var next, pt2, first, last, pt = parent._pt; pt;) {
                            for (next = pt._next, pt2 = first; pt2 && pt2.pr > pt.pr;) pt2 = pt2._next;
                            (pt._prev = pt2 ? pt2._prev : last) ? pt._prev._next = pt: first = pt, (pt._next = pt2) ? pt2._prev = pt : last = pt, pt = next
                        }
                        parent._pt = first
                    },
                    PropTween = function() {
                        function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
                            this.t = target, this.s = start, this.c = change, this.p = prop, this.r = renderer || _renderPlain, this.d = data || this, this.set = setter || _setterPlain, this.pr = priority || 0, this._next = next, next && (next._prev = this)
                        }
                        return PropTween.prototype.modifier = function modifier(func, tween, target) {
                            this.mSet = this.mSet || this.set, this.set = _setterWithModifier, this.m = func, this.mt = target, this.tween = tween
                        }, PropTween
                    }();
                _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(name) {
                    return _reservedProps[name] = 1
                })), _globals.TweenMax = _globals.TweenLite = Tween, _globals.TimelineLite = _globals.TimelineMax = Timeline, _globalTimeline = new Timeline({
                    sortChildren: !1,
                    defaults: _defaults,
                    autoRemoveChildren: !0,
                    id: "root",
                    smoothChildTiming: !0
                }), _config.stringFilter = _colorStringFilter;
                var _media = [],
                    _listeners = {},
                    _emptyArray = [],
                    _lastMediaTime = 0,
                    _contextID = 0,
                    _dispatch = function _dispatch(type) {
                        return (_listeners[type] || _emptyArray).map((function(f) {
                            return f()
                        }))
                    },
                    _onMediaChange = function _onMediaChange() {
                        var time = Date.now(),
                            matches = [];
                        time - _lastMediaTime > 2 && (_dispatch("matchMediaInit"), _media.forEach((function(c) {
                            var match, p, anyMatch, toggled, queries = c.queries,
                                conditions = c.conditions;
                            for (p in queries)(match = _win.matchMedia(queries[p]).matches) && (anyMatch = 1), match !== conditions[p] && (conditions[p] = match, toggled = 1);
                            toggled && (c.revert(), anyMatch && matches.push(c))
                        })), _dispatch("matchMediaRevert"), matches.forEach((function(c) {
                            return c.onMatch(c)
                        })), _lastMediaTime = time, _dispatch("matchMedia"))
                    },
                    Context = function() {
                        function Context(func, scope) {
                            this.selector = scope && selector(scope), this.data = [], this._r = [], this.isReverted = !1, this.id = _contextID++, func && this.add(func)
                        }
                        var _proto5 = Context.prototype;
                        return _proto5.add = function add(name, func, scope) {
                            _isFunction(name) && (scope = func, func = name, name = _isFunction);
                            var self = this,
                                f = function f() {
                                    var result, prev = _context,
                                        prevSelector = self.selector;
                                    return prev && prev !== self && prev.data.push(self), scope && (self.selector = selector(scope)), _context = self, result = func.apply(self, arguments), _isFunction(result) && self._r.push(result), _context = prev, self.selector = prevSelector, self.isReverted = !1, result
                                };
                            return self.last = f, name === _isFunction ? f(self) : name ? self[name] = f : f
                        }, _proto5.ignore = function ignore(func) {
                            var prev = _context;
                            _context = null, func(this), _context = prev
                        }, _proto5.getTweens = function getTweens() {
                            var a = [];
                            return this.data.forEach((function(e) {
                                return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && "nested" === e.parent.data) && a.push(e)
                            })), a
                        }, _proto5.clear = function clear() {
                            this._r.length = this.data.length = 0
                        }, _proto5.kill = function kill(revert, matchMedia) {
                            var _this4 = this;
                            if (revert) {
                                var tweens = this.getTweens();
                                this.data.forEach((function(t) {
                                    "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function(tween) {
                                        return tweens.splice(tweens.indexOf(tween), 1)
                                    })))
                                })), tweens.map((function(t) {
                                    return {
                                        g: t.globalTime(0),
                                        t: t
                                    }
                                })).sort((function(a, b) {
                                    return b.g - a.g || -1 / 0
                                })).forEach((function(o) {
                                    return o.t.revert(revert)
                                })), this.data.forEach((function(e) {
                                    return !(e instanceof Tween) && e.revert && e.revert(revert)
                                })), this._r.forEach((function(f) {
                                    return f(revert, _this4)
                                })), this.isReverted = !0
                            } else this.data.forEach((function(e) {
                                return e.kill && e.kill()
                            }));
                            if (this.clear(), matchMedia)
                                for (var i = _media.length; i--;) _media[i].id === this.id && _media.splice(i, 1)
                        }, _proto5.revert = function revert(config) {
                            this.kill(config || {})
                        }, Context
                    }(),
                    MatchMedia = function() {
                        function MatchMedia(scope) {
                            this.contexts = [], this.scope = scope
                        }
                        var _proto6 = MatchMedia.prototype;
                        return _proto6.add = function add(conditions, func, scope) {
                            _isObject(conditions) || (conditions = {
                                matches: conditions
                            });
                            var mq, p, active, context = new Context(0, scope || this.scope),
                                cond = context.conditions = {};
                            for (p in _context && !context.selector && (context.selector = _context.selector), this.contexts.push(context), func = context.add("onMatch", func), context.queries = conditions, conditions) "all" === p ? active = 1 : (mq = _win.matchMedia(conditions[p])) && (_media.indexOf(context) < 0 && _media.push(context), (cond[p] = mq.matches) && (active = 1), mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange));
                            return active && func(context), this
                        }, _proto6.revert = function revert(config) {
                            this.kill(config || {})
                        }, _proto6.kill = function kill(revert) {
                            this.contexts.forEach((function(c) {
                                return c.kill(revert, !0)
                            }))
                        }, MatchMedia
                    }(),
                    _gsap = {
                        registerPlugin: function registerPlugin() {
                            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                            args.forEach((function(config) {
                                return _createPlugin(config)
                            }))
                        },
                        timeline: function timeline(vars) {
                            return new Timeline(vars)
                        },
                        getTweensOf: function getTweensOf(targets, onlyActive) {
                            return _globalTimeline.getTweensOf(targets, onlyActive)
                        },
                        getProperty: function getProperty(target, property, unit, uncache) {
                            _isString(target) && (target = toArray(target)[0]);
                            var getter = _getCache(target || {}).get,
                                format = unit ? _passThrough : _numericIfPossible;
                            return "native" === unit && (unit = ""), target ? property ? format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache)) : function(property, unit, uncache) {
                                return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache))
                            } : target
                        },
                        quickSetter: function quickSetter(target, property, unit) {
                            if ((target = toArray(target)).length > 1) {
                                var setters = target.map((function(t) {
                                        return gsap.quickSetter(t, property, unit)
                                    })),
                                    l = setters.length;
                                return function(value) {
                                    for (var i = l; i--;) setters[i](value)
                                }
                            }
                            target = target[0] || {};
                            var Plugin = _plugins[property],
                                cache = _getCache(target),
                                p = cache.harness && (cache.harness.aliases || {})[property] || property,
                                setter = Plugin ? function(value) {
                                    var p = new Plugin;
                                    _quickTween._pt = 0, p.init(target, unit ? value + unit : value, _quickTween, 0, [target]), p.render(1, p), _quickTween._pt && _renderPropTweens(1, _quickTween)
                                } : cache.set(target, p);
                            return Plugin ? setter : function(value) {
                                return setter(target, p, unit ? value + unit : value, cache, 1)
                            }
                        },
                        quickTo: function quickTo(target, property, vars) {
                            var _merge2, tween = gsap.to(target, _merge(((_merge2 = {})[property] = "+=0.1", _merge2.paused = !0, _merge2), vars || {})),
                                func = function func(value, start, startIsRelative) {
                                    return tween.resetTo(property, value, start, startIsRelative)
                                };
                            return func.tween = tween, func
                        },
                        isTweening: function isTweening(targets) {
                            return _globalTimeline.getTweensOf(targets, !0).length > 0
                        },
                        defaults: function defaults(value) {
                            return value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease)), _mergeDeep(_defaults, value || {})
                        },
                        config: function config(value) {
                            return _mergeDeep(_config, value || {})
                        },
                        registerEffect: function registerEffect(_ref3) {
                            var name = _ref3.name,
                                effect = _ref3.effect,
                                plugins = _ref3.plugins,
                                defaults = _ref3.defaults,
                                extendTimeline = _ref3.extendTimeline;
                            (plugins || "").split(",").forEach((function(pluginName) {
                                return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.")
                            })), _effects[name] = function(targets, vars, tl) {
                                return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl)
                            }, extendTimeline && (Timeline.prototype[name] = function(targets, vars, position) {
                                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position)
                            })
                        },
                        registerEase: function registerEase(name, ease) {
                            _easeMap[name] = _parseEase(ease)
                        },
                        parseEase: function parseEase(ease, defaultEase) {
                            return arguments.length ? _parseEase(ease, defaultEase) : _easeMap
                        },
                        getById: function getById(id) {
                            return _globalTimeline.getById(id)
                        },
                        exportRoot: function exportRoot(vars, includeDelayedCalls) {
                            void 0 === vars && (vars = {});
                            var child, next, tl = new Timeline(vars);
                            for (tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming), _globalTimeline.remove(tl), tl._dp = 0, tl._time = tl._tTime = _globalTimeline._time, child = _globalTimeline._first; child;) next = child._next, !includeDelayedCalls && !child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0] || _addToTimeline(tl, child, child._start - child._delay), child = next;
                            return _addToTimeline(_globalTimeline, tl, 0), tl
                        },
                        context: function context(func, scope) {
                            return func ? new Context(func, scope) : _context
                        },
                        matchMedia: function matchMedia(scope) {
                            return new MatchMedia(scope)
                        },
                        matchMediaRefresh: function matchMediaRefresh() {
                            return _media.forEach((function(c) {
                                var found, p, cond = c.conditions;
                                for (p in cond) cond[p] && (cond[p] = !1, found = 1);
                                found && c.revert()
                            })) || _onMediaChange()
                        },
                        addEventListener: function addEventListener(type, callback) {
                            var a = _listeners[type] || (_listeners[type] = []);
                            ~a.indexOf(callback) || a.push(callback)
                        },
                        removeEventListener: function removeEventListener(type, callback) {
                            var a = _listeners[type],
                                i = a && a.indexOf(callback);
                            i >= 0 && a.splice(i, 1)
                        },
                        utils: {
                            wrap: wrap,
                            wrapYoyo: wrapYoyo,
                            distribute: distribute,
                            random: random,
                            snap: snap,
                            normalize: normalize,
                            getUnit: getUnit,
                            clamp: clamp,
                            splitColor: splitColor,
                            toArray: toArray,
                            selector: selector,
                            mapRange: mapRange,
                            pipe: pipe,
                            unitize: unitize,
                            interpolate: interpolate,
                            shuffle: shuffle
                        },
                        install: _install,
                        effects: _effects,
                        ticker: _ticker,
                        updateRoot: Timeline.updateRoot,
                        plugins: _plugins,
                        globalTimeline: _globalTimeline,
                        core: {
                            PropTween: PropTween,
                            globals: _addGlobal,
                            Tween: Tween,
                            Timeline: Timeline,
                            Animation: Animation,
                            getCache: _getCache,
                            _removeLinkedListItem: _removeLinkedListItem,
                            reverting: function reverting() {
                                return _reverting
                            },
                            context: function context(toAdd) {
                                return toAdd && _context && (_context.data.push(toAdd), toAdd._ctx = _context), _context
                            },
                            suppressOverwrites: function suppressOverwrites(value) {
                                return _suppressOverwrites = value
                            }
                        }
                    };
                _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", (function(name) {
                    return _gsap[name] = Tween[name]
                })), _ticker.add(Timeline.updateRoot), _quickTween = _gsap.to({}, {
                    duration: 0
                });
                var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
                        for (var pt = plugin._pt; pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop;) pt = pt._next;
                        return pt
                    },
                    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
                        return {
                            name: name,
                            rawVars: 1,
                            init: function init(target, vars, tween) {
                                tween._onInit = function(tween) {
                                    var temp, p;
                                    if (_isString(vars) && (temp = {}, _forEachName(vars, (function(name) {
                                            return temp[name] = 1
                                        })), vars = temp), modifier) {
                                        for (p in temp = {}, vars) temp[p] = modifier(vars[p]);
                                        vars = temp
                                    }! function _addModifiers(tween, modifiers) {
                                        var p, i, pt, targets = tween._targets;
                                        for (p in modifiers)
                                            for (i = targets.length; i--;)(pt = tween._ptLookup[i][p]) && (pt = pt.d) && (pt._pt && (pt = _getPluginPropTween(pt, p)), pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p))
                                    }(tween, vars)
                                }
                            }
                        }
                    },
                    gsap = _gsap.registerPlugin({
                        name: "attr",
                        init: function init(target, vars, tween, index, targets) {
                            var p, pt, v;
                            for (p in this.tween = tween, vars) v = target.getAttribute(p) || "", (pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p)).op = p, pt.b = v, this._props.push(p)
                        },
                        render: function render(ratio, data) {
                            for (var pt = data._pt; pt;) _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d), pt = pt._next
                        }
                    }, {
                        name: "endArray",
                        init: function init(target, value) {
                            for (var i = value.length; i--;) this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1)
                        }
                    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
                Tween.version = Timeline.version = gsap.version = "3.12.2", _coreReady = 1, _windowExists() && _wake();
                var Power0 = _easeMap.Power0,
                    Power1 = _easeMap.Power1,
                    Power2 = _easeMap.Power2,
                    Power3 = _easeMap.Power3,
                    Power4 = _easeMap.Power4,
                    Linear = _easeMap.Linear,
                    Quad = _easeMap.Quad,
                    Cubic = _easeMap.Cubic,
                    Quart = _easeMap.Quart,
                    Quint = _easeMap.Quint,
                    Strong = _easeMap.Strong,
                    Elastic = _easeMap.Elastic,
                    Back = _easeMap.Back,
                    SteppedEase = _easeMap.SteppedEase,
                    Bounce = _easeMap.Bounce,
                    Sine = _easeMap.Sine,
                    Expo = _easeMap.Expo,
                    Circ = _easeMap.Circ
            },
            "./node_modules/gsap/index.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    Back: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back,
                    Bounce: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce,
                    CSSPlugin: () => _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin,
                    Circ: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ,
                    Cubic: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic,
                    Elastic: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic,
                    Expo: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo,
                    Linear: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear,
                    Power0: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0,
                    Power1: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1,
                    Power2: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2,
                    Power3: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3,
                    Power4: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4,
                    Quad: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad,
                    Quart: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart,
                    Quint: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint,
                    Sine: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine,
                    SteppedEase: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase,
                    Strong: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong,
                    TimelineLite: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite,
                    TimelineMax: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax,
                    TweenLite: () => _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite,
                    TweenMax: () => TweenMaxWithCSS,
                    default: () => gsapWithCSS,
                    gsap: () => gsapWithCSS
                });
                var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/gsap/gsap-core.js"),
                    _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/gsap/CSSPlugin.js"),
                    gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
                    TweenMaxWithCSS = gsapWithCSS.core.Tween
            },
            "./node_modules/lottie-web/build/player/lottie.js": function(module, exports, __webpack_require__) {
                var factory;
                "undefined" != typeof navigator && (factory = function() {
                    "use strict";
                    var svgNS = "http://www.w3.org/2000/svg",
                        locationHref = "",
                        _useWebWorker = !1,
                        initialDefaultFrame = -999999,
                        setWebWorker = function setWebWorker(flag) {
                            _useWebWorker = !!flag
                        },
                        getWebWorker = function getWebWorker() {
                            return _useWebWorker
                        },
                        setLocationHref = function setLocationHref(value) {
                            locationHref = value
                        },
                        getLocationHref = function getLocationHref() {
                            return locationHref
                        };

                    function createTag(type) {
                        return document.createElement(type)
                    }

                    function extendPrototype(sources, destination) {
                        var i, sourcePrototype, len = sources.length;
                        for (i = 0; i < len; i += 1)
                            for (var attr in sourcePrototype = sources[i].prototype) Object.prototype.hasOwnProperty.call(sourcePrototype, attr) && (destination.prototype[attr] = sourcePrototype[attr])
                    }

                    function getDescriptor(object, prop) {
                        return Object.getOwnPropertyDescriptor(object, prop)
                    }

                    function createProxyFunction(prototype) {
                        function ProxyFunction() {}
                        return ProxyFunction.prototype = prototype, ProxyFunction
                    }
                    var audioControllerFactory = function() {
                            function AudioController(audioFactory) {
                                this.audios = [], this.audioFactory = audioFactory, this._volume = 1, this._isMuted = !1
                            }
                            return AudioController.prototype = {
                                    addAudio: function addAudio(audio) {
                                        this.audios.push(audio)
                                    },
                                    pause: function pause() {
                                        var i, len = this.audios.length;
                                        for (i = 0; i < len; i += 1) this.audios[i].pause()
                                    },
                                    resume: function resume() {
                                        var i, len = this.audios.length;
                                        for (i = 0; i < len; i += 1) this.audios[i].resume()
                                    },
                                    setRate: function setRate(rateValue) {
                                        var i, len = this.audios.length;
                                        for (i = 0; i < len; i += 1) this.audios[i].setRate(rateValue)
                                    },
                                    createAudio: function createAudio(assetPath) {
                                        return this.audioFactory ? this.audioFactory(assetPath) : window.Howl ? new window.Howl({
                                            src: [assetPath]
                                        }) : {
                                            isPlaying: !1,
                                            play: function play() {
                                                this.isPlaying = !0
                                            },
                                            seek: function seek() {
                                                this.isPlaying = !1
                                            },
                                            playing: function playing() {},
                                            rate: function rate() {},
                                            setVolume: function setVolume() {}
                                        }
                                    },
                                    setAudioFactory: function setAudioFactory(audioFactory) {
                                        this.audioFactory = audioFactory
                                    },
                                    setVolume: function setVolume(value) {
                                        this._volume = value, this._updateVolume()
                                    },
                                    mute: function mute() {
                                        this._isMuted = !0, this._updateVolume()
                                    },
                                    unmute: function unmute() {
                                        this._isMuted = !1, this._updateVolume()
                                    },
                                    getVolume: function getVolume() {
                                        return this._volume
                                    },
                                    _updateVolume: function _updateVolume() {
                                        var i, len = this.audios.length;
                                        for (i = 0; i < len; i += 1) this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1))
                                    }
                                },
                                function() {
                                    return new AudioController
                                }
                        }(),
                        createTypedArray = function() {
                            function createRegularArray(type, len) {
                                var value, i = 0,
                                    arr = [];
                                switch (type) {
                                    case "int16":
                                    case "uint8c":
                                        value = 1;
                                        break;
                                    default:
                                        value = 1.1
                                }
                                for (i = 0; i < len; i += 1) arr.push(value);
                                return arr
                            }
                            return "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function createTypedArrayFactory(type, len) {
                                return "float32" === type ? new Float32Array(len) : "int16" === type ? new Int16Array(len) : "uint8c" === type ? new Uint8ClampedArray(len) : createRegularArray(type, len)
                            } : createRegularArray
                        }();

                    function createSizedArray(len) {
                        return Array.apply(null, {
                            length: len
                        })
                    }

                    function _typeof$6(obj) {
                        return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$6(obj)
                    }
                    var subframeEnabled = !0,
                        expressionsPlugin = null,
                        expressionsInterfaces = null,
                        idPrefix$1 = "",
                        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                        _shouldRoundValues = !1,
                        bmPow = Math.pow,
                        bmSqrt = Math.sqrt,
                        bmFloor = Math.floor,
                        bmMax = Math.max,
                        bmMin = Math.min,
                        BMMath = {};

                    function ProjectInterface$1() {
                        return {}
                    }! function() {
                        var i, propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                            len = propertyNames.length;
                        for (i = 0; i < len; i += 1) BMMath[propertyNames[i]] = Math[propertyNames[i]]
                    }(), BMMath.random = Math.random, BMMath.abs = function(val) {
                        if ("object" === _typeof$6(val) && val.length) {
                            var i, absArr = createSizedArray(val.length),
                                len = val.length;
                            for (i = 0; i < len; i += 1) absArr[i] = Math.abs(val[i]);
                            return absArr
                        }
                        return Math.abs(val)
                    };
                    var defaultCurveSegments = 150,
                        degToRads = Math.PI / 180,
                        roundCorner = .5519;

                    function roundValues(flag) {
                        _shouldRoundValues = !!flag
                    }

                    function bmRnd(value) {
                        return _shouldRoundValues ? Math.round(value) : value
                    }

                    function styleDiv(element) {
                        element.style.position = "absolute", element.style.top = 0, element.style.left = 0, element.style.display = "block", element.style.transformOrigin = "0 0", element.style.webkitTransformOrigin = "0 0", element.style.backfaceVisibility = "visible", element.style.webkitBackfaceVisibility = "visible", element.style.transformStyle = "preserve-3d", element.style.webkitTransformStyle = "preserve-3d", element.style.mozTransformStyle = "preserve-3d"
                    }

                    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
                        this.type = type, this.currentTime = currentTime, this.totalTime = totalTime, this.direction = frameMultiplier < 0 ? -1 : 1
                    }

                    function BMCompleteEvent(type, frameMultiplier) {
                        this.type = type, this.direction = frameMultiplier < 0 ? -1 : 1
                    }

                    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
                        this.type = type, this.currentLoop = currentLoop, this.totalLoops = totalLoops, this.direction = frameMultiplier < 0 ? -1 : 1
                    }

                    function BMSegmentStartEvent(type, firstFrame, totalFrames) {
                        this.type = type, this.firstFrame = firstFrame, this.totalFrames = totalFrames
                    }

                    function BMDestroyEvent(type, target) {
                        this.type = type, this.target = target
                    }

                    function BMRenderFrameErrorEvent(nativeError, currentTime) {
                        this.type = "renderFrameError", this.nativeError = nativeError, this.currentTime = currentTime
                    }

                    function BMConfigErrorEvent(nativeError) {
                        this.type = "configError", this.nativeError = nativeError
                    }

                    function BMAnimationConfigErrorEvent(type, nativeError) {
                        this.type = type, this.nativeError = nativeError
                    }
                    var createElementID = (_count = 0, function createID() {
                            return idPrefix$1 + "__lottie_element_" + (_count += 1)
                        }),
                        _count;

                    function HSVtoRGB(h, s, v) {
                        var r, g, b, i, f, p, q, t;
                        switch (p = v * (1 - s), q = v * (1 - (f = 6 * h - (i = Math.floor(6 * h))) * s), t = v * (1 - (1 - f) * s), i % 6) {
                            case 0:
                                r = v, g = t, b = p;
                                break;
                            case 1:
                                r = q, g = v, b = p;
                                break;
                            case 2:
                                r = p, g = v, b = t;
                                break;
                            case 3:
                                r = p, g = q, b = v;
                                break;
                            case 4:
                                r = t, g = p, b = v;
                                break;
                            case 5:
                                r = v, g = p, b = q
                        }
                        return [r, g, b]
                    }

                    function RGBtoHSV(r, g, b) {
                        var h, max = Math.max(r, g, b),
                            min = Math.min(r, g, b),
                            d = max - min,
                            s = 0 === max ? 0 : d / max,
                            v = max / 255;
                        switch (max) {
                            case min:
                                h = 0;
                                break;
                            case r:
                                h = g - b + d * (g < b ? 6 : 0), h /= 6 * d;
                                break;
                            case g:
                                h = b - r + 2 * d, h /= 6 * d;
                                break;
                            case b:
                                h = r - g + 4 * d, h /= 6 * d
                        }
                        return [h, s, v]
                    }

                    function addSaturationToRGB(color, offset) {
                        var hsv = RGBtoHSV(255 * color[0], 255 * color[1], 255 * color[2]);
                        return hsv[1] += offset, hsv[1] > 1 ? hsv[1] = 1 : hsv[1] <= 0 && (hsv[1] = 0), HSVtoRGB(hsv[0], hsv[1], hsv[2])
                    }

                    function addBrightnessToRGB(color, offset) {
                        var hsv = RGBtoHSV(255 * color[0], 255 * color[1], 255 * color[2]);
                        return hsv[2] += offset, hsv[2] > 1 ? hsv[2] = 1 : hsv[2] < 0 && (hsv[2] = 0), HSVtoRGB(hsv[0], hsv[1], hsv[2])
                    }

                    function addHueToRGB(color, offset) {
                        var hsv = RGBtoHSV(255 * color[0], 255 * color[1], 255 * color[2]);
                        return hsv[0] += offset / 360, hsv[0] > 1 ? hsv[0] -= 1 : hsv[0] < 0 && (hsv[0] += 1), HSVtoRGB(hsv[0], hsv[1], hsv[2])
                    }
                    var rgbToHex = function() {
                            var i, hex, colorMap = [];
                            for (i = 0; i < 256; i += 1) hex = i.toString(16), colorMap[i] = 1 === hex.length ? "0" + hex : hex;
                            return function(r, g, b) {
                                return r < 0 && (r = 0), g < 0 && (g = 0), b < 0 && (b = 0), "#" + colorMap[r] + colorMap[g] + colorMap[b]
                            }
                        }(),
                        setSubframeEnabled = function setSubframeEnabled(flag) {
                            subframeEnabled = !!flag
                        },
                        getSubframeEnabled = function getSubframeEnabled() {
                            return subframeEnabled
                        },
                        setExpressionsPlugin = function setExpressionsPlugin(value) {
                            expressionsPlugin = value
                        },
                        getExpressionsPlugin = function getExpressionsPlugin() {
                            return expressionsPlugin
                        },
                        setExpressionInterfaces = function setExpressionInterfaces(value) {
                            expressionsInterfaces = value
                        },
                        getExpressionInterfaces = function getExpressionInterfaces() {
                            return expressionsInterfaces
                        },
                        setDefaultCurveSegments = function setDefaultCurveSegments(value) {
                            defaultCurveSegments = value
                        },
                        getDefaultCurveSegments = function getDefaultCurveSegments() {
                            return defaultCurveSegments
                        },
                        setIdPrefix = function setIdPrefix(value) {
                            idPrefix$1 = value
                        },
                        getIdPrefix = function getIdPrefix() {
                            return idPrefix$1
                        };

                    function createNS(type) {
                        return document.createElementNS(svgNS, type)
                    }

                    function _typeof$5(obj) {
                        return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$5(obj)
                    }
                    var dataManager = function() {
                            var workerFn, workerInstance, _counterId = 1,
                                processes = [],
                                workerProxy = {
                                    onmessage: function onmessage() {},
                                    postMessage: function postMessage(path) {
                                        workerFn({
                                            data: path
                                        })
                                    }
                                },
                                _workerSelf = {
                                    postMessage: function postMessage(data) {
                                        workerProxy.onmessage({
                                            data: data
                                        })
                                    }
                                };

                            function setupWorker() {
                                workerInstance || (workerInstance = function createWorker(fn) {
                                    if (window.Worker && window.Blob && getWebWorker()) {
                                        var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
                                                type: "text/javascript"
                                            }),
                                            url = URL.createObjectURL(blob);
                                        return new Worker(url)
                                    }
                                    return workerFn = fn, workerProxy
                                }((function workerStart(e) {
                                    if (_workerSelf.dataManager || (_workerSelf.dataManager = function dataFunctionManager() {
                                            function completeLayers(layers, comps) {
                                                var layerData, i, j, jLen, k, kLen, len = layers.length;
                                                for (i = 0; i < len; i += 1)
                                                    if ("ks" in (layerData = layers[i]) && !layerData.completed) {
                                                        if (layerData.completed = !0, layerData.hasMask) {
                                                            var maskProps = layerData.masksProperties;
                                                            for (jLen = maskProps.length, j = 0; j < jLen; j += 1)
                                                                if (maskProps[j].pt.k.i) convertPathsToAbsoluteValues(maskProps[j].pt.k);
                                                                else
                                                                    for (kLen = maskProps[j].pt.k.length, k = 0; k < kLen; k += 1) maskProps[j].pt.k[k].s && convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]), maskProps[j].pt.k[k].e && convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0])
                                                        }
                                                        0 === layerData.ty ? (layerData.layers = findCompLayers(layerData.refId, comps), completeLayers(layerData.layers, comps)) : 4 === layerData.ty ? completeShapes(layerData.shapes) : 5 === layerData.ty && completeText(layerData)
                                                    }
                                            }

                                            function findCompLayers(id, comps) {
                                                var comp = function findComp(id, comps) {
                                                    for (var i = 0, len = comps.length; i < len;) {
                                                        if (comps[i].id === id) return comps[i];
                                                        i += 1
                                                    }
                                                    return null
                                                }(id, comps);
                                                return comp ? comp.layers.__used ? JSON.parse(JSON.stringify(comp.layers)) : (comp.layers.__used = !0, comp.layers) : null
                                            }

                                            function completeShapes(arr) {
                                                var i, j, jLen;
                                                for (i = arr.length - 1; i >= 0; i -= 1)
                                                    if ("sh" === arr[i].ty)
                                                        if (arr[i].ks.k.i) convertPathsToAbsoluteValues(arr[i].ks.k);
                                                        else
                                                            for (jLen = arr[i].ks.k.length, j = 0; j < jLen; j += 1) arr[i].ks.k[j].s && convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]), arr[i].ks.k[j].e && convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                                                else "gr" === arr[i].ty && completeShapes(arr[i].it)
                                            }

                                            function convertPathsToAbsoluteValues(path) {
                                                var i, len = path.i.length;
                                                for (i = 0; i < len; i += 1) path.i[i][0] += path.v[i][0], path.i[i][1] += path.v[i][1], path.o[i][0] += path.v[i][0], path.o[i][1] += path.v[i][1]
                                            }

                                            function checkVersion(minimum, animVersionString) {
                                                var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                                                return minimum[0] > animVersion[0] || !(animVersion[0] > minimum[0]) && (minimum[1] > animVersion[1] || !(animVersion[1] > minimum[1]) && (minimum[2] > animVersion[2] || !(animVersion[2] > minimum[2]) && null))
                                            }
                                            var minimumVersion, checkText = function() {
                                                    var minimumVersion = [4, 4, 14];

                                                    function iterateLayers(layers) {
                                                        var i, textLayer, documentData, len = layers.length;
                                                        for (i = 0; i < len; i += 1) 5 === layers[i].ty && (documentData = void 0, documentData = (textLayer = layers[i]).t.d, textLayer.t.d = {
                                                            k: [{
                                                                s: documentData,
                                                                t: 0
                                                            }]
                                                        })
                                                    }
                                                    return function(animationData) {
                                                        if (checkVersion(minimumVersion, animationData.v) && (iterateLayers(animationData.layers), animationData.assets)) {
                                                            var i, len = animationData.assets.length;
                                                            for (i = 0; i < len; i += 1) animationData.assets[i].layers && iterateLayers(animationData.assets[i].layers)
                                                        }
                                                    }
                                                }(),
                                                checkChars = (minimumVersion = [4, 7, 99], function(animationData) {
                                                    if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                                                        var i, len = animationData.chars.length;
                                                        for (i = 0; i < len; i += 1) {
                                                            var charData = animationData.chars[i];
                                                            charData.data && charData.data.shapes && (completeShapes(charData.data.shapes), charData.data.ip = 0, charData.data.op = 99999, charData.data.st = 0, charData.data.sr = 1, charData.data.ks = {
                                                                p: {
                                                                    k: [0, 0],
                                                                    a: 0
                                                                },
                                                                s: {
                                                                    k: [100, 100],
                                                                    a: 0
                                                                },
                                                                a: {
                                                                    k: [0, 0],
                                                                    a: 0
                                                                },
                                                                r: {
                                                                    k: 0,
                                                                    a: 0
                                                                },
                                                                o: {
                                                                    k: 100,
                                                                    a: 0
                                                                }
                                                            }, animationData.chars[i].t || (charData.data.shapes.push({
                                                                ty: "no"
                                                            }), charData.data.shapes[0].it.push({
                                                                p: {
                                                                    k: [0, 0],
                                                                    a: 0
                                                                },
                                                                s: {
                                                                    k: [100, 100],
                                                                    a: 0
                                                                },
                                                                a: {
                                                                    k: [0, 0],
                                                                    a: 0
                                                                },
                                                                r: {
                                                                    k: 0,
                                                                    a: 0
                                                                },
                                                                o: {
                                                                    k: 100,
                                                                    a: 0
                                                                },
                                                                sk: {
                                                                    k: 0,
                                                                    a: 0
                                                                },
                                                                sa: {
                                                                    k: 0,
                                                                    a: 0
                                                                },
                                                                ty: "tr"
                                                            })))
                                                        }
                                                    }
                                                }),
                                                checkPathProperties = function() {
                                                    var minimumVersion = [5, 7, 15];

                                                    function iterateLayers(layers) {
                                                        var i, pathData, len = layers.length;
                                                        for (i = 0; i < len; i += 1) 5 === layers[i].ty && (pathData = void 0, "number" == typeof(pathData = layers[i].t.p).a && (pathData.a = {
                                                            a: 0,
                                                            k: pathData.a
                                                        }), "number" == typeof pathData.p && (pathData.p = {
                                                            a: 0,
                                                            k: pathData.p
                                                        }), "number" == typeof pathData.r && (pathData.r = {
                                                            a: 0,
                                                            k: pathData.r
                                                        }))
                                                    }
                                                    return function(animationData) {
                                                        if (checkVersion(minimumVersion, animationData.v) && (iterateLayers(animationData.layers), animationData.assets)) {
                                                            var i, len = animationData.assets.length;
                                                            for (i = 0; i < len; i += 1) animationData.assets[i].layers && iterateLayers(animationData.assets[i].layers)
                                                        }
                                                    }
                                                }(),
                                                checkColors = function() {
                                                    var minimumVersion = [4, 1, 9];

                                                    function iterateShapes(shapes) {
                                                        var i, j, jLen, len = shapes.length;
                                                        for (i = 0; i < len; i += 1)
                                                            if ("gr" === shapes[i].ty) iterateShapes(shapes[i].it);
                                                            else if ("fl" === shapes[i].ty || "st" === shapes[i].ty)
                                                            if (shapes[i].c.k && shapes[i].c.k[0].i)
                                                                for (jLen = shapes[i].c.k.length, j = 0; j < jLen; j += 1) shapes[i].c.k[j].s && (shapes[i].c.k[j].s[0] /= 255, shapes[i].c.k[j].s[1] /= 255, shapes[i].c.k[j].s[2] /= 255, shapes[i].c.k[j].s[3] /= 255), shapes[i].c.k[j].e && (shapes[i].c.k[j].e[0] /= 255, shapes[i].c.k[j].e[1] /= 255, shapes[i].c.k[j].e[2] /= 255, shapes[i].c.k[j].e[3] /= 255);
                                                            else shapes[i].c.k[0] /= 255, shapes[i].c.k[1] /= 255, shapes[i].c.k[2] /= 255, shapes[i].c.k[3] /= 255
                                                    }

                                                    function iterateLayers(layers) {
                                                        var i, len = layers.length;
                                                        for (i = 0; i < len; i += 1) 4 === layers[i].ty && iterateShapes(layers[i].shapes)
                                                    }
                                                    return function(animationData) {
                                                        if (checkVersion(minimumVersion, animationData.v) && (iterateLayers(animationData.layers), animationData.assets)) {
                                                            var i, len = animationData.assets.length;
                                                            for (i = 0; i < len; i += 1) animationData.assets[i].layers && iterateLayers(animationData.assets[i].layers)
                                                        }
                                                    }
                                                }(),
                                                checkShapes = function() {
                                                    var minimumVersion = [4, 4, 18];

                                                    function completeClosingShapes(arr) {
                                                        var i, j, jLen;
                                                        for (i = arr.length - 1; i >= 0; i -= 1)
                                                            if ("sh" === arr[i].ty)
                                                                if (arr[i].ks.k.i) arr[i].ks.k.c = arr[i].closed;
                                                                else
                                                                    for (jLen = arr[i].ks.k.length, j = 0; j < jLen; j += 1) arr[i].ks.k[j].s && (arr[i].ks.k[j].s[0].c = arr[i].closed), arr[i].ks.k[j].e && (arr[i].ks.k[j].e[0].c = arr[i].closed);
                                                        else "gr" === arr[i].ty && completeClosingShapes(arr[i].it)
                                                    }

                                                    function iterateLayers(layers) {
                                                        var layerData, i, j, jLen, k, kLen, len = layers.length;
                                                        for (i = 0; i < len; i += 1) {
                                                            if ((layerData = layers[i]).hasMask) {
                                                                var maskProps = layerData.masksProperties;
                                                                for (jLen = maskProps.length, j = 0; j < jLen; j += 1)
                                                                    if (maskProps[j].pt.k.i) maskProps[j].pt.k.c = maskProps[j].cl;
                                                                    else
                                                                        for (kLen = maskProps[j].pt.k.length, k = 0; k < kLen; k += 1) maskProps[j].pt.k[k].s && (maskProps[j].pt.k[k].s[0].c = maskProps[j].cl), maskProps[j].pt.k[k].e && (maskProps[j].pt.k[k].e[0].c = maskProps[j].cl)
                                                            }
                                                            4 === layerData.ty && completeClosingShapes(layerData.shapes)
                                                        }
                                                    }
                                                    return function(animationData) {
                                                        if (checkVersion(minimumVersion, animationData.v) && (iterateLayers(animationData.layers), animationData.assets)) {
                                                            var i, len = animationData.assets.length;
                                                            for (i = 0; i < len; i += 1) animationData.assets[i].layers && iterateLayers(animationData.assets[i].layers)
                                                        }
                                                    }
                                                }();

                                            function completeText(data) {
                                                0 === data.t.a.length && data.t.p
                                            }
                                            var moduleOb = {
                                                completeData: function completeData(animationData) {
                                                    animationData.__complete || (checkColors(animationData), checkText(animationData), checkChars(animationData), checkPathProperties(animationData), checkShapes(animationData), completeLayers(animationData.layers, animationData.assets), function completeChars(chars, assets) {
                                                        if (chars) {
                                                            var i = 0,
                                                                len = chars.length;
                                                            for (i = 0; i < len; i += 1) 1 === chars[i].t && (chars[i].data.layers = findCompLayers(chars[i].data.refId, assets), completeLayers(chars[i].data.layers, assets))
                                                        }
                                                    }(animationData.chars, animationData.assets), animationData.__complete = !0)
                                                }
                                            };
                                            return moduleOb.checkColors = checkColors, moduleOb.checkChars = checkChars, moduleOb.checkPathProperties = checkPathProperties, moduleOb.checkShapes = checkShapes, moduleOb.completeLayers = completeLayers, moduleOb
                                        }()), _workerSelf.assetLoader || (_workerSelf.assetLoader = function() {
                                            function formatResponse(xhr) {
                                                var contentTypeHeader = xhr.getResponseHeader("content-type");
                                                return contentTypeHeader && "json" === xhr.responseType && -1 !== contentTypeHeader.indexOf("json") || xhr.response && "object" === _typeof$5(xhr.response) ? xhr.response : xhr.response && "string" == typeof xhr.response ? JSON.parse(xhr.response) : xhr.responseText ? JSON.parse(xhr.responseText) : null
                                            }
                                            return {
                                                load: function loadAsset(path, fullPath, callback, errorCallback) {
                                                    var response, xhr = new XMLHttpRequest;
                                                    try {
                                                        xhr.responseType = "json"
                                                    } catch (err) {}
                                                    xhr.onreadystatechange = function() {
                                                        if (4 === xhr.readyState)
                                                            if (200 === xhr.status) response = formatResponse(xhr), callback(response);
                                                            else try {
                                                                response = formatResponse(xhr), callback(response)
                                                            } catch (err) {
                                                                errorCallback && errorCallback(err)
                                                            }
                                                    };
                                                    try {
                                                        xhr.open(["G", "E", "T"].join(""), path, !0)
                                                    } catch (error) {
                                                        xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, !0)
                                                    }
                                                    xhr.send()
                                                }
                                            }
                                        }()), "loadAnimation" === e.data.type) _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, (function(data) {
                                        _workerSelf.dataManager.completeData(data), _workerSelf.postMessage({
                                            id: e.data.id,
                                            payload: data,
                                            status: "success"
                                        })
                                    }), (function() {
                                        _workerSelf.postMessage({
                                            id: e.data.id,
                                            status: "error"
                                        })
                                    }));
                                    else if ("complete" === e.data.type) {
                                        var animation = e.data.animation;
                                        _workerSelf.dataManager.completeData(animation), _workerSelf.postMessage({
                                            id: e.data.id,
                                            payload: animation,
                                            status: "success"
                                        })
                                    } else "loadData" === e.data.type && _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, (function(data) {
                                        _workerSelf.postMessage({
                                            id: e.data.id,
                                            payload: data,
                                            status: "success"
                                        })
                                    }), (function() {
                                        _workerSelf.postMessage({
                                            id: e.data.id,
                                            status: "error"
                                        })
                                    }))
                                })), workerInstance.onmessage = function(event) {
                                    var data = event.data,
                                        id = data.id,
                                        process = processes[id];
                                    processes[id] = null, "success" === data.status ? process.onComplete(data.payload) : process.onError && process.onError()
                                })
                            }

                            function createProcess(onComplete, onError) {
                                var id = "processId_" + (_counterId += 1);
                                return processes[id] = {
                                    onComplete: onComplete,
                                    onError: onError
                                }, id
                            }
                            return {
                                loadAnimation: function loadAnimation(path, onComplete, onError) {
                                    setupWorker();
                                    var processId = createProcess(onComplete, onError);
                                    workerInstance.postMessage({
                                        type: "loadAnimation",
                                        path: path,
                                        fullPath: window.location.origin + window.location.pathname,
                                        id: processId
                                    })
                                },
                                loadData: function loadData(path, onComplete, onError) {
                                    setupWorker();
                                    var processId = createProcess(onComplete, onError);
                                    workerInstance.postMessage({
                                        type: "loadData",
                                        path: path,
                                        fullPath: window.location.origin + window.location.pathname,
                                        id: processId
                                    })
                                },
                                completeAnimation: function completeAnimation(anim, onComplete, onError) {
                                    setupWorker();
                                    var processId = createProcess(onComplete, onError);
                                    workerInstance.postMessage({
                                        type: "complete",
                                        animation: anim,
                                        id: processId
                                    })
                                }
                            }
                        }(),
                        ImagePreloader = function() {
                            var proxyImage = function() {
                                var canvas = createTag("canvas");
                                canvas.width = 1, canvas.height = 1;
                                var ctx = canvas.getContext("2d");
                                return ctx.fillStyle = "rgba(0,0,0,0)", ctx.fillRect(0, 0, 1, 1), canvas
                            }();

                            function imageLoaded() {
                                this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                            }

                            function footageLoaded() {
                                this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                            }

                            function getAssetsPath(assetData, assetsPath, originalPath) {
                                var path = "";
                                if (assetData.e) path = assetData.p;
                                else if (assetsPath) {
                                    var imagePath = assetData.p; - 1 !== imagePath.indexOf("images/") && (imagePath = imagePath.split("/")[1]), path = assetsPath + imagePath
                                } else path = originalPath, path += assetData.u ? assetData.u : "", path += assetData.p;
                                return path
                            }

                            function testImageLoaded(img) {
                                var _count = 0,
                                    intervalId = setInterval(function() {
                                        (img.getBBox().width || _count > 500) && (this._imageLoaded(), clearInterval(intervalId)), _count += 1
                                    }.bind(this), 50)
                            }

                            function createFootageData(data) {
                                var ob = {
                                        assetData: data
                                    },
                                    path = getAssetsPath(data, this.assetsPath, this.path);
                                return dataManager.loadData(path, function(footageData) {
                                    ob.img = footageData, this._footageLoaded()
                                }.bind(this), function() {
                                    ob.img = {}, this._footageLoaded()
                                }.bind(this)), ob
                            }

                            function ImagePreloaderFactory() {
                                this._imageLoaded = imageLoaded.bind(this), this._footageLoaded = footageLoaded.bind(this), this.testImageLoaded = testImageLoaded.bind(this), this.createFootageData = createFootageData.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
                            }
                            return ImagePreloaderFactory.prototype = {
                                loadAssets: function loadAssets(assets, cb) {
                                    var i;
                                    this.imagesLoadedCb = cb;
                                    var len = assets.length;
                                    for (i = 0; i < len; i += 1) assets[i].layers || (assets[i].t && "seq" !== assets[i].t ? 3 === assets[i].t && (this.totalFootages += 1, this.images.push(this.createFootageData(assets[i]))) : (this.totalImages += 1, this.images.push(this._createImageData(assets[i]))))
                                },
                                setAssetsPath: function setAssetsPath(path) {
                                    this.assetsPath = path || ""
                                },
                                setPath: function setPath(path) {
                                    this.path = path || ""
                                },
                                loadedImages: function loadedImages() {
                                    return this.totalImages === this.loadedAssets
                                },
                                loadedFootages: function loadedFootages() {
                                    return this.totalFootages === this.loadedFootagesCount
                                },
                                destroy: function destroy() {
                                    this.imagesLoadedCb = null, this.images.length = 0
                                },
                                getAsset: function getAsset(assetData) {
                                    for (var i = 0, len = this.images.length; i < len;) {
                                        if (this.images[i].assetData === assetData) return this.images[i].img;
                                        i += 1
                                    }
                                    return null
                                },
                                createImgData: function createImgData(assetData) {
                                    var path = getAssetsPath(assetData, this.assetsPath, this.path),
                                        img = createTag("img");
                                    img.crossOrigin = "anonymous", img.addEventListener("load", this._imageLoaded, !1), img.addEventListener("error", function() {
                                        ob.img = proxyImage, this._imageLoaded()
                                    }.bind(this), !1), img.src = path;
                                    var ob = {
                                        img: img,
                                        assetData: assetData
                                    };
                                    return ob
                                },
                                createImageData: function createImageData(assetData) {
                                    var path = getAssetsPath(assetData, this.assetsPath, this.path),
                                        img = createNS("image");
                                    isSafari ? this.testImageLoaded(img) : img.addEventListener("load", this._imageLoaded, !1), img.addEventListener("error", function() {
                                        ob.img = proxyImage, this._imageLoaded()
                                    }.bind(this), !1), img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path), this._elementHelper.append ? this._elementHelper.append(img) : this._elementHelper.appendChild(img);
                                    var ob = {
                                        img: img,
                                        assetData: assetData
                                    };
                                    return ob
                                },
                                imageLoaded: imageLoaded,
                                footageLoaded: footageLoaded,
                                setCacheType: function setCacheType(type, elementHelper) {
                                    "svg" === type ? (this._elementHelper = elementHelper, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                                }
                            }, ImagePreloaderFactory
                        }();

                    function BaseEvent() {}
                    BaseEvent.prototype = {
                        triggerEvent: function triggerEvent(eventName, args) {
                            if (this._cbs[eventName])
                                for (var callbacks = this._cbs[eventName], i = 0; i < callbacks.length; i += 1) callbacks[i](args)
                        },
                        addEventListener: function addEventListener(eventName, callback) {
                            return this._cbs[eventName] || (this._cbs[eventName] = []), this._cbs[eventName].push(callback),
                                function() {
                                    this.removeEventListener(eventName, callback)
                                }.bind(this)
                        },
                        removeEventListener: function removeEventListener(eventName, callback) {
                            if (callback) {
                                if (this._cbs[eventName]) {
                                    for (var i = 0, len = this._cbs[eventName].length; i < len;) this._cbs[eventName][i] === callback && (this._cbs[eventName].splice(i, 1), i -= 1, len -= 1), i += 1;
                                    this._cbs[eventName].length || (this._cbs[eventName] = null)
                                }
                            } else this._cbs[eventName] = null
                        }
                    };
                    var markerParser = function() {
                            function parsePayloadLines(payload) {
                                for (var line, lines = payload.split("\r\n"), keys = {}, keysCount = 0, i = 0; i < lines.length; i += 1) 2 === (line = lines[i].split(":")).length && (keys[line[0]] = line[1].trim(), keysCount += 1);
                                if (0 === keysCount) throw new Error;
                                return keys
                            }
                            return function(_markers) {
                                for (var markers = [], i = 0; i < _markers.length; i += 1) {
                                    var _marker = _markers[i],
                                        markerData = {
                                            time: _marker.tm,
                                            duration: _marker.dr
                                        };
                                    try {
                                        markerData.payload = JSON.parse(_markers[i].cm)
                                    } catch (_) {
                                        try {
                                            markerData.payload = parsePayloadLines(_markers[i].cm)
                                        } catch (__) {
                                            markerData.payload = {
                                                name: _markers[i].cm
                                            }
                                        }
                                    }
                                    markers.push(markerData)
                                }
                                return markers
                            }
                        }(),
                        ProjectInterface = function() {
                            function registerComposition(comp) {
                                this.compositions.push(comp)
                            }
                            return function() {
                                function _thisProjectFunction(name) {
                                    for (var i = 0, len = this.compositions.length; i < len;) {
                                        if (this.compositions[i].data && this.compositions[i].data.nm === name) return this.compositions[i].prepareFrame && this.compositions[i].data.xt && this.compositions[i].prepareFrame(this.currentFrame), this.compositions[i].compInterface;
                                        i += 1
                                    }
                                    return null
                                }
                                return _thisProjectFunction.compositions = [], _thisProjectFunction.currentFrame = 0, _thisProjectFunction.registerComposition = registerComposition, _thisProjectFunction
                            }
                        }(),
                        renderers = {},
                        registerRenderer = function registerRenderer(key, value) {
                            renderers[key] = value
                        };

                    function getRenderer(key) {
                        return renderers[key]
                    }

                    function getRegisteredRenderer() {
                        if (renderers.canvas) return "canvas";
                        for (var key in renderers)
                            if (renderers[key]) return key;
                        return ""
                    }

                    function _typeof$4(obj) {
                        return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$4(obj)
                    }
                    var AnimationItem = function AnimationItem() {
                        this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin()
                    };
                    extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(params) {
                        (params.wrapper || params.container) && (this.wrapper = params.wrapper || params.container);
                        var animType = "svg";
                        params.animType ? animType = params.animType : params.renderer && (animType = params.renderer);
                        var RendererClass = getRenderer(animType);
                        this.renderer = new RendererClass(this, params.rendererSettings), this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = animType, "" === params.loop || null === params.loop || void 0 === params.loop || !0 === params.loop ? this.loop = !0 : !1 === params.loop ? this.loop = !1 : this.loop = parseInt(params.loop, 10), this.autoplay = !("autoplay" in params) || params.autoplay, this.name = params.name ? params.name : "", this.autoloadSegments = !Object.prototype.hasOwnProperty.call(params, "autoloadSegments") || params.autoloadSegments, this.assetsPath = params.assetsPath, this.initialSegment = params.initialSegment, params.audioFactory && this.audioController.setAudioFactory(params.audioFactory), params.animationData ? this.setupAnimation(params.animationData) : params.path && (-1 !== params.path.lastIndexOf("\\") ? this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1) : this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1), this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError))
                    }, AnimationItem.prototype.onSetupError = function() {
                        this.trigger("data_failed")
                    }, AnimationItem.prototype.setupAnimation = function(data) {
                        dataManager.completeAnimation(data, this.configAnimation)
                    }, AnimationItem.prototype.setData = function(wrapper, animationData) {
                        animationData && "object" !== _typeof$4(animationData) && (animationData = JSON.parse(animationData));
                        var params = {
                                wrapper: wrapper,
                                animationData: animationData
                            },
                            wrapperAttributes = wrapper.attributes;
                        params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "", params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
                        var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
                        "false" === loop ? params.loop = !1 : "true" === loop ? params.loop = !0 : "" !== loop && (params.loop = parseInt(loop, 10));
                        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : !wrapperAttributes.getNamedItem("bm-autoplay") || wrapperAttributes.getNamedItem("bm-autoplay").value;
                        params.autoplay = "false" !== autoplay, params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "", "false" === (wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "") && (params.prerender = !1), params.path ? this.setParams(params) : this.trigger("destroy")
                    }, AnimationItem.prototype.includeLayers = function(data) {
                        data.op > this.animationData.op && (this.animationData.op = data.op, this.totalFrames = Math.floor(data.op - this.animationData.ip));
                        var i, j, layers = this.animationData.layers,
                            len = layers.length,
                            newLayers = data.layers,
                            jLen = newLayers.length;
                        for (j = 0; j < jLen; j += 1)
                            for (i = 0; i < len;) {
                                if (layers[i].id === newLayers[j].id) {
                                    layers[i] = newLayers[j];
                                    break
                                }
                                i += 1
                            }
                        if ((data.chars || data.fonts) && (this.renderer.globalData.fontManager.addChars(data.chars), this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs)), data.assets)
                            for (len = data.assets.length, i = 0; i < len; i += 1) this.animationData.assets.push(data.assets[i]);
                        this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
                    }, AnimationItem.prototype.onSegmentComplete = function(data) {
                        this.animationData = data;
                        var expressionsPlugin = getExpressionsPlugin();
                        expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
                    }, AnimationItem.prototype.loadNextSegment = function() {
                        var segments = this.animationData.segments;
                        if (!segments || 0 === segments.length || !this.autoloadSegments) return this.trigger("data_ready"), void(this.timeCompleted = this.totalFrames);
                        var segment = segments.shift();
                        this.timeCompleted = segment.time * this.frameRate;
                        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
                        this.segmentPos += 1, dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
                            this.trigger("data_failed")
                        }.bind(this))
                    }, AnimationItem.prototype.loadSegments = function() {
                        this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
                    }, AnimationItem.prototype.imagesLoaded = function() {
                        this.trigger("loaded_images"), this.checkLoaded()
                    }, AnimationItem.prototype.preloadImages = function() {
                        this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
                    }, AnimationItem.prototype.configAnimation = function(animData) {
                        if (this.renderer) try {
                            this.animationData = animData, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(animData), animData.assets || (animData.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(animData.assets), this.markers = markerParser(animData.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                        } catch (error) {
                            this.triggerConfigError(error)
                        }
                    }, AnimationItem.prototype.waitForFontsLoaded = function() {
                        this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
                    }, AnimationItem.prototype.checkLoaded = function() {
                        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages()) {
                            this.isLoaded = !0;
                            var expressionsPlugin = getExpressionsPlugin();
                            expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function() {
                                this.trigger("DOMLoaded")
                            }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play()
                        }
                    }, AnimationItem.prototype.resize = function(width, height) {
                        var _width = "number" == typeof width ? width : void 0,
                            _height = "number" == typeof height ? height : void 0;
                        this.renderer.updateContainerSize(_width, _height)
                    }, AnimationItem.prototype.setSubframe = function(flag) {
                        this.isSubframeEnabled = !!flag
                    }, AnimationItem.prototype.gotoFrame = function() {
                        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame")
                    }, AnimationItem.prototype.renderFrame = function() {
                        if (!1 !== this.isLoaded && this.renderer) try {
                            this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                        } catch (error) {
                            this.triggerRenderFrameError(error)
                        }
                    }, AnimationItem.prototype.play = function(name) {
                        name && this.name !== name || !0 === this.isPaused && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
                    }, AnimationItem.prototype.pause = function(name) {
                        name && this.name !== name || !1 === this.isPaused && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause())
                    }, AnimationItem.prototype.togglePause = function(name) {
                        name && this.name !== name || (!0 === this.isPaused ? this.play() : this.pause())
                    }, AnimationItem.prototype.stop = function(name) {
                        name && this.name !== name || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
                    }, AnimationItem.prototype.getMarkerData = function(markerName) {
                        for (var marker, i = 0; i < this.markers.length; i += 1)
                            if ((marker = this.markers[i]).payload && marker.payload.name === markerName) return marker;
                        return null
                    }, AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {
                        if (!name || this.name === name) {
                            var numValue = Number(value);
                            if (isNaN(numValue)) {
                                var marker = this.getMarkerData(value);
                                marker && this.goToAndStop(marker.time, !0)
                            } else isFrame ? this.setCurrentRawFrameValue(value) : this.setCurrentRawFrameValue(value * this.frameModifier);
                            this.pause()
                        }
                    }, AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {
                        if (!name || this.name === name) {
                            var numValue = Number(value);
                            if (isNaN(numValue)) {
                                var marker = this.getMarkerData(value);
                                marker && (marker.duration ? this.playSegments([marker.time, marker.time + marker.duration], !0) : this.goToAndStop(marker.time, !0))
                            } else this.goToAndStop(numValue, isFrame, name);
                            this.play()
                        }
                    }, AnimationItem.prototype.advanceTime = function(value) {
                        if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                            var nextValue = this.currentRawFrame + value * this.frameModifier,
                                _isComplete = !1;
                            nextValue >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? nextValue >= this.totalFrames ? (this.playCount += 1, this.checkSegments(nextValue % this.totalFrames) || (this.setCurrentRawFrameValue(nextValue % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(nextValue) : this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0) || (_isComplete = !0, nextValue = this.totalFrames - 1) : nextValue < 0 ? this.checkSegments(nextValue % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (_isComplete = !0, nextValue = 0) : (this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(nextValue), _isComplete && (this.setCurrentRawFrameValue(nextValue), this.pause(), this.trigger("complete"))
                        }
                    }, AnimationItem.prototype.adjustSegment = function(arr, offset) {
                        this.playCount = 0, arr[1] < arr[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = arr[0] - arr[1], this.timeCompleted = this.totalFrames, this.firstFrame = arr[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - offset)) : arr[1] > arr[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = arr[1] - arr[0], this.timeCompleted = this.totalFrames, this.firstFrame = arr[0], this.setCurrentRawFrameValue(.001 + offset)), this.trigger("segmentStart")
                    }, AnimationItem.prototype.setSegment = function(init, end) {
                        var pendingFrame = -1;
                        this.isPaused && (this.currentRawFrame + this.firstFrame < init ? pendingFrame = init : this.currentRawFrame + this.firstFrame > end && (pendingFrame = end - init)), this.firstFrame = init, this.totalFrames = end - init, this.timeCompleted = this.totalFrames, -1 !== pendingFrame && this.goToAndStop(pendingFrame, !0)
                    }, AnimationItem.prototype.playSegments = function(arr, forceFlag) {
                        if (forceFlag && (this.segments.length = 0), "object" === _typeof$4(arr[0])) {
                            var i, len = arr.length;
                            for (i = 0; i < len; i += 1) this.segments.push(arr[i])
                        } else this.segments.push(arr);
                        this.segments.length && forceFlag && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
                    }, AnimationItem.prototype.resetSegments = function(forceFlag) {
                        this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), forceFlag && this.checkSegments(0)
                    }, AnimationItem.prototype.checkSegments = function(offset) {
                        return !!this.segments.length && (this.adjustSegment(this.segments.shift(), offset), !0)
                    }, AnimationItem.prototype.destroy = function(name) {
                        name && this.name !== name || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null)
                    }, AnimationItem.prototype.setCurrentRawFrameValue = function(value) {
                        this.currentRawFrame = value, this.gotoFrame()
                    }, AnimationItem.prototype.setSpeed = function(val) {
                        this.playSpeed = val, this.updaFrameModifier()
                    }, AnimationItem.prototype.setDirection = function(val) {
                        this.playDirection = val < 0 ? -1 : 1, this.updaFrameModifier()
                    }, AnimationItem.prototype.setLoop = function(isLooping) {
                        this.loop = isLooping
                    }, AnimationItem.prototype.setVolume = function(val, name) {
                        name && this.name !== name || this.audioController.setVolume(val)
                    }, AnimationItem.prototype.getVolume = function() {
                        return this.audioController.getVolume()
                    }, AnimationItem.prototype.mute = function(name) {
                        name && this.name !== name || this.audioController.mute()
                    }, AnimationItem.prototype.unmute = function(name) {
                        name && this.name !== name || this.audioController.unmute()
                    }, AnimationItem.prototype.updaFrameModifier = function() {
                        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
                    }, AnimationItem.prototype.getPath = function() {
                        return this.path
                    }, AnimationItem.prototype.getAssetsPath = function(assetData) {
                        var path = "";
                        if (assetData.e) path = assetData.p;
                        else if (this.assetsPath) {
                            var imagePath = assetData.p; - 1 !== imagePath.indexOf("images/") && (imagePath = imagePath.split("/")[1]), path = this.assetsPath + imagePath
                        } else path = this.path, path += assetData.u ? assetData.u : "", path += assetData.p;
                        return path
                    }, AnimationItem.prototype.getAssetData = function(id) {
                        for (var i = 0, len = this.assets.length; i < len;) {
                            if (id === this.assets[i].id) return this.assets[i];
                            i += 1
                        }
                        return null
                    }, AnimationItem.prototype.hide = function() {
                        this.renderer.hide()
                    }, AnimationItem.prototype.show = function() {
                        this.renderer.show()
                    }, AnimationItem.prototype.getDuration = function(isFrame) {
                        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate
                    }, AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {
                        try {
                            this.renderer.getElementByPath(path).updateDocumentData(documentData, index)
                        } catch (error) {}
                    }, AnimationItem.prototype.trigger = function(name) {
                        if (this._cbs && this._cbs[name]) switch (name) {
                            case "enterFrame":
                                this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                                break;
                            case "drawnFrame":
                                this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(name, this.drawnFrameEvent);
                                break;
                            case "loopComplete":
                                this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                                break;
                            case "complete":
                                this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                                break;
                            case "segmentStart":
                                this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                                break;
                            case "destroy":
                                this.triggerEvent(name, new BMDestroyEvent(name, this));
                                break;
                            default:
                                this.triggerEvent(name)
                        }
                        "enterFrame" === name && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === name && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult)), "complete" === name && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult)), "segmentStart" === name && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames)), "destroy" === name && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(name, this))
                    }, AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
                        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
                        this.triggerEvent("error", error), this.onError && this.onError.call(this, error)
                    }, AnimationItem.prototype.triggerConfigError = function(nativeError) {
                        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
                        this.triggerEvent("error", error), this.onError && this.onError.call(this, error)
                    };
                    var animationManager = function() {
                            var moduleOb = {},
                                registeredAnimations = [],
                                initTime = 0,
                                len = 0,
                                playingAnimationsNum = 0,
                                _stopped = !0,
                                _isFrozen = !1;

                            function removeElement(ev) {
                                for (var i = 0, animItem = ev.target; i < len;) registeredAnimations[i].animation === animItem && (registeredAnimations.splice(i, 1), i -= 1, len -= 1, animItem.isPaused || subtractPlayingCount()), i += 1
                            }

                            function registerAnimation(element, animationData) {
                                if (!element) return null;
                                for (var i = 0; i < len;) {
                                    if (registeredAnimations[i].elem === element && null !== registeredAnimations[i].elem) return registeredAnimations[i].animation;
                                    i += 1
                                }
                                var animItem = new AnimationItem;
                                return setupAnimation(animItem, element), animItem.setData(element, animationData), animItem
                            }

                            function addPlayingCount() {
                                playingAnimationsNum += 1, activate()
                            }

                            function subtractPlayingCount() {
                                playingAnimationsNum -= 1
                            }

                            function setupAnimation(animItem, element) {
                                animItem.addEventListener("destroy", removeElement), animItem.addEventListener("_active", addPlayingCount), animItem.addEventListener("_idle", subtractPlayingCount), registeredAnimations.push({
                                    elem: element,
                                    animation: animItem
                                }), len += 1
                            }

                            function resume(nowTime) {
                                var i, elapsedTime = nowTime - initTime;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.advanceTime(elapsedTime);
                                initTime = nowTime, playingAnimationsNum && !_isFrozen ? window.requestAnimationFrame(resume) : _stopped = !0
                            }

                            function first(nowTime) {
                                initTime = nowTime, window.requestAnimationFrame(resume)
                            }

                            function activate() {
                                !_isFrozen && playingAnimationsNum && _stopped && (window.requestAnimationFrame(first), _stopped = !1)
                            }
                            return moduleOb.registerAnimation = registerAnimation, moduleOb.loadAnimation = function loadAnimation(params) {
                                var animItem = new AnimationItem;
                                return setupAnimation(animItem, null), animItem.setParams(params), animItem
                            }, moduleOb.setSpeed = function setSpeed(val, animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setSpeed(val, animation)
                            }, moduleOb.setDirection = function setDirection(val, animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setDirection(val, animation)
                            }, moduleOb.play = function play(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.play(animation)
                            }, moduleOb.pause = function pause(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.pause(animation)
                            }, moduleOb.stop = function stop(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.stop(animation)
                            }, moduleOb.togglePause = function togglePause(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.togglePause(animation)
                            }, moduleOb.searchAnimations = function searchAnimations(animationData, standalone, renderer) {
                                var i, animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                                    lenAnims = animElements.length;
                                for (i = 0; i < lenAnims; i += 1) renderer && animElements[i].setAttribute("data-bm-type", renderer), registerAnimation(animElements[i], animationData);
                                if (standalone && 0 === lenAnims) {
                                    renderer || (renderer = "svg");
                                    var body = document.getElementsByTagName("body")[0];
                                    body.innerText = "";
                                    var div = createTag("div");
                                    div.style.width = "100%", div.style.height = "100%", div.setAttribute("data-bm-type", renderer), body.appendChild(div), registerAnimation(div, animationData)
                                }
                            }, moduleOb.resize = function resize() {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.resize()
                            }, moduleOb.goToAndStop = function goToAndStop(value, isFrame, animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.goToAndStop(value, isFrame, animation)
                            }, moduleOb.destroy = function destroy(animation) {
                                var i;
                                for (i = len - 1; i >= 0; i -= 1) registeredAnimations[i].animation.destroy(animation)
                            }, moduleOb.freeze = function freeze() {
                                _isFrozen = !0
                            }, moduleOb.unfreeze = function unfreeze() {
                                _isFrozen = !1, activate()
                            }, moduleOb.setVolume = function setVolume(val, animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.setVolume(val, animation)
                            }, moduleOb.mute = function mute(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.mute(animation)
                            }, moduleOb.unmute = function unmute(animation) {
                                var i;
                                for (i = 0; i < len; i += 1) registeredAnimations[i].animation.unmute(animation)
                            }, moduleOb.getRegisteredAnimations = function getRegisteredAnimations() {
                                var i, lenAnims = registeredAnimations.length,
                                    animations = [];
                                for (i = 0; i < lenAnims; i += 1) animations.push(registeredAnimations[i].animation);
                                return animations
                            }, moduleOb
                        }(),
                        BezierFactory = function() {
                            var ob = {
                                    getBezierEasing: function getBezierEasing(a, b, c, d, nm) {
                                        var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
                                        if (beziers[str]) return beziers[str];
                                        var bezEasing = new BezierEasing([a, b, c, d]);
                                        return beziers[str] = bezEasing, bezEasing
                                    }
                                },
                                beziers = {},
                                kSplineTableSize = 11,
                                kSampleStepSize = 1 / (kSplineTableSize - 1),
                                float32ArraySupported = "function" == typeof Float32Array;

                            function A(aA1, aA2) {
                                return 1 - 3 * aA2 + 3 * aA1
                            }

                            function B(aA1, aA2) {
                                return 3 * aA2 - 6 * aA1
                            }

                            function C(aA1) {
                                return 3 * aA1
                            }

                            function calcBezier(aT, aA1, aA2) {
                                return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT
                            }

                            function getSlope(aT, aA1, aA2) {
                                return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1)
                            }

                            function BezierEasing(points) {
                                this._p = points, this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize), this._precomputed = !1, this.get = this.get.bind(this)
                            }
                            return BezierEasing.prototype = {
                                get: function get(x) {
                                    var mX1 = this._p[0],
                                        mY1 = this._p[1],
                                        mX2 = this._p[2],
                                        mY2 = this._p[3];
                                    return this._precomputed || this._precompute(), mX1 === mY1 && mX2 === mY2 ? x : 0 === x ? 0 : 1 === x ? 1 : calcBezier(this._getTForX(x), mY1, mY2)
                                },
                                _precompute: function _precompute() {
                                    var mX1 = this._p[0],
                                        mY1 = this._p[1],
                                        mX2 = this._p[2],
                                        mY2 = this._p[3];
                                    this._precomputed = !0, mX1 === mY1 && mX2 === mY2 || this._calcSampleValues()
                                },
                                _calcSampleValues: function _calcSampleValues() {
                                    for (var mX1 = this._p[0], mX2 = this._p[2], i = 0; i < kSplineTableSize; ++i) this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)
                                },
                                _getTForX: function _getTForX(aX) {
                                    for (var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues, intervalStart = 0, currentSample = 1, lastSample = kSplineTableSize - 1; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
                                    var guessForT = intervalStart + (aX - mSampleValues[--currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]) * kSampleStepSize,
                                        initialSlope = getSlope(guessForT, mX1, mX2);
                                    return initialSlope >= .001 ? function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
                                        for (var i = 0; i < 4; ++i) {
                                            var currentSlope = getSlope(aGuessT, mX1, mX2);
                                            if (0 === currentSlope) return aGuessT;
                                            aGuessT -= (calcBezier(aGuessT, mX1, mX2) - aX) / currentSlope
                                        }
                                        return aGuessT
                                    }(aX, guessForT, mX1, mX2) : 0 === initialSlope ? guessForT : function binarySubdivide(aX, aA, aB, mX1, mX2) {
                                        var currentX, currentT, i = 0;
                                        do {
                                            (currentX = calcBezier(currentT = aA + (aB - aA) / 2, mX1, mX2) - aX) > 0 ? aB = currentT : aA = currentT
                                        } while (Math.abs(currentX) > 1e-7 && ++i < 10);
                                        return currentT
                                    }(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)
                                }
                            }, ob
                        }(),
                        pooling = {
                            double: function _double(arr) {
                                return arr.concat(createSizedArray(arr.length))
                            }
                        },
                        poolFactory = function(initialLength, _create, _release) {
                            var _length = 0,
                                _maxLength = initialLength,
                                pool = createSizedArray(_maxLength);
                            return {
                                newElement: function newElement() {
                                    return _length ? pool[_length -= 1] : _create()
                                },
                                release: function release(element) {
                                    _length === _maxLength && (pool = pooling.double(pool), _maxLength *= 2), _release && _release(element), pool[_length] = element, _length += 1
                                }
                            }
                        },
                        bezierLengthPool = poolFactory(8, (function create() {
                            return {
                                addedLength: 0,
                                percents: createTypedArray("float32", getDefaultCurveSegments()),
                                lengths: createTypedArray("float32", getDefaultCurveSegments())
                            }
                        })),
                        segmentsLengthPool = poolFactory(8, (function create() {
                            return {
                                lengths: [],
                                totalLength: 0
                            }
                        }), (function release(element) {
                            var i, len = element.lengths.length;
                            for (i = 0; i < len; i += 1) bezierLengthPool.release(element.lengths[i]);
                            element.lengths.length = 0
                        }));

                    function bezFunction() {
                        var math = Math;

                        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
                            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
                            return det1 > -.001 && det1 < .001
                        }
                        var getBezierLength = function(pt1, pt2, pt3, pt4) {
                            var k, i, len, ptCoord, perc, ptDistance, curveSegments = getDefaultCurveSegments(),
                                addedLength = 0,
                                point = [],
                                lastPoint = [],
                                lengthData = bezierLengthPool.newElement();
                            for (len = pt3.length, k = 0; k < curveSegments; k += 1) {
                                for (perc = k / (curveSegments - 1), ptDistance = 0, i = 0; i < len; i += 1) ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i], point[i] = ptCoord, null !== lastPoint[i] && (ptDistance += bmPow(point[i] - lastPoint[i], 2)), lastPoint[i] = point[i];
                                ptDistance && (addedLength += ptDistance = bmSqrt(ptDistance)), lengthData.percents[k] = perc, lengthData.lengths[k] = addedLength
                            }
                            return lengthData.addedLength = addedLength, lengthData
                        };

                        function BezierData(length) {
                            this.segmentLength = 0, this.points = new Array(length)
                        }

                        function PointData(partial, point) {
                            this.partialLength = partial, this.point = point
                        }
                        var storedData, buildBezierData = (storedData = {}, function(pt1, pt2, pt3, pt4) {
                            var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
                            if (!storedData[bezierName]) {
                                var k, i, len, ptCoord, perc, ptDistance, point, curveSegments = getDefaultCurveSegments(),
                                    addedLength = 0,
                                    lastPoint = null;
                                2 === pt1.length && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1]) && (curveSegments = 2);
                                var bezierData = new BezierData(curveSegments);
                                for (len = pt3.length, k = 0; k < curveSegments; k += 1) {
                                    for (point = createSizedArray(len), perc = k / (curveSegments - 1), ptDistance = 0, i = 0; i < len; i += 1) ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i], point[i] = ptCoord, null !== lastPoint && (ptDistance += bmPow(point[i] - lastPoint[i], 2));
                                    addedLength += ptDistance = bmSqrt(ptDistance), bezierData.points[k] = new PointData(ptDistance, point), lastPoint = point
                                }
                                bezierData.segmentLength = addedLength, storedData[bezierName] = bezierData
                            }
                            return storedData[bezierName]
                        });

                        function getDistancePerc(perc, bezierData) {
                            var percents = bezierData.percents,
                                lengths = bezierData.lengths,
                                len = percents.length,
                                initPos = bmFloor((len - 1) * perc),
                                lengthPos = perc * bezierData.addedLength,
                                lPerc = 0;
                            if (initPos === len - 1 || 0 === initPos || lengthPos === lengths[initPos]) return percents[initPos];
                            for (var dir = lengths[initPos] > lengthPos ? -1 : 1, flag = !0; flag;)
                                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos ? (lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]), flag = !1) : initPos += dir, initPos < 0 || initPos >= len - 1) {
                                    if (initPos === len - 1) return percents[initPos];
                                    flag = !1
                                } return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc
                        }
                        var bezierSegmentPoints = createTypedArray("float32", 8);
                        return {
                            getSegmentsLength: function getSegmentsLength(shapeData) {
                                var i, segmentsLength = segmentsLengthPool.newElement(),
                                    closed = shapeData.c,
                                    pathV = shapeData.v,
                                    pathO = shapeData.o,
                                    pathI = shapeData.i,
                                    len = shapeData._length,
                                    lengths = segmentsLength.lengths,
                                    totalLength = 0;
                                for (i = 0; i < len - 1; i += 1) lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]), totalLength += lengths[i].addedLength;
                                return closed && len && (lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]), totalLength += lengths[i].addedLength), segmentsLength.totalLength = totalLength, segmentsLength
                            },
                            getNewSegment: function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
                                startPerc < 0 ? startPerc = 0 : startPerc > 1 && (startPerc = 1);
                                var i, t0 = getDistancePerc(startPerc, bezierData),
                                    t1 = getDistancePerc(endPerc = endPerc > 1 ? 1 : endPerc, bezierData),
                                    len = pt1.length,
                                    u0 = 1 - t0,
                                    u1 = 1 - t1,
                                    u0u0u0 = u0 * u0 * u0,
                                    t0u0u0_3 = t0 * u0 * u0 * 3,
                                    t0t0u0_3 = t0 * t0 * u0 * 3,
                                    t0t0t0 = t0 * t0 * t0,
                                    u0u0u1 = u0 * u0 * u1,
                                    t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1,
                                    t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1,
                                    t0t0t1 = t0 * t0 * t1,
                                    u0u1u1 = u0 * u1 * u1,
                                    t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1,
                                    t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1,
                                    t0t1t1 = t0 * t1 * t1,
                                    u1u1u1 = u1 * u1 * u1,
                                    t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1,
                                    t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1,
                                    t1t1t1 = t1 * t1 * t1;
                                for (i = 0; i < len; i += 1) bezierSegmentPoints[4 * i] = math.round(1e3 * (u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i])) / 1e3, bezierSegmentPoints[4 * i + 1] = math.round(1e3 * (u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i])) / 1e3, bezierSegmentPoints[4 * i + 2] = math.round(1e3 * (u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i])) / 1e3, bezierSegmentPoints[4 * i + 3] = math.round(1e3 * (u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i])) / 1e3;
                                return bezierSegmentPoints
                            },
                            getPointInSegment: function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
                                var t1 = getDistancePerc(percent, bezierData),
                                    u1 = 1 - t1;
                                return [math.round(1e3 * (u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0])) / 1e3, math.round(1e3 * (u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1])) / 1e3]
                            },
                            buildBezierData: buildBezierData,
                            pointOnLine2D: pointOnLine2D,
                            pointOnLine3D: function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
                                if (0 === z1 && 0 === z2 && 0 === z3) return pointOnLine2D(x1, y1, x2, y2, x3, y3);
                                var diffDist, dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2)),
                                    dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2)),
                                    dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
                                return (diffDist = dist1 > dist2 ? dist1 > dist3 ? dist1 - dist2 - dist3 : dist3 - dist2 - dist1 : dist3 > dist2 ? dist3 - dist2 - dist1 : dist2 - dist1 - dist3) > -1e-4 && diffDist < 1e-4
                            }
                        }
                    }
                    var bez = bezFunction(),
                        initFrame = initialDefaultFrame,
                        mathAbs = Math.abs;

                    function interpolateValue(frameNum, caching) {
                        var newValue, offsetTime = this.offsetTime;
                        "multidimensional" === this.propType && (newValue = createTypedArray("float32", this.pv.length));
                        for (var keyData, nextKeyData, keyframeMetadata, k, kLen, perc, jLen, j, fnc, iterationIndex = caching.lastIndex, i = iterationIndex, len = this.keyframes.length - 1, flag = !0; flag;) {
                            if (keyData = this.keyframes[i], nextKeyData = this.keyframes[i + 1], i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                                keyData.h && (keyData = nextKeyData), iterationIndex = 0;
                                break
                            }
                            if (nextKeyData.t - offsetTime > frameNum) {
                                iterationIndex = i;
                                break
                            }
                            i < len - 1 ? i += 1 : (iterationIndex = 0, flag = !1)
                        }
                        keyframeMetadata = this.keyframesMetadata[i] || {};
                        var endValue, nextKeyTime = nextKeyData.t - offsetTime,
                            keyTime = keyData.t - offsetTime;
                        if (keyData.to) {
                            keyframeMetadata.bezierData || (keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti));
                            var bezierData = keyframeMetadata.bezierData;
                            if (frameNum >= nextKeyTime || frameNum < keyTime) {
                                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                                for (kLen = bezierData.points[ind].point.length, k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[ind].point[k]
                            } else {
                                keyframeMetadata.__fnct ? fnc = keyframeMetadata.__fnct : (fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get, keyframeMetadata.__fnct = fnc), perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                                var segmentPerc, distanceInLine = bezierData.segmentLength * perc,
                                    addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
                                for (j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0, flag = !0, jLen = bezierData.points.length; flag;) {
                                    if (addedLength += bezierData.points[j].partialLength, 0 === distanceInLine || 0 === perc || j === bezierData.points.length - 1) {
                                        for (kLen = bezierData.points[j].point.length, k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[j].point[k];
                                        break
                                    }
                                    if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                                        for (segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength, kLen = bezierData.points[j].point.length, k = 0; k < kLen; k += 1) newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                                        break
                                    }
                                    j < jLen - 1 ? j += 1 : flag = !1
                                }
                                caching._lastPoint = j, caching._lastAddedLength = addedLength - bezierData.points[j].partialLength, caching._lastKeyframeIndex = i
                            }
                        } else {
                            var outX, outY, inX, inY, keyValue;
                            if (len = keyData.s.length, endValue = nextKeyData.s || keyData.e, this.sh && 1 !== keyData.h) frameNum >= nextKeyTime ? (newValue[0] = endValue[0], newValue[1] = endValue[1], newValue[2] = endValue[2]) : frameNum <= keyTime ? (newValue[0] = keyData.s[0], newValue[1] = keyData.s[1], newValue[2] = keyData.s[2]) : quaternionToEuler(newValue, slerp(createQuaternion(keyData.s), createQuaternion(endValue), (frameNum - keyTime) / (nextKeyTime - keyTime)));
                            else
                                for (i = 0; i < len; i += 1) 1 !== keyData.h && (frameNum >= nextKeyTime ? perc = 1 : frameNum < keyTime ? perc = 0 : (keyData.o.x.constructor === Array ? (keyframeMetadata.__fnct || (keyframeMetadata.__fnct = []), keyframeMetadata.__fnct[i] ? fnc = keyframeMetadata.__fnct[i] : (outX = void 0 === keyData.o.x[i] ? keyData.o.x[0] : keyData.o.x[i], outY = void 0 === keyData.o.y[i] ? keyData.o.y[0] : keyData.o.y[i], inX = void 0 === keyData.i.x[i] ? keyData.i.x[0] : keyData.i.x[i], inY = void 0 === keyData.i.y[i] ? keyData.i.y[0] : keyData.i.y[i], fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get, keyframeMetadata.__fnct[i] = fnc)) : keyframeMetadata.__fnct ? fnc = keyframeMetadata.__fnct : (outX = keyData.o.x, outY = keyData.o.y, inX = keyData.i.x, inY = keyData.i.y, fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get, keyData.keyframeMetadata = fnc), perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime)))), endValue = nextKeyData.s || keyData.e, keyValue = 1 === keyData.h ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc, "multidimensional" === this.propType ? newValue[i] = keyValue : newValue = keyValue
                        }
                        return caching.lastIndex = iterationIndex, newValue
                    }

                    function slerp(a, b, t) {
                        var omega, cosom, sinom, scale0, scale1, out = [],
                            ax = a[0],
                            ay = a[1],
                            az = a[2],
                            aw = a[3],
                            bx = b[0],
                            by = b[1],
                            bz = b[2],
                            bw = b[3];
                        return (cosom = ax * bx + ay * by + az * bz + aw * bw) < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1 - cosom > 1e-6 ? (omega = Math.acos(cosom), sinom = Math.sin(omega), scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom) : (scale0 = 1 - t, scale1 = t), out[0] = scale0 * ax + scale1 * bx, out[1] = scale0 * ay + scale1 * by, out[2] = scale0 * az + scale1 * bz, out[3] = scale0 * aw + scale1 * bw, out
                    }

                    function quaternionToEuler(out, quat) {
                        var qx = quat[0],
                            qy = quat[1],
                            qz = quat[2],
                            qw = quat[3],
                            heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz),
                            attitude = Math.asin(2 * qx * qy + 2 * qz * qw),
                            bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
                        out[0] = heading / degToRads, out[1] = attitude / degToRads, out[2] = bank / degToRads
                    }

                    function createQuaternion(values) {
                        var heading = values[0] * degToRads,
                            attitude = values[1] * degToRads,
                            bank = values[2] * degToRads,
                            c1 = Math.cos(heading / 2),
                            c2 = Math.cos(attitude / 2),
                            c3 = Math.cos(bank / 2),
                            s1 = Math.sin(heading / 2),
                            s2 = Math.sin(attitude / 2),
                            s3 = Math.sin(bank / 2);
                        return [s1 * s2 * c3 + c1 * c2 * s3, s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * c3 - s1 * s2 * s3]
                    }

                    function getValueAtCurrentTime() {
                        var frameNum = this.comp.renderedFrame - this.offsetTime,
                            initTime = this.keyframes[0].t - this.offsetTime,
                            endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
                            this._caching.lastFrame >= frameNum && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                            var renderResult = this.interpolateValue(frameNum, this._caching);
                            this.pv = renderResult
                        }
                        return this._caching.lastFrame = frameNum, this.pv
                    }

                    function setVValue(val) {
                        var multipliedValue;
                        if ("unidimensional" === this.propType) multipliedValue = val * this.mult, mathAbs(this.v - multipliedValue) > 1e-5 && (this.v = multipliedValue, this._mdf = !0);
                        else
                            for (var i = 0, len = this.v.length; i < len;) multipliedValue = val[i] * this.mult, mathAbs(this.v[i] - multipliedValue) > 1e-5 && (this.v[i] = multipliedValue, this._mdf = !0), i += 1
                    }

                    function processEffectsSequence() {
                        if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                            if (this.lock) this.setVValue(this.pv);
                            else {
                                var i;
                                this.lock = !0, this._mdf = this._isFirstFrame;
                                var len = this.effectsSequence.length,
                                    finalValue = this.kf ? this.pv : this.data.k;
                                for (i = 0; i < len; i += 1) finalValue = this.effectsSequence[i](finalValue);
                                this.setVValue(finalValue), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                            }
                    }

                    function addEffect(effectFunction) {
                        this.effectsSequence.push(effectFunction), this.container.addDynamicProperty(this)
                    }

                    function ValueProperty(elem, data, mult, container) {
                        this.propType = "unidimensional", this.mult = mult || 1, this.data = data, this.v = mult ? data.k * mult : data.k, this.pv = data.k, this._mdf = !1, this.elem = elem, this.container = container, this.comp = elem.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
                    }

                    function MultiDimensionalProperty(elem, data, mult, container) {
                        var i;
                        this.propType = "multidimensional", this.mult = mult || 1, this.data = data, this._mdf = !1, this.elem = elem, this.container = container, this.comp = elem.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                        var len = data.k.length;
                        for (this.v = createTypedArray("float32", len), this.pv = createTypedArray("float32", len), this.vel = createTypedArray("float32", len), i = 0; i < len; i += 1) this.v[i] = data.k[i] * this.mult, this.pv[i] = data.k[i];
                        this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect
                    }

                    function KeyframedValueProperty(elem, data, mult, container) {
                        this.propType = "unidimensional", this.keyframes = data.k, this.keyframesMetadata = [], this.offsetTime = elem.data.st, this.frameId = -1, this._caching = {
                            lastFrame: initFrame,
                            lastIndex: 0,
                            value: 0,
                            _lastKeyframeIndex: -1
                        }, this.k = !0, this.kf = !0, this.data = data, this.mult = mult || 1, this.elem = elem, this.container = container, this.comp = elem.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect
                    }

                    function KeyframedMultidimensionalProperty(elem, data, mult, container) {
                        var i;
                        this.propType = "multidimensional";
                        var s, e, to, ti, len = data.k.length;
                        for (i = 0; i < len - 1; i += 1) data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s && (s = data.k[i].s, e = data.k[i + 1].s, to = data.k[i].to, ti = data.k[i].ti, (2 === s.length && (s[0] !== e[0] || s[1] !== e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || 3 === s.length && (s[0] !== e[0] || s[1] !== e[1] || s[2] !== e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) && (data.k[i].to = null, data.k[i].ti = null), s[0] === e[0] && s[1] === e[1] && 0 === to[0] && 0 === to[1] && 0 === ti[0] && 0 === ti[1] && (2 === s.length || s[2] === e[2] && 0 === to[2] && 0 === ti[2]) && (data.k[i].to = null, data.k[i].ti = null));
                        this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = data, this.keyframes = data.k, this.keyframesMetadata = [], this.offsetTime = elem.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = mult || 1, this.elem = elem, this.container = container, this.comp = elem.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
                        var arrLen = data.k[0].s.length;
                        for (this.v = createTypedArray("float32", arrLen), this.pv = createTypedArray("float32", arrLen), i = 0; i < arrLen; i += 1) this.v[i] = initFrame, this.pv[i] = initFrame;
                        this._caching = {
                            lastFrame: initFrame,
                            lastIndex: 0,
                            value: createTypedArray("float32", arrLen)
                        }, this.addEffect = addEffect
                    }
                    var PropertyFactory = {
                        getProp: function getProp(elem, data, type, mult, container) {
                            var p;
                            if (data.sid && (data = elem.globalData.slotManager.getProp(data)), data.k.length)
                                if ("number" == typeof data.k[0]) p = new MultiDimensionalProperty(elem, data, mult, container);
                                else switch (type) {
                                    case 0:
                                        p = new KeyframedValueProperty(elem, data, mult, container);
                                        break;
                                    case 1:
                                        p = new KeyframedMultidimensionalProperty(elem, data, mult, container)
                                } else p = new ValueProperty(elem, data, mult, container);
                            return p.effectsSequence.length && container.addDynamicProperty(p), p
                        }
                    };

                    function DynamicPropertyContainer() {}
                    DynamicPropertyContainer.prototype = {
                        addDynamicProperty: function addDynamicProperty(prop) {
                            -1 === this.dynamicProperties.indexOf(prop) && (this.dynamicProperties.push(prop), this.container.addDynamicProperty(this), this._isAnimated = !0)
                        },
                        iterateDynamicProperties: function iterateDynamicProperties() {
                            var i;
                            this._mdf = !1;
                            var len = this.dynamicProperties.length;
                            for (i = 0; i < len; i += 1) this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this._mdf = !0)
                        },
                        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
                            this.container = container, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                        }
                    };
                    var pointPool = poolFactory(8, (function create() {
                        return createTypedArray("float32", 2)
                    }));

                    function ShapePath() {
                        this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
                    }
                    ShapePath.prototype.setPathData = function(closed, len) {
                        this.c = closed, this.setLength(len);
                        for (var i = 0; i < len;) this.v[i] = pointPool.newElement(), this.o[i] = pointPool.newElement(), this.i[i] = pointPool.newElement(), i += 1
                    }, ShapePath.prototype.setLength = function(len) {
                        for (; this._maxLength < len;) this.doubleArrayLength();
                        this._length = len
                    }, ShapePath.prototype.doubleArrayLength = function() {
                        this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
                    }, ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
                        var arr;
                        switch (this._length = Math.max(this._length, pos + 1), this._length >= this._maxLength && this.doubleArrayLength(), type) {
                            case "v":
                                arr = this.v;
                                break;
                            case "i":
                                arr = this.i;
                                break;
                            case "o":
                                arr = this.o;
                                break;
                            default:
                                arr = []
                        }(!arr[pos] || arr[pos] && !replace) && (arr[pos] = pointPool.newElement()), arr[pos][0] = x, arr[pos][1] = y
                    }, ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
                        this.setXYAt(vX, vY, "v", pos, replace), this.setXYAt(oX, oY, "o", pos, replace), this.setXYAt(iX, iY, "i", pos, replace)
                    }, ShapePath.prototype.reverse = function() {
                        var newPath = new ShapePath;
                        newPath.setPathData(this.c, this._length);
                        var vertices = this.v,
                            outPoints = this.o,
                            inPoints = this.i,
                            init = 0;
                        this.c && (newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, !1), init = 1);
                        var i, cnt = this._length - 1,
                            len = this._length;
                        for (i = init; i < len; i += 1) newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, !1), cnt -= 1;
                        return newPath
                    }, ShapePath.prototype.length = function() {
                        return this._length
                    };
                    var shapePool = (factory = poolFactory(4, (function create() {
                            return new ShapePath
                        }), (function release(shapePath) {
                            var i, len = shapePath._length;
                            for (i = 0; i < len; i += 1) pointPool.release(shapePath.v[i]), pointPool.release(shapePath.i[i]), pointPool.release(shapePath.o[i]), shapePath.v[i] = null, shapePath.i[i] = null, shapePath.o[i] = null;
                            shapePath._length = 0, shapePath.c = !1
                        })), factory.clone = function clone(shape) {
                            var i, cloned = factory.newElement(),
                                len = void 0 === shape._length ? shape.v.length : shape._length;
                            for (cloned.setLength(len), cloned.c = shape.c, i = 0; i < len; i += 1) cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
                            return cloned
                        }, factory),
                        factory;

                    function ShapeCollection() {
                        this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
                    }
                    ShapeCollection.prototype.addShape = function(shapeData) {
                        this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = shapeData, this._length += 1
                    }, ShapeCollection.prototype.releaseShapes = function() {
                        var i;
                        for (i = 0; i < this._length; i += 1) shapePool.release(this.shapes[i]);
                        this._length = 0
                    };
                    var shapeCollectionPool = (ob = {
                            newShapeCollection: function newShapeCollection() {
                                return _length ? pool[_length -= 1] : new ShapeCollection
                            },
                            release: function release(shapeCollection) {
                                var i, len = shapeCollection._length;
                                for (i = 0; i < len; i += 1) shapePool.release(shapeCollection.shapes[i]);
                                shapeCollection._length = 0, _length === _maxLength && (pool = pooling.double(pool), _maxLength *= 2), pool[_length] = shapeCollection, _length += 1
                            }
                        }, _length = 0, _maxLength = 4, pool = createSizedArray(_maxLength), ob),
                        ob, _length, _maxLength, pool, ShapePropertyFactory = function() {
                            var initFrame = -999999;

                            function interpolateShape(frameNum, previousValue, caching) {
                                var keyPropS, keyPropE, isHold, j, k, jLen, kLen, perc, vertexValue, iterationIndex = caching.lastIndex,
                                    kf = this.keyframes;
                                if (frameNum < kf[0].t - this.offsetTime) keyPropS = kf[0].s[0], isHold = !0, iterationIndex = 0;
                                else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0], isHold = !0;
                                else {
                                    for (var keyData, nextKeyData, keyframeMetadata, i = iterationIndex, len = kf.length - 1, flag = !0; flag && (keyData = kf[i], !((nextKeyData = kf[i + 1]).t - this.offsetTime > frameNum));) i < len - 1 ? i += 1 : flag = !1;
                                    if (keyframeMetadata = this.keyframesMetadata[i] || {}, iterationIndex = i, !(isHold = 1 === keyData.h)) {
                                        if (frameNum >= nextKeyData.t - this.offsetTime) perc = 1;
                                        else if (frameNum < keyData.t - this.offsetTime) perc = 0;
                                        else {
                                            var fnc;
                                            keyframeMetadata.__fnct ? fnc = keyframeMetadata.__fnct : (fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get, keyframeMetadata.__fnct = fnc), perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)))
                                        }
                                        keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0]
                                    }
                                    keyPropS = keyData.s[0]
                                }
                                for (jLen = previousValue._length, kLen = keyPropS.i[0].length, caching.lastIndex = iterationIndex, j = 0; j < jLen; j += 1)
                                    for (k = 0; k < kLen; k += 1) vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc, previousValue.i[j][k] = vertexValue, vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc, previousValue.o[j][k] = vertexValue, vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc, previousValue.v[j][k] = vertexValue
                            }

                            function interpolateShapeCurrentTime() {
                                var frameNum = this.comp.renderedFrame - this.offsetTime,
                                    initTime = this.keyframes[0].t - this.offsetTime,
                                    endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                                    lastFrame = this._caching.lastFrame;
                                return lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime) || (this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0, this.interpolateShape(frameNum, this.pv, this._caching)), this._caching.lastFrame = frameNum, this.pv
                            }

                            function resetShape() {
                                this.paths = this.localShapeCollection
                            }

                            function setVValue(newPath) {
                                (function shapesEqual(shape1, shape2) {
                                    if (shape1._length !== shape2._length || shape1.c !== shape2.c) return !1;
                                    var i, len = shape1._length;
                                    for (i = 0; i < len; i += 1)
                                        if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) return !1;
                                    return !0
                                })(this.v, newPath) || (this.v = shapePool.clone(newPath), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                            }

                            function processEffectsSequence() {
                                if (this.elem.globalData.frameId !== this.frameId)
                                    if (this.effectsSequence.length)
                                        if (this.lock) this.setVValue(this.pv);
                                        else {
                                            var finalValue, i;
                                            this.lock = !0, this._mdf = !1, finalValue = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                                            var len = this.effectsSequence.length;
                                            for (i = 0; i < len; i += 1) finalValue = this.effectsSequence[i](finalValue);
                                            this.setVValue(finalValue), this.lock = !1, this.frameId = this.elem.globalData.frameId
                                        }
                                else this._mdf = !1
                            }

                            function ShapeProperty(elem, data, type) {
                                this.propType = "shape", this.comp = elem.comp, this.container = elem, this.elem = elem, this.data = data, this.k = !1, this.kf = !1, this._mdf = !1;
                                var pathData = 3 === type ? data.pt.k : data.ks.k;
                                this.v = shapePool.clone(pathData), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = resetShape, this.effectsSequence = []
                            }

                            function addEffect(effectFunction) {
                                this.effectsSequence.push(effectFunction), this.container.addDynamicProperty(this)
                            }

                            function KeyframedShapeProperty(elem, data, type) {
                                this.propType = "shape", this.comp = elem.comp, this.elem = elem, this.container = elem, this.offsetTime = elem.data.st, this.keyframes = 3 === type ? data.pt.k : data.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
                                var len = this.keyframes[0].s[0].i.length;
                                this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, len), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = initFrame, this.reset = resetShape, this._caching = {
                                    lastFrame: initFrame,
                                    lastIndex: 0
                                }, this.effectsSequence = [interpolateShapeCurrentTime.bind(this)]
                            }
                            ShapeProperty.prototype.interpolateShape = interpolateShape, ShapeProperty.prototype.getValue = processEffectsSequence, ShapeProperty.prototype.setVValue = setVValue, ShapeProperty.prototype.addEffect = addEffect, KeyframedShapeProperty.prototype.getValue = processEffectsSequence, KeyframedShapeProperty.prototype.interpolateShape = interpolateShape, KeyframedShapeProperty.prototype.setVValue = setVValue, KeyframedShapeProperty.prototype.addEffect = addEffect;
                            var EllShapeProperty = function() {
                                    var cPoint = roundCorner;

                                    function EllShapePropertyFactory(elem, data) {
                                        this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = data.d, this.elem = elem, this.comp = elem.comp, this.frameId = -1, this.initDynamicPropertyContainer(elem), this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this), this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                                    }
                                    return EllShapePropertyFactory.prototype = {
                                        reset: resetShape,
                                        getValue: function getValue() {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                                        },
                                        convertEllToPath: function convertEllToPath() {
                                            var p0 = this.p.v[0],
                                                p1 = this.p.v[1],
                                                s0 = this.s.v[0] / 2,
                                                s1 = this.s.v[1] / 2,
                                                _cw = 3 !== this.d,
                                                _v = this.v;
                                            _v.v[0][0] = p0, _v.v[0][1] = p1 - s1, _v.v[1][0] = _cw ? p0 + s0 : p0 - s0, _v.v[1][1] = p1, _v.v[2][0] = p0, _v.v[2][1] = p1 + s1, _v.v[3][0] = _cw ? p0 - s0 : p0 + s0, _v.v[3][1] = p1, _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint, _v.i[0][1] = p1 - s1, _v.i[1][0] = _cw ? p0 + s0 : p0 - s0, _v.i[1][1] = p1 - s1 * cPoint, _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint, _v.i[2][1] = p1 + s1, _v.i[3][0] = _cw ? p0 - s0 : p0 + s0, _v.i[3][1] = p1 + s1 * cPoint, _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint, _v.o[0][1] = p1 - s1, _v.o[1][0] = _cw ? p0 + s0 : p0 - s0, _v.o[1][1] = p1 + s1 * cPoint, _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint, _v.o[2][1] = p1 + s1, _v.o[3][0] = _cw ? p0 - s0 : p0 + s0, _v.o[3][1] = p1 - s1 * cPoint
                                        }
                                    }, extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory), EllShapePropertyFactory
                                }(),
                                StarShapeProperty = function() {
                                    function StarShapePropertyFactory(elem, data) {
                                        this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = elem, this.comp = elem.comp, this.data = data, this.frameId = -1, this.d = data.d, this.initDynamicPropertyContainer(elem), 1 === data.sy ? (this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this), this.is = PropertyFactory.getProp(elem, data.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this), this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this), this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this), this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this), this.os = PropertyFactory.getProp(elem, data.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                                    }
                                    return StarShapePropertyFactory.prototype = {
                                        reset: resetShape,
                                        getValue: function getValue() {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                                        },
                                        convertStarToPath: function convertStarToPath() {
                                            var i, rad, roundness, perimSegment, numPts = 2 * Math.floor(this.pt.v),
                                                angle = 2 * Math.PI / numPts,
                                                longFlag = !0,
                                                longRad = this.or.v,
                                                shortRad = this.ir.v,
                                                longRound = this.os.v,
                                                shortRound = this.is.v,
                                                longPerimSegment = 2 * Math.PI * longRad / (2 * numPts),
                                                shortPerimSegment = 2 * Math.PI * shortRad / (2 * numPts),
                                                currentAng = -Math.PI / 2;
                                            currentAng += this.r.v;
                                            var dir = 3 === this.data.d ? -1 : 1;
                                            for (this.v._length = 0, i = 0; i < numPts; i += 1) {
                                                roundness = longFlag ? longRound : shortRound, perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                                                var x = (rad = longFlag ? longRad : shortRad) * Math.cos(currentAng),
                                                    y = rad * Math.sin(currentAng),
                                                    ox = 0 === x && 0 === y ? 0 : y / Math.sqrt(x * x + y * y),
                                                    oy = 0 === x && 0 === y ? 0 : -x / Math.sqrt(x * x + y * y);
                                                x += +this.p.v[0], y += +this.p.v[1], this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, !0), longFlag = !longFlag, currentAng += angle * dir
                                            }
                                        },
                                        convertPolygonToPath: function convertPolygonToPath() {
                                            var i, numPts = Math.floor(this.pt.v),
                                                angle = 2 * Math.PI / numPts,
                                                rad = this.or.v,
                                                roundness = this.os.v,
                                                perimSegment = 2 * Math.PI * rad / (4 * numPts),
                                                currentAng = .5 * -Math.PI,
                                                dir = 3 === this.data.d ? -1 : 1;
                                            for (currentAng += this.r.v, this.v._length = 0, i = 0; i < numPts; i += 1) {
                                                var x = rad * Math.cos(currentAng),
                                                    y = rad * Math.sin(currentAng),
                                                    ox = 0 === x && 0 === y ? 0 : y / Math.sqrt(x * x + y * y),
                                                    oy = 0 === x && 0 === y ? 0 : -x / Math.sqrt(x * x + y * y);
                                                x += +this.p.v[0], y += +this.p.v[1], this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, !0), currentAng += angle * dir
                                            }
                                            this.paths.length = 0, this.paths[0] = this.v
                                        }
                                    }, extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory), StarShapePropertyFactory
                                }(),
                                RectShapeProperty = function() {
                                    function RectShapePropertyFactory(elem, data) {
                                        this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = elem, this.comp = elem.comp, this.frameId = -1, this.d = data.d, this.initDynamicPropertyContainer(elem), this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this), this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this), this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                                    }
                                    return RectShapePropertyFactory.prototype = {
                                        convertRectToPath: function convertRectToPath() {
                                            var p0 = this.p.v[0],
                                                p1 = this.p.v[1],
                                                v0 = this.s.v[0] / 2,
                                                v1 = this.s.v[1] / 2,
                                                round = bmMin(v0, v1, this.r.v),
                                                cPoint = round * (1 - roundCorner);
                                            this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, !0), this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, !0), 0 !== round ? (this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, !0), this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, !0), this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, !0), this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, !0), this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, !0), this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, !0)) : (this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2), this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3))) : (this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, !0), 0 !== round ? (this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, !0), this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, !0), this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, !0), this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, !0), this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, !0), this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, !0), this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, !0)) : (this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, !0), this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, !0), this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, !0)))
                                        },
                                        getValue: function getValue() {
                                            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                                        },
                                        reset: resetShape
                                    }, extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory), RectShapePropertyFactory
                                }(),
                                ob = {
                                    getShapeProp: function getShapeProp(elem, data, type) {
                                        var prop;
                                        return 3 === type || 4 === type ? prop = (3 === type ? data.pt : data.ks).k.length ? new KeyframedShapeProperty(elem, data, type) : new ShapeProperty(elem, data, type) : 5 === type ? prop = new RectShapeProperty(elem, data) : 6 === type ? prop = new EllShapeProperty(elem, data) : 7 === type && (prop = new StarShapeProperty(elem, data)), prop.k && elem.addDynamicProperty(prop), prop
                                    },
                                    getConstructorFunction: function getConstructorFunction() {
                                        return ShapeProperty
                                    },
                                    getKeyframedConstructorFunction: function getKeyframedConstructorFunction() {
                                        return KeyframedShapeProperty
                                    }
                                };
                            return ob
                        }(),
                        Matrix = function() {
                            var _cos = Math.cos,
                                _sin = Math.sin,
                                _tan = Math.tan,
                                _rnd = Math.round;

                            function reset() {
                                return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                            }

                            function rotate(angle) {
                                if (0 === angle) return this;
                                var mCos = _cos(angle),
                                    mSin = _sin(angle);
                                return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function rotateX(angle) {
                                if (0 === angle) return this;
                                var mCos = _cos(angle),
                                    mSin = _sin(angle);
                                return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1)
                            }

                            function rotateY(angle) {
                                if (0 === angle) return this;
                                var mCos = _cos(angle),
                                    mSin = _sin(angle);
                                return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1)
                            }

                            function rotateZ(angle) {
                                if (0 === angle) return this;
                                var mCos = _cos(angle),
                                    mSin = _sin(angle);
                                return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function shear(sx, sy) {
                                return this._t(1, sy, sx, 1, 0, 0)
                            }

                            function skew(ax, ay) {
                                return this.shear(_tan(ax), _tan(ay))
                            }

                            function skewFromAxis(ax, angle) {
                                var mCos = _cos(angle),
                                    mSin = _sin(angle);
                                return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                            }

                            function scale(sx, sy, sz) {
                                return sz || 0 === sz || (sz = 1), 1 === sx && 1 === sy && 1 === sz ? this : this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1)
                            }

                            function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                                return this.props[0] = a, this.props[1] = b, this.props[2] = c, this.props[3] = d, this.props[4] = e, this.props[5] = f, this.props[6] = g, this.props[7] = h, this.props[8] = i, this.props[9] = j, this.props[10] = k, this.props[11] = l, this.props[12] = m, this.props[13] = n, this.props[14] = o, this.props[15] = p, this
                            }

                            function translate(tx, ty, tz) {
                                return tz = tz || 0, 0 !== tx || 0 !== ty || 0 !== tz ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1) : this
                            }

                            function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
                                var _p = this.props;
                                if (1 === a2 && 0 === b2 && 0 === c2 && 0 === d2 && 0 === e2 && 1 === f2 && 0 === g2 && 0 === h2 && 0 === i2 && 0 === j2 && 1 === k2 && 0 === l2) return _p[12] = _p[12] * a2 + _p[15] * m2, _p[13] = _p[13] * f2 + _p[15] * n2, _p[14] = _p[14] * k2 + _p[15] * o2, _p[15] *= p2, this._identityCalculated = !1, this;
                                var a1 = _p[0],
                                    b1 = _p[1],
                                    c1 = _p[2],
                                    d1 = _p[3],
                                    e1 = _p[4],
                                    f1 = _p[5],
                                    g1 = _p[6],
                                    h1 = _p[7],
                                    i1 = _p[8],
                                    j1 = _p[9],
                                    k1 = _p[10],
                                    l1 = _p[11],
                                    m1 = _p[12],
                                    n1 = _p[13],
                                    o1 = _p[14],
                                    p1 = _p[15];
                                return _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2, _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2, _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2, _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2, _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2, _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2, _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2, _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2, _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2, _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2, _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2, _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2, _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2, _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2, _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2, _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2, this._identityCalculated = !1, this
                            }

                            function multiply(matrix) {
                                var matrixProps = matrix.props;
                                return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15])
                            }

                            function isIdentity() {
                                return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
                            }

                            function equals(matr) {
                                for (var i = 0; i < 16;) {
                                    if (matr.props[i] !== this.props[i]) return !1;
                                    i += 1
                                }
                                return !0
                            }

                            function clone(matr) {
                                var i;
                                for (i = 0; i < 16; i += 1) matr.props[i] = this.props[i];
                                return matr
                            }

                            function cloneFromProps(props) {
                                var i;
                                for (i = 0; i < 16; i += 1) this.props[i] = props[i]
                            }

                            function applyToPoint(x, y, z) {
                                return {
                                    x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                                    y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                                    z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
                                }
                            }

                            function applyToX(x, y, z) {
                                return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12]
                            }

                            function applyToY(x, y, z) {
                                return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13]
                            }

                            function applyToZ(x, y, z) {
                                return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
                            }

                            function getInverseMatrix() {
                                var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                                    a = this.props[5] / determinant,
                                    b = -this.props[1] / determinant,
                                    c = -this.props[4] / determinant,
                                    d = this.props[0] / determinant,
                                    e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant,
                                    f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant,
                                    inverseMatrix = new Matrix;
                                return inverseMatrix.props[0] = a, inverseMatrix.props[1] = b, inverseMatrix.props[4] = c, inverseMatrix.props[5] = d, inverseMatrix.props[12] = e, inverseMatrix.props[13] = f, inverseMatrix
                            }

                            function inversePoint(pt) {
                                return this.getInverseMatrix().applyToPointArray(pt[0], pt[1], pt[2] || 0)
                            }

                            function inversePoints(pts) {
                                var i, len = pts.length,
                                    retPts = [];
                                for (i = 0; i < len; i += 1) retPts[i] = inversePoint(pts[i]);
                                return retPts
                            }

                            function applyToTriplePoints(pt1, pt2, pt3) {
                                var arr = createTypedArray("float32", 6);
                                if (this.isIdentity()) arr[0] = pt1[0], arr[1] = pt1[1], arr[2] = pt2[0], arr[3] = pt2[1], arr[4] = pt3[0], arr[5] = pt3[1];
                                else {
                                    var p0 = this.props[0],
                                        p1 = this.props[1],
                                        p4 = this.props[4],
                                        p5 = this.props[5],
                                        p12 = this.props[12],
                                        p13 = this.props[13];
                                    arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12, arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13, arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12, arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13, arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12, arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13
                                }
                                return arr
                            }

                            function applyToPointArray(x, y, z) {
                                return this.isIdentity() ? [x, y, z] : [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]]
                            }

                            function applyToPointStringified(x, y) {
                                if (this.isIdentity()) return x + "," + y;
                                var _p = this.props;
                                return Math.round(100 * (x * _p[0] + y * _p[4] + _p[12])) / 100 + "," + Math.round(100 * (x * _p[1] + y * _p[5] + _p[13])) / 100
                            }

                            function toCSS() {
                                for (var i = 0, props = this.props, cssValue = "matrix3d("; i < 16;) cssValue += _rnd(1e4 * props[i]) / 1e4, cssValue += 15 === i ? ")" : ",", i += 1;
                                return cssValue
                            }

                            function roundMatrixProperty(val) {
                                return val < 1e-6 && val > 0 || val > -1e-6 && val < 0 ? _rnd(1e4 * val) / 1e4 : val
                            }

                            function to2dCSS() {
                                var props = this.props;
                                return "matrix(" + roundMatrixProperty(props[0]) + "," + roundMatrixProperty(props[1]) + "," + roundMatrixProperty(props[4]) + "," + roundMatrixProperty(props[5]) + "," + roundMatrixProperty(props[12]) + "," + roundMatrixProperty(props[13]) + ")"
                            }
                            return function() {
                                this.reset = reset, this.rotate = rotate, this.rotateX = rotateX, this.rotateY = rotateY, this.rotateZ = rotateZ, this.skew = skew, this.skewFromAxis = skewFromAxis, this.shear = shear, this.scale = scale, this.setTransform = setTransform, this.translate = translate, this.transform = transform, this.multiply = multiply, this.applyToPoint = applyToPoint, this.applyToX = applyToX, this.applyToY = applyToY, this.applyToZ = applyToZ, this.applyToPointArray = applyToPointArray, this.applyToTriplePoints = applyToTriplePoints, this.applyToPointStringified = applyToPointStringified, this.toCSS = toCSS, this.to2dCSS = to2dCSS, this.clone = clone, this.cloneFromProps = cloneFromProps, this.equals = equals, this.inversePoints = inversePoints, this.inversePoint = inversePoint, this.getInverseMatrix = getInverseMatrix, this._t = this.transform, this.isIdentity = isIdentity, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                            }
                        }();

                    function _typeof$3(obj) {
                        return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$3(obj)
                    }
                    var lottie = {},
                        standalone = "__[STANDALONE]__",
                        animationData = "__[ANIMATIONDATA]__",
                        renderer = "";

                    function setLocation(href) {
                        setLocationHref(href)
                    }

                    function searchAnimations() {
                        !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
                    }

                    function setSubframeRendering(flag) {
                        setSubframeEnabled(flag)
                    }

                    function setPrefix(prefix) {
                        setIdPrefix(prefix)
                    }

                    function loadAnimation(params) {
                        return !0 === standalone && (params.animationData = JSON.parse(animationData)), animationManager.loadAnimation(params)
                    }

                    function setQuality(value) {
                        if ("string" == typeof value) switch (value) {
                            case "high":
                                setDefaultCurveSegments(200);
                                break;
                            default:
                            case "medium":
                                setDefaultCurveSegments(50);
                                break;
                            case "low":
                                setDefaultCurveSegments(10)
                        } else !isNaN(value) && value > 1 && setDefaultCurveSegments(value);
                        getDefaultCurveSegments() >= 50 ? roundValues(!1) : roundValues(!0)
                    }

                    function inBrowser() {
                        return "undefined" != typeof navigator
                    }

                    function installPlugin(type, plugin) {
                        "expressions" === type && setExpressionsPlugin(plugin)
                    }

                    function getFactory(name) {
                        switch (name) {
                            case "propertyFactory":
                                return PropertyFactory;
                            case "shapePropertyFactory":
                                return ShapePropertyFactory;
                            case "matrix":
                                return Matrix;
                            default:
                                return null
                        }
                    }

                    function checkReady() {
                        "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
                    }

                    function getQueryVariable(variable) {
                        for (var vars = queryString.split("&"), i = 0; i < vars.length; i += 1) {
                            var pair = vars[i].split("=");
                            if (decodeURIComponent(pair[0]) == variable) return decodeURIComponent(pair[1])
                        }
                        return null
                    }
                    lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2";
                    var queryString = "";
                    if (standalone) {
                        var scripts = document.getElementsByTagName("script"),
                            index = scripts.length - 1,
                            myScript = scripts[index] || {
                                src: ""
                            };
                        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", renderer = getQueryVariable("renderer")
                    }
                    var readyStateCheckInterval = setInterval(checkReady, 100);
                    try {
                        "object" !== _typeof$3(exports) && __webpack_require__.amdO
                    } catch (err) {}
                    var ShapeModifiers = function() {
                        var ob = {},
                            modifiers = {};
                        return ob.registerModifier = function registerModifier(nm, factory) {
                            modifiers[nm] || (modifiers[nm] = factory)
                        }, ob.getModifier = function getModifier(nm, elem, data) {
                            return new modifiers[nm](elem, data)
                        }, ob
                    }();

                    function ShapeModifier() {}

                    function TrimModifier() {}

                    function PuckerAndBloatModifier() {}
                    ShapeModifier.prototype.initModifierProperties = function() {}, ShapeModifier.prototype.addShapeToModifier = function() {}, ShapeModifier.prototype.addShape = function(data) {
                        if (!this.closed) {
                            data.sh.container.addDynamicProperty(data.sh);
                            var shapeData = {
                                shape: data.sh,
                                data: data,
                                localShapeCollection: shapeCollectionPool.newShapeCollection()
                            };
                            this.shapes.push(shapeData), this.addShapeToModifier(shapeData), this._isAnimated && data.setAsAnimated()
                        }
                    }, ShapeModifier.prototype.init = function(elem, data) {
                        this.shapes = [], this.elem = elem, this.initDynamicPropertyContainer(elem), this.initModifierProperties(elem, data), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                    }, ShapeModifier.prototype.processKeys = function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
                    }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(elem, data) {
                        this.s = PropertyFactory.getProp(elem, data.s, 0, .01, this), this.e = PropertyFactory.getProp(elem, data.e, 0, .01, this), this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = data.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
                    }, TrimModifier.prototype.addShapeToModifier = function(shapeData) {
                        shapeData.pathsData = []
                    }, TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
                        var segments = [];
                        e <= 1 ? segments.push({
                            s: s,
                            e: e
                        }) : s >= 1 ? segments.push({
                            s: s - 1,
                            e: e - 1
                        }) : (segments.push({
                            s: s,
                            e: 1
                        }), segments.push({
                            s: 0,
                            e: e - 1
                        }));
                        var i, segmentOb, shapeSegments = [],
                            len = segments.length;
                        for (i = 0; i < len; i += 1) {
                            var shapeS, shapeE;
                            (segmentOb = segments[i]).e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength || (shapeS = segmentOb.s * totalModifierLength <= addedLength ? 0 : (segmentOb.s * totalModifierLength - addedLength) / shapeLength, shapeE = segmentOb.e * totalModifierLength >= addedLength + shapeLength ? 1 : (segmentOb.e * totalModifierLength - addedLength) / shapeLength, shapeSegments.push([shapeS, shapeE]))
                        }
                        return shapeSegments.length || shapeSegments.push([0, 0]), shapeSegments
                    }, TrimModifier.prototype.releasePathsData = function(pathsData) {
                        var i, len = pathsData.length;
                        for (i = 0; i < len; i += 1) segmentsLengthPool.release(pathsData[i]);
                        return pathsData.length = 0, pathsData
                    }, TrimModifier.prototype.processShapes = function(_isFirstFrame) {
                        var s, e, shapePaths, i;
                        if (this._mdf || _isFirstFrame) {
                            var o = this.o.v % 360 / 360;
                            if (o < 0 && (o += 1), (s = this.s.v > 1 ? 1 + o : this.s.v < 0 ? 0 + o : this.s.v + o) > (e = this.e.v > 1 ? 1 + o : this.e.v < 0 ? 0 + o : this.e.v + o)) {
                                var _s = s;
                                s = e, e = _s
                            }
                            s = 1e-4 * Math.round(1e4 * s), e = 1e-4 * Math.round(1e4 * e), this.sValue = s, this.eValue = e
                        } else s = this.sValue, e = this.eValue;
                        var j, jLen, pathsData, pathData, totalShapeLength, len = this.shapes.length,
                            totalModifierLength = 0;
                        if (e === s)
                            for (i = 0; i < len; i += 1) this.shapes[i].localShapeCollection.releaseShapes(), this.shapes[i].shape._mdf = !0, this.shapes[i].shape.paths = this.shapes[i].localShapeCollection, this._mdf && (this.shapes[i].pathsData.length = 0);
                        else if (1 === e && 0 === s || 0 === e && 1 === s) {
                            if (this._mdf)
                                for (i = 0; i < len; i += 1) this.shapes[i].pathsData.length = 0, this.shapes[i].shape._mdf = !0
                        } else {
                            var shapeData, localShapeCollection, segments = [];
                            for (i = 0; i < len; i += 1)
                                if ((shapeData = this.shapes[i]).shape._mdf || this._mdf || _isFirstFrame || 2 === this.m) {
                                    if (jLen = (shapePaths = shapeData.shape.paths)._length, totalShapeLength = 0, !shapeData.shape._mdf && shapeData.pathsData.length) totalShapeLength = shapeData.totalShapeLength;
                                    else {
                                        for (pathsData = this.releasePathsData(shapeData.pathsData), j = 0; j < jLen; j += 1) pathData = bez.getSegmentsLength(shapePaths.shapes[j]), pathsData.push(pathData), totalShapeLength += pathData.totalLength;
                                        shapeData.totalShapeLength = totalShapeLength, shapeData.pathsData = pathsData
                                    }
                                    totalModifierLength += totalShapeLength, shapeData.shape._mdf = !0
                                } else shapeData.shape.paths = shapeData.localShapeCollection;
                            var edges, shapeS = s,
                                shapeE = e,
                                addedLength = 0;
                            for (i = len - 1; i >= 0; i -= 1)
                                if ((shapeData = this.shapes[i]).shape._mdf) {
                                    for ((localShapeCollection = shapeData.localShapeCollection).releaseShapes(), 2 === this.m && len > 1 ? (edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength), addedLength += shapeData.totalShapeLength) : edges = [
                                            [shapeS, shapeE]
                                        ], jLen = edges.length, j = 0; j < jLen; j += 1) {
                                        shapeS = edges[j][0], shapeE = edges[j][1], segments.length = 0, shapeE <= 1 ? segments.push({
                                            s: shapeData.totalShapeLength * shapeS,
                                            e: shapeData.totalShapeLength * shapeE
                                        }) : shapeS >= 1 ? segments.push({
                                            s: shapeData.totalShapeLength * (shapeS - 1),
                                            e: shapeData.totalShapeLength * (shapeE - 1)
                                        }) : (segments.push({
                                            s: shapeData.totalShapeLength * shapeS,
                                            e: shapeData.totalShapeLength
                                        }), segments.push({
                                            s: 0,
                                            e: shapeData.totalShapeLength * (shapeE - 1)
                                        }));
                                        var newShapesData = this.addShapes(shapeData, segments[0]);
                                        if (segments[0].s !== segments[0].e) {
                                            if (segments.length > 1)
                                                if (shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1].c) {
                                                    var lastShape = newShapesData.pop();
                                                    this.addPaths(newShapesData, localShapeCollection), newShapesData = this.addShapes(shapeData, segments[1], lastShape)
                                                } else this.addPaths(newShapesData, localShapeCollection), newShapesData = this.addShapes(shapeData, segments[1]);
                                            this.addPaths(newShapesData, localShapeCollection)
                                        }
                                    }
                                    shapeData.shape.paths = localShapeCollection
                                }
                        }
                    }, TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
                        var i, len = newPaths.length;
                        for (i = 0; i < len; i += 1) localShapeCollection.addShape(newPaths[i])
                    }, TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
                        shapePath.setXYAt(pt2[0], pt2[1], "o", pos), shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1), newShape && shapePath.setXYAt(pt1[0], pt1[1], "v", pos), shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1)
                    }, TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
                        shapePath.setXYAt(points[1], points[5], "o", pos), shapePath.setXYAt(points[2], points[6], "i", pos + 1), newShape && shapePath.setXYAt(points[0], points[4], "v", pos), shapePath.setXYAt(points[3], points[7], "v", pos + 1)
                    }, TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
                        var i, j, jLen, currentLengthData, segmentCount, lengths, segment, initPos, pathsData = shapeData.pathsData,
                            shapePaths = shapeData.shape.paths.shapes,
                            len = shapeData.shape.paths._length,
                            addedLength = 0,
                            shapes = [],
                            newShape = !0;
                        for (shapePath ? (segmentCount = shapePath._length, initPos = shapePath._length) : (shapePath = shapePool.newElement(), segmentCount = 0, initPos = 0), shapes.push(shapePath), i = 0; i < len; i += 1) {
                            for (lengths = pathsData[i].lengths, shapePath.c = shapePaths[i].c, jLen = shapePaths[i].c ? lengths.length : lengths.length + 1, j = 1; j < jLen; j += 1)
                                if (addedLength + (currentLengthData = lengths[j - 1]).addedLength < shapeSegment.s) addedLength += currentLengthData.addedLength, shapePath.c = !1;
                                else {
                                    if (addedLength > shapeSegment.e) {
                                        shapePath.c = !1;
                                        break
                                    }
                                    shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength ? (this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape), newShape = !1) : (segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]), this.addSegmentFromArray(segment, shapePath, segmentCount, newShape), newShape = !1, shapePath.c = !1), addedLength += currentLengthData.addedLength, segmentCount += 1
                                } if (shapePaths[i].c && lengths.length) {
                                if (currentLengthData = lengths[j - 1], addedLength <= shapeSegment.e) {
                                    var segmentLength = lengths[j - 1].addedLength;
                                    shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength ? (this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape), newShape = !1) : (segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]), this.addSegmentFromArray(segment, shapePath, segmentCount, newShape), newShape = !1, shapePath.c = !1)
                                } else shapePath.c = !1;
                                addedLength += currentLengthData.addedLength, segmentCount += 1
                            }
                            if (shapePath._length && (shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos), shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1)), addedLength > shapeSegment.e) break;
                            i < len - 1 && (shapePath = shapePool.newElement(), newShape = !0, shapes.push(shapePath), segmentCount = 0)
                        }
                        return shapes
                    }, extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {
                        this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
                    }, PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
                        var percent = amount / 100,
                            centerPoint = [0, 0],
                            pathLength = path._length,
                            i = 0;
                        for (i = 0; i < pathLength; i += 1) centerPoint[0] += path.v[i][0], centerPoint[1] += path.v[i][1];
                        centerPoint[0] /= pathLength, centerPoint[1] /= pathLength;
                        var vX, vY, oX, oY, iX, iY, clonedPath = shapePool.newElement();
                        for (clonedPath.c = path.c, i = 0; i < pathLength; i += 1) vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent, vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent, oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent, oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent, iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent, iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent, clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
                        return clonedPath
                    }, PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
                        var shapePaths, i, j, jLen, shapeData, localShapeCollection, len = this.shapes.length,
                            amount = this.amount.v;
                        if (0 !== amount)
                            for (i = 0; i < len; i += 1) {
                                if (localShapeCollection = (shapeData = this.shapes[i]).localShapeCollection, shapeData.shape._mdf || this._mdf || _isFirstFrame)
                                    for (localShapeCollection.releaseShapes(), shapeData.shape._mdf = !0, shapePaths = shapeData.shape.paths.shapes, jLen = shapeData.shape.paths._length, j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                                shapeData.shape.paths = shapeData.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    };
                    var TransformPropertyFactory = function() {
                        var defaultVector = [0, 0];

                        function TransformProperty(elem, data, container) {
                            if (this.elem = elem, this.frameId = -1, this.propType = "transform", this.data = data, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(container || elem), data.p && data.p.s ? (this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this), this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this), data.p.z && (this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(elem, data.p || {
                                    k: [0, 0, 0]
                                }, 1, 0, this), data.rx) {
                                if (this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this), data.or.k[0].ti) {
                                    var i, len = data.or.k.length;
                                    for (i = 0; i < len; i += 1) data.or.k[i].to = null, data.or.k[i].ti = null
                                }
                                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this), this.or.sh = !0
                            } else this.r = PropertyFactory.getProp(elem, data.r || {
                                k: 0
                            }, 0, degToRads, this);
                            data.sk && (this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(elem, data.a || {
                                k: [0, 0, 0]
                            }, 1, 0, this), this.s = PropertyFactory.getProp(elem, data.s || {
                                k: [100, 100, 100]
                            }, 1, .01, this), data.o ? this.o = PropertyFactory.getProp(elem, data.o, 0, .01, elem) : this.o = {
                                _mdf: !1,
                                v: 1
                            }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                        }
                        return TransformProperty.prototype = {
                            applyToMatrix: function applyToMatrix(mat) {
                                var _mdf = this._mdf;
                                this.iterateDynamicProperties(), this._mdf = this._mdf || _mdf, this.a && mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && mat.skewFromAxis(-this.sk.v, this.sa.v), this.r ? mat.rotate(-this.r.v) : mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? mat.translate(this.px.v, this.py.v, -this.pz.v) : mat.translate(this.px.v, this.py.v, 0) : mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                            },
                            getValue: function processKeys(forceRender) {
                                if (this.elem.globalData.frameId !== this.frameId) {
                                    if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || forceRender) {
                                        var frameRate;
                                        if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                            var v1, v2;
                                            if (frameRate = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (v1 = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / frameRate, 0), v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0), v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / frameRate, 0)) : (v1 = this.p.pv, v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / frameRate, this.p.offsetTime));
                                            else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                                v1 = [], v2 = [];
                                                var px = this.px,
                                                    py = this.py;
                                                px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t ? (v1[0] = px.getValueAtTime((px.keyframes[0].t + .01) / frameRate, 0), v1[1] = py.getValueAtTime((py.keyframes[0].t + .01) / frameRate, 0), v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0), v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0)) : px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t ? (v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0), v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0), v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - .01) / frameRate, 0), v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - .01) / frameRate, 0)) : (v1 = [px.pv, py.pv], v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - .01) / frameRate, px.offsetTime), v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - .01) / frameRate, py.offsetTime))
                                            } else v1 = v2 = defaultVector;
                                            this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]))
                                        }
                                        this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                                    }
                                    this.frameId = this.elem.globalData.frameId
                                }
                            },
                            precalculateMatrix: function precalculateMatrix() {
                                if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                                    if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                        if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                        this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                                    }
                                    this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                                }
                            },
                            autoOrient: function autoOrient() {}
                        }, extendPrototype([DynamicPropertyContainer], TransformProperty), TransformProperty.prototype.addDynamicProperty = function addDynamicProperty(prop) {
                            this._addDynamicProperty(prop), this.elem.addDynamicProperty(prop), this._isDirty = !0
                        }, TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                            getTransformProperty: function getTransformProperty(elem, data, container) {
                                return new TransformProperty(elem, data, container)
                            }
                        }
                    }();

                    function RepeaterModifier() {}

                    function RoundCornersModifier() {}

                    function floatEqual(a, b) {
                        return 1e5 * Math.abs(a - b) <= Math.min(Math.abs(a), Math.abs(b))
                    }

                    function floatZero(f) {
                        return Math.abs(f) <= 1e-5
                    }

                    function lerp(p0, p1, amount) {
                        return p0 * (1 - amount) + p1 * amount
                    }

                    function lerpPoint(p0, p1, amount) {
                        return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)]
                    }

                    function quadRoots(a, b, c) {
                        if (0 === a) return [];
                        var s = b * b - 4 * a * c;
                        if (s < 0) return [];
                        var singleRoot = -b / (2 * a);
                        if (0 === s) return [singleRoot];
                        var delta = Math.sqrt(s) / (2 * a);
                        return [singleRoot - delta, singleRoot + delta]
                    }

                    function polynomialCoefficients(p0, p1, p2, p3) {
                        return [3 * p1 - p0 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0]
                    }

                    function singlePoint(p) {
                        return new PolynomialBezier(p, p, p, p, !1)
                    }

                    function PolynomialBezier(p0, p1, p2, p3, linearize) {
                        linearize && pointEqual(p0, p1) && (p1 = lerpPoint(p0, p3, 1 / 3)), linearize && pointEqual(p2, p3) && (p2 = lerpPoint(p0, p3, 2 / 3));
                        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]),
                            coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
                        this.a = [coeffx[0], coeffy[0]], this.b = [coeffx[1], coeffy[1]], this.c = [coeffx[2], coeffy[2]], this.d = [coeffx[3], coeffy[3]], this.points = [p0, p1, p2, p3]
                    }

                    function extrema(bez, comp) {
                        var min = bez.points[0][comp],
                            max = bez.points[bez.points.length - 1][comp];
                        if (min > max) {
                            var e = max;
                            max = min, min = e
                        }
                        for (var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]), i = 0; i < f.length; i += 1)
                            if (f[i] > 0 && f[i] < 1) {
                                var val = bez.point(f[i])[comp];
                                val < min ? min = val : val > max && (max = val)
                            } return {
                            min: min,
                            max: max
                        }
                    }

                    function intersectData(bez, t1, t2) {
                        var box = bez.boundingBox();
                        return {
                            cx: box.cx,
                            cy: box.cy,
                            width: box.width,
                            height: box.height,
                            bez: bez,
                            t: (t1 + t2) / 2,
                            t1: t1,
                            t2: t2
                        }
                    }

                    function splitData(data) {
                        var split = data.bez.split(.5);
                        return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)]
                    }

                    function boxIntersect(b1, b2) {
                        return 2 * Math.abs(b1.cx - b2.cx) < b1.width + b2.width && 2 * Math.abs(b1.cy - b2.cy) < b1.height + b2.height
                    }

                    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
                        if (boxIntersect(d1, d2))
                            if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) intersections.push([d1.t, d2.t]);
                            else {
                                var d1s = splitData(d1),
                                    d2s = splitData(d2);
                                intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion), intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion), intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion), intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion)
                            }
                    }

                    function crossProduct(a, b) {
                        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
                    }

                    function lineIntersection(start1, end1, start2, end2) {
                        var v1 = [start1[0], start1[1], 1],
                            v2 = [end1[0], end1[1], 1],
                            v3 = [start2[0], start2[1], 1],
                            v4 = [end2[0], end2[1], 1],
                            r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
                        return floatZero(r[2]) ? null : [r[0] / r[2], r[1] / r[2]]
                    }

                    function polarOffset(p, angle, length) {
                        return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length]
                    }

                    function pointDistance(p1, p2) {
                        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1])
                    }

                    function pointEqual(p1, p2) {
                        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1])
                    }

                    function ZigZagModifier() {}

                    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
                        var angO = angle - Math.PI / 2,
                            angI = angle + Math.PI / 2,
                            px = point[0] + Math.cos(angle) * direction * amplitude,
                            py = point[1] - Math.sin(angle) * direction * amplitude;
                        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length())
                    }

                    function getPerpendicularVector(pt1, pt2) {
                        var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]],
                            rot = .5 * -Math.PI;
                        return [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]]
                    }

                    function getProjectingAngle(path, cur) {
                        var prevIndex = 0 === cur ? path.length() - 1 : cur - 1,
                            nextIndex = (cur + 1) % path.length(),
                            pVector = getPerpendicularVector(path.v[prevIndex], path.v[nextIndex]);
                        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0])
                    }

                    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
                        var angle = getProjectingAngle(path, cur),
                            point = path.v[cur % path._length],
                            prevPoint = path.v[0 === cur ? path._length - 1 : cur - 1],
                            nextPoint = path.v[(cur + 1) % path._length],
                            prevDist = 2 === pointType ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0,
                            nextDist = 2 === pointType ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
                        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / (2 * (frequency + 1)), prevDist / (2 * (frequency + 1)), pointType)
                    }

                    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
                        for (var i = 0; i < frequency; i += 1) {
                            var t = (i + 1) / (frequency + 1),
                                dist = 2 === pointType ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0,
                                angle = segment.normalAngle(t);
                            setPoint(outputBezier, segment.point(t), angle, direction, amplitude, dist / (2 * (frequency + 1)), dist / (2 * (frequency + 1)), pointType), direction = -direction
                        }
                        return direction
                    }

                    function linearOffset(p1, p2, amount) {
                        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
                        return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)]
                    }

                    function offsetSegment(segment, amount) {
                        var p0, p1a, p1b, p2b, p2a, p3, e;
                        p0 = (e = linearOffset(segment.points[0], segment.points[1], amount))[0], p1a = e[1], p1b = (e = linearOffset(segment.points[1], segment.points[2], amount))[0], p2b = e[1], p2a = (e = linearOffset(segment.points[2], segment.points[3], amount))[0], p3 = e[1];
                        var p1 = lineIntersection(p0, p1a, p1b, p2b);
                        null === p1 && (p1 = p1a);
                        var p2 = lineIntersection(p2a, p3, p1b, p2b);
                        return null === p2 && (p2 = p2a), new PolynomialBezier(p0, p1, p2, p3)
                    }

                    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
                        var p0 = seg1.points[3],
                            p1 = seg2.points[0];
                        if (3 === lineJoin) return p0;
                        if (pointEqual(p0, p1)) return p0;
                        if (2 === lineJoin) {
                            var angleOut = -seg1.tangentAngle(1),
                                angleIn = -seg2.tangentAngle(0) + Math.PI,
                                center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100)),
                                radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2,
                                tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
                            return outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1), tan = polarOffset(p1, angleIn, 2 * radius * roundCorner), outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length()), p1
                        }
                        var intersection = lineIntersection(pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2], p0, p1, pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1]);
                        return intersection && pointDistance(intersection, p0) < miterLimit ? (outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length()), intersection) : p0
                    }

                    function getIntersection(a, b) {
                        var intersect = a.intersections(b);
                        return intersect.length && floatEqual(intersect[0][0], 1) && intersect.shift(), intersect.length ? intersect[0] : null
                    }

                    function pruneSegmentIntersection(a, b) {
                        var outa = a.slice(),
                            outb = b.slice(),
                            intersect = getIntersection(a[a.length - 1], b[0]);
                        return intersect && (outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0], outb[0] = b[0].split(intersect[1])[1]), a.length > 1 && b.length > 1 && (intersect = getIntersection(a[0], b[b.length - 1])) ? [
                            [a[0].split(intersect[0])[0]],
                            [b[b.length - 1].split(intersect[1])[1]]
                        ] : [outa, outb]
                    }

                    function pruneIntersections(segments) {
                        for (var e, i = 1; i < segments.length; i += 1) e = pruneSegmentIntersection(segments[i - 1], segments[i]), segments[i - 1] = e[0], segments[i] = e[1];
                        return segments.length > 1 && (e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]), segments[segments.length - 1] = e[0], segments[0] = e[1]), segments
                    }

                    function offsetSegmentSplit(segment, amount) {
                        var left, right, split, mid, flex = segment.inflectionPoints();
                        if (0 === flex.length) return [offsetSegment(segment, amount)];
                        if (1 === flex.length || floatEqual(flex[1], 1)) return left = (split = segment.split(flex[0]))[0], right = split[1], [offsetSegment(left, amount), offsetSegment(right, amount)];
                        left = (split = segment.split(flex[0]))[0];
                        var t = (flex[1] - flex[0]) / (1 - flex[0]);
                        return mid = (split = split[1].split(t))[0], right = split[1], [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)]
                    }

                    function OffsetPathModifier() {}

                    function getFontProperties(fontData) {
                        for (var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [], fWeight = "normal", fStyle = "normal", len = styles.length, i = 0; i < len; i += 1) switch (styles[i].toLowerCase()) {
                            case "italic":
                                fStyle = "italic";
                                break;
                            case "bold":
                                fWeight = "700";
                                break;
                            case "black":
                                fWeight = "900";
                                break;
                            case "medium":
                                fWeight = "500";
                                break;
                            case "regular":
                            case "normal":
                                fWeight = "400";
                                break;
                            case "light":
                            case "thin":
                                fWeight = "200"
                        }
                        return {
                            style: fStyle,
                            weight: fontData.fWeight || fWeight
                        }
                    }
                    extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(elem, data) {
                        this.getValue = this.processKeys, this.c = PropertyFactory.getProp(elem, data.c, 0, null, this), this.o = PropertyFactory.getProp(elem, data.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this), this.so = PropertyFactory.getProp(elem, data.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, .01, this), this.data = data, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
                    }, RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {
                        var dir = inv ? -1 : 1,
                            scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc),
                            scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
                        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]), rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]), rMatrix.rotate(-transform.r.v * dir * perc), rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]), sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]), sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY), sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2])
                    }, RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
                        for (this.elem = elem, this.arr = arr, this.pos = pos, this.elemsData = elemsData, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(elem), this.initModifierProperties(elem, arr[pos]); pos > 0;) pos -= 1, this._elements.unshift(arr[pos]);
                        this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                    }, RepeaterModifier.prototype.resetElements = function(elements) {
                        var i, len = elements.length;
                        for (i = 0; i < len; i += 1) elements[i]._processed = !1, "gr" === elements[i].ty && this.resetElements(elements[i].it)
                    }, RepeaterModifier.prototype.cloneElements = function(elements) {
                        var newElements = JSON.parse(JSON.stringify(elements));
                        return this.resetElements(newElements), newElements
                    }, RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
                        var i, len = elements.length;
                        for (i = 0; i < len; i += 1) elements[i]._render = renderFlag, "gr" === elements[i].ty && this.changeGroupRender(elements[i].it, renderFlag)
                    }, RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
                        var items, itemsTransform, i, dir, cont, hasReloaded = !1;
                        if (this._mdf || _isFirstFrame) {
                            var renderFlag, copies = Math.ceil(this.c.v);
                            if (this._groups.length < copies) {
                                for (; this._groups.length < copies;) {
                                    var group = {
                                        it: this.cloneElements(this._elements),
                                        ty: "gr"
                                    };
                                    group.it.push({
                                        a: {
                                            a: 0,
                                            ix: 1,
                                            k: [0, 0]
                                        },
                                        nm: "Transform",
                                        o: {
                                            a: 0,
                                            ix: 7,
                                            k: 100
                                        },
                                        p: {
                                            a: 0,
                                            ix: 2,
                                            k: [0, 0]
                                        },
                                        r: {
                                            a: 1,
                                            ix: 6,
                                            k: [{
                                                s: 0,
                                                e: 0,
                                                t: 0
                                            }, {
                                                s: 0,
                                                e: 0,
                                                t: 1
                                            }]
                                        },
                                        s: {
                                            a: 0,
                                            ix: 3,
                                            k: [100, 100]
                                        },
                                        sa: {
                                            a: 0,
                                            ix: 5,
                                            k: 0
                                        },
                                        sk: {
                                            a: 0,
                                            ix: 4,
                                            k: 0
                                        },
                                        ty: "tr"
                                    }), this.arr.splice(0, 0, group), this._groups.splice(0, 0, group), this._currentCopies += 1
                                }
                                this.elem.reloadShapes(), hasReloaded = !0
                            }
                            for (cont = 0, i = 0; i <= this._groups.length - 1; i += 1) {
                                if (renderFlag = cont < copies, this._groups[i]._render = renderFlag, this.changeGroupRender(this._groups[i].it, renderFlag), !renderFlag) {
                                    var elems = this.elemsData[i].it,
                                        transformData = elems[elems.length - 1];
                                    0 !== transformData.transform.op.v ? (transformData.transform.op._mdf = !0, transformData.transform.op.v = 0) : transformData.transform.op._mdf = !1
                                }
                                cont += 1
                            }
                            this._currentCopies = copies;
                            var offset = this.o.v,
                                offsetModulo = offset % 1,
                                roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset),
                                pProps = this.pMatrix.props,
                                rProps = this.rMatrix.props,
                                sProps = this.sMatrix.props;
                            this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                            var j, jLen, iteration = 0;
                            if (offset > 0) {
                                for (; iteration < roundOffset;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), iteration += 1;
                                offsetModulo && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, !1), iteration += offsetModulo)
                            } else if (offset < 0) {
                                for (; iteration > roundOffset;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), iteration -= 1;
                                offsetModulo && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, !0), iteration -= offsetModulo)
                            }
                            for (i = 1 === this.data.m ? 0 : this._currentCopies - 1, dir = 1 === this.data.m ? 1 : -1, cont = this._currentCopies; cont;) {
                                if (jLen = (itemsTransform = (items = this.elemsData[i].it)[items.length - 1].transform.mProps.v.props).length, items[items.length - 1].transform.mProps._mdf = !0, items[items.length - 1].transform.op._mdf = !0, items[items.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), 0 !== iteration) {
                                    for ((0 !== i && 1 === dir || i !== this._currentCopies - 1 && -1 === dir) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]), this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]), this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]), j = 0; j < jLen; j += 1) itemsTransform[j] = this.matrix.props[j];
                                    this.matrix.reset()
                                } else
                                    for (this.matrix.reset(), j = 0; j < jLen; j += 1) itemsTransform[j] = this.matrix.props[j];
                                iteration += 1, cont -= 1, i += dir
                            }
                        } else
                            for (cont = this._currentCopies, i = 0, dir = 1; cont;) itemsTransform = (items = this.elemsData[i].it)[items.length - 1].transform.mProps.v.props, items[items.length - 1].transform.mProps._mdf = !1, items[items.length - 1].transform.op._mdf = !1, cont -= 1, i += dir;
                        return hasReloaded
                    }, RepeaterModifier.prototype.addShape = function() {}, extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {
                        this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
                    }, RoundCornersModifier.prototype.processPath = function(path, round) {
                        var i, clonedPath = shapePool.newElement();
                        clonedPath.c = path.c;
                        var currentV, currentI, currentO, closerV, distance, newPosPerc, vX, vY, oX, oY, iX, iY, len = path._length,
                            index = 0;
                        for (i = 0; i < len; i += 1) currentV = path.v[i], currentO = path.o[i], currentI = path.i[i], currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1] ? 0 !== i && i !== len - 1 || path.c ? (closerV = 0 === i ? path.v[len - 1] : path.v[i - 1], newPosPerc = (distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2))) ? Math.min(distance / 2, round) / distance : 0, vX = iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc, vY = iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc, oX = vX - (vX - currentV[0]) * roundCorner, oY = vY - (vY - currentV[1]) * roundCorner, clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index), index += 1, closerV = i === len - 1 ? path.v[0] : path.v[i + 1], newPosPerc = (distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2))) ? Math.min(distance / 2, round) / distance : 0, vX = oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc, vY = oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc, iX = vX - (vX - currentV[0]) * roundCorner, iY = vY - (vY - currentV[1]) * roundCorner, clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index), index += 1) : (clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index), index += 1) : (clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index), index += 1);
                        return clonedPath
                    }, RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
                        var shapePaths, i, j, jLen, shapeData, localShapeCollection, len = this.shapes.length,
                            rd = this.rd.v;
                        if (0 !== rd)
                            for (i = 0; i < len; i += 1) {
                                if (localShapeCollection = (shapeData = this.shapes[i]).localShapeCollection, shapeData.shape._mdf || this._mdf || _isFirstFrame)
                                    for (localShapeCollection.releaseShapes(), shapeData.shape._mdf = !0, shapePaths = shapeData.shape.paths.shapes, jLen = shapeData.shape.paths._length, j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
                                shapeData.shape.paths = shapeData.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    }, PolynomialBezier.prototype.point = function(t) {
                        return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]]
                    }, PolynomialBezier.prototype.derivative = function(t) {
                        return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]]
                    }, PolynomialBezier.prototype.tangentAngle = function(t) {
                        var p = this.derivative(t);
                        return Math.atan2(p[1], p[0])
                    }, PolynomialBezier.prototype.normalAngle = function(t) {
                        var p = this.derivative(t);
                        return Math.atan2(p[0], p[1])
                    }, PolynomialBezier.prototype.inflectionPoints = function() {
                        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
                        if (floatZero(denom)) return [];
                        var tcusp = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom,
                            square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
                        if (square < 0) return [];
                        var root = Math.sqrt(square);
                        return floatZero(root) ? root > 0 && root < 1 ? [tcusp] : [] : [tcusp - root, tcusp + root].filter((function(r) {
                            return r > 0 && r < 1
                        }))
                    }, PolynomialBezier.prototype.split = function(t) {
                        if (t <= 0) return [singlePoint(this.points[0]), this];
                        if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
                        var p10 = lerpPoint(this.points[0], this.points[1], t),
                            p11 = lerpPoint(this.points[1], this.points[2], t),
                            p12 = lerpPoint(this.points[2], this.points[3], t),
                            p20 = lerpPoint(p10, p11, t),
                            p21 = lerpPoint(p11, p12, t),
                            p3 = lerpPoint(p20, p21, t);
                        return [new PolynomialBezier(this.points[0], p10, p20, p3, !0), new PolynomialBezier(p3, p21, p12, this.points[3], !0)]
                    }, PolynomialBezier.prototype.bounds = function() {
                        return {
                            x: extrema(this, 0),
                            y: extrema(this, 1)
                        }
                    }, PolynomialBezier.prototype.boundingBox = function() {
                        var bounds = this.bounds();
                        return {
                            left: bounds.x.min,
                            right: bounds.x.max,
                            top: bounds.y.min,
                            bottom: bounds.y.max,
                            width: bounds.x.max - bounds.x.min,
                            height: bounds.y.max - bounds.y.min,
                            cx: (bounds.x.max + bounds.x.min) / 2,
                            cy: (bounds.y.max + bounds.y.min) / 2
                        }
                    }, PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
                        void 0 === tolerance && (tolerance = 2), void 0 === maxRecursion && (maxRecursion = 7);
                        var intersections = [];
                        return intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion), intersections
                    }, PolynomialBezier.shapeSegment = function(shapePath, index) {
                        var nextIndex = (index + 1) % shapePath.length();
                        return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], !0)
                    }, PolynomialBezier.shapeSegmentInverted = function(shapePath, index) {
                        var nextIndex = (index + 1) % shapePath.length();
                        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], !0)
                    }, extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function(elem, data) {
                        this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this), this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this), this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this), this._isAnimated = 0 !== this.amplitude.effectsSequence.length || 0 !== this.frequency.effectsSequence.length || 0 !== this.pointsType.effectsSequence.length
                    }, ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
                        var count = path._length,
                            clonedPath = shapePool.newElement();
                        if (clonedPath.c = path.c, path.c || (count -= 1), 0 === count) return clonedPath;
                        var direction = -1,
                            segment = PolynomialBezier.shapeSegment(path, 0);
                        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
                        for (var i = 0; i < count; i += 1) direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction), segment = i !== count - 1 || path.c ? PolynomialBezier.shapeSegment(path, (i + 1) % count) : null, zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
                        return clonedPath
                    }, ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
                        var shapePaths, i, j, jLen, shapeData, localShapeCollection, len = this.shapes.length,
                            amplitude = this.amplitude.v,
                            frequency = Math.max(0, Math.round(this.frequency.v)),
                            pointType = this.pointsType.v;
                        if (0 !== amplitude)
                            for (i = 0; i < len; i += 1) {
                                if (localShapeCollection = (shapeData = this.shapes[i]).localShapeCollection, shapeData.shape._mdf || this._mdf || _isFirstFrame)
                                    for (localShapeCollection.releaseShapes(), shapeData.shape._mdf = !0, shapePaths = shapeData.shape.paths.shapes, jLen = shapeData.shape.paths._length, j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
                                shapeData.shape.paths = shapeData.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    }, extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function(elem, data) {
                        this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this), this.lineJoin = data.lj, this._isAnimated = 0 !== this.amount.effectsSequence.length
                    }, OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
                        var outputBezier = shapePool.newElement();
                        outputBezier.c = inputBezier.c;
                        var i, j, segment, count = inputBezier.length();
                        inputBezier.c || (count -= 1);
                        var multiSegments = [];
                        for (i = 0; i < count; i += 1) segment = PolynomialBezier.shapeSegment(inputBezier, i), multiSegments.push(offsetSegmentSplit(segment, amount));
                        if (!inputBezier.c)
                            for (i = count - 1; i >= 0; i -= 1) segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i), multiSegments.push(offsetSegmentSplit(segment, amount));
                        multiSegments = pruneIntersections(multiSegments);
                        var lastPoint = null,
                            lastSeg = null;
                        for (i = 0; i < multiSegments.length; i += 1) {
                            var multiSegment = multiSegments[i];
                            for (lastSeg && (lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit)), lastSeg = multiSegment[multiSegment.length - 1], j = 0; j < multiSegment.length; j += 1) segment = multiSegment[j], lastPoint && pointEqual(segment.points[0], lastPoint) ? outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1) : outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length()), outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length()), lastPoint = segment.points[3]
                        }
                        return multiSegments.length && joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit), outputBezier
                    }, OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
                        var shapePaths, i, j, jLen, shapeData, localShapeCollection, len = this.shapes.length,
                            amount = this.amount.v,
                            miterLimit = this.miterLimit.v,
                            lineJoin = this.lineJoin;
                        if (0 !== amount)
                            for (i = 0; i < len; i += 1) {
                                if (localShapeCollection = (shapeData = this.shapes[i]).localShapeCollection, shapeData.shape._mdf || this._mdf || _isFirstFrame)
                                    for (localShapeCollection.releaseShapes(), shapeData.shape._mdf = !0, shapePaths = shapeData.shape.paths.shapes, jLen = shapeData.shape.paths._length, j = 0; j < jLen; j += 1) localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
                                shapeData.shape.paths = shapeData.localShapeCollection
                            }
                        this.dynamicProperties.length || (this._mdf = !1)
                    };
                    var FontManager = function() {
                        var emptyChar = {
                                w: 0,
                                size: 0,
                                shapes: [],
                                data: {
                                    shapes: []
                                }
                            },
                            combinedCharacters = [];
                        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                        var REGIONAL_CHARACTER_A_CODE_POINT = 127462,
                            REGIONAL_CHARACTER_Z_CODE_POINT = 127487,
                            surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];

                        function setUpNode(font, family) {
                            var parentNode = createTag("span");
                            parentNode.setAttribute("aria-hidden", !0), parentNode.style.fontFamily = family;
                            var node = createTag("span");
                            node.innerText = "giItT1WQy@!-/#", parentNode.style.position = "absolute", parentNode.style.left = "-10000px", parentNode.style.top = "-10000px", parentNode.style.fontSize = "300px", parentNode.style.fontVariant = "normal", parentNode.style.fontStyle = "normal", parentNode.style.fontWeight = "normal", parentNode.style.letterSpacing = "0", parentNode.appendChild(node), document.body.appendChild(parentNode);
                            var width = node.offsetWidth;
                            return node.style.fontFamily = function trimFontOptions(font) {
                                var i, familyArray = font.split(","),
                                    len = familyArray.length,
                                    enabledFamilies = [];
                                for (i = 0; i < len; i += 1) "sans-serif" !== familyArray[i] && "monospace" !== familyArray[i] && enabledFamilies.push(familyArray[i]);
                                return enabledFamilies.join(",")
                            }(font) + ", " + family, {
                                node: node,
                                w: width,
                                parent: parentNode
                            }
                        }

                        function createHelper(fontData, def) {
                            var helper, engine = document.body && def ? "svg" : "canvas",
                                fontProps = getFontProperties(fontData);
                            if ("svg" === engine) {
                                var tHelper = createNS("text");
                                tHelper.style.fontSize = "100px", tHelper.setAttribute("font-family", fontData.fFamily), tHelper.setAttribute("font-style", fontProps.style), tHelper.setAttribute("font-weight", fontProps.weight), tHelper.textContent = "1", fontData.fClass ? (tHelper.style.fontFamily = "inherit", tHelper.setAttribute("class", fontData.fClass)) : tHelper.style.fontFamily = fontData.fFamily, def.appendChild(tHelper), helper = tHelper
                            } else {
                                var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
                                tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily, helper = tCanvasHelper
                            }
                            return {
                                measureText: function measure(text) {
                                    return "svg" === engine ? (helper.textContent = text, helper.getComputedTextLength()) : helper.measureText(text).width
                                }
                            }
                        }

                        function getCodePoint(string) {
                            var codePoint = 0,
                                first = string.charCodeAt(0);
                            if (first >= 55296 && first <= 56319) {
                                var second = string.charCodeAt(1);
                                second >= 56320 && second <= 57343 && (codePoint = 1024 * (first - 55296) + second - 56320 + 65536)
                            }
                            return codePoint
                        }

                        function isRegionalCode(string) {
                            var codePoint = getCodePoint(string);
                            return codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT
                        }
                        var Font = function Font() {
                            this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
                        };
                        Font.isModifier = function isModifier(firstCharCode, secondCharCode) {
                            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
                            return -1 !== surrogateModifiers.indexOf(sum)
                        }, Font.isZeroWidthJoiner = function isZeroWidthJoiner(charCode) {
                            return 8205 === charCode
                        }, Font.isFlagEmoji = function isFlagEmoji(string) {
                            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2))
                        }, Font.isRegionalCode = isRegionalCode, Font.isCombinedCharacter = function isCombinedCharacter(_char3) {
                            return -1 !== combinedCharacters.indexOf(_char3)
                        }, Font.isRegionalFlag = function isRegionalFlag(text, index) {
                            var codePoint = getCodePoint(text.substr(index, 2));
                            if (127988 !== codePoint) return !1;
                            var count = 0;
                            for (index += 2; count < 5;) {
                                if ((codePoint = getCodePoint(text.substr(index, 2))) < 917601 || codePoint > 917626) return !1;
                                count += 1, index += 2
                            }
                            return 917631 === getCodePoint(text.substr(index, 2))
                        }, Font.isVariationSelector = function isVariationSelector(charCode) {
                            return 65039 === charCode
                        }, Font.BLACK_FLAG_CODE_POINT = 127988;
                        var fontPrototype = {
                            addChars: function addChars(chars) {
                                if (chars) {
                                    var i;
                                    this.chars || (this.chars = []);
                                    var j, found, len = chars.length,
                                        jLen = this.chars.length;
                                    for (i = 0; i < len; i += 1) {
                                        for (j = 0, found = !1; j < jLen;) this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch && (found = !0), j += 1;
                                        found || (this.chars.push(chars[i]), jLen += 1)
                                    }
                                }
                            },
                            addFonts: function addFonts(fontData, defs) {
                                if (fontData) {
                                    if (this.chars) return this.isLoaded = !0, void(this.fonts = fontData.list);
                                    if (!document.body) return this.isLoaded = !0, fontData.list.forEach((function(data) {
                                        data.helper = createHelper(data), data.cache = {}
                                    })), void(this.fonts = fontData.list);
                                    var i, fontArr = fontData.list,
                                        len = fontArr.length,
                                        _pendingFonts = len;
                                    for (i = 0; i < len; i += 1) {
                                        var loadedSelector, j, shouldLoadFont = !0;
                                        if (fontArr[i].loaded = !1, fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, "monospace"), fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, "sans-serif"), fontArr[i].fPath) {
                                            if ("p" === fontArr[i].fOrigin || 3 === fontArr[i].origin) {
                                                if ((loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]')).length > 0 && (shouldLoadFont = !1), shouldLoadFont) {
                                                    var s = createTag("style");
                                                    s.setAttribute("f-forigin", fontArr[i].fOrigin), s.setAttribute("f-origin", fontArr[i].origin), s.setAttribute("f-family", fontArr[i].fFamily), s.type = "text/css", s.innerText = "@font-face {font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}", defs.appendChild(s)
                                                }
                                            } else if ("g" === fontArr[i].fOrigin || 1 === fontArr[i].origin) {
                                                for (loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), j = 0; j < loadedSelector.length; j += 1) - 1 !== loadedSelector[j].href.indexOf(fontArr[i].fPath) && (shouldLoadFont = !1);
                                                if (shouldLoadFont) {
                                                    var l = createTag("link");
                                                    l.setAttribute("f-forigin", fontArr[i].fOrigin), l.setAttribute("f-origin", fontArr[i].origin), l.type = "text/css", l.rel = "stylesheet", l.href = fontArr[i].fPath, document.body.appendChild(l)
                                                }
                                            } else if ("t" === fontArr[i].fOrigin || 2 === fontArr[i].origin) {
                                                for (loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), j = 0; j < loadedSelector.length; j += 1) fontArr[i].fPath === loadedSelector[j].src && (shouldLoadFont = !1);
                                                if (shouldLoadFont) {
                                                    var sc = createTag("link");
                                                    sc.setAttribute("f-forigin", fontArr[i].fOrigin), sc.setAttribute("f-origin", fontArr[i].origin), sc.setAttribute("rel", "stylesheet"), sc.setAttribute("href", fontArr[i].fPath), defs.appendChild(sc)
                                                }
                                            }
                                        } else fontArr[i].loaded = !0, _pendingFonts -= 1;
                                        fontArr[i].helper = createHelper(fontArr[i], defs), fontArr[i].cache = {}, this.fonts.push(fontArr[i])
                                    }
                                    0 === _pendingFonts ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                                } else this.isLoaded = !0
                            },
                            getCharData: function getCharData(_char, style, font) {
                                for (var i = 0, len = this.chars.length; i < len;) {
                                    if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) return this.chars[i];
                                    i += 1
                                }
                                return ("string" == typeof _char && 13 !== _char.charCodeAt(0) || !_char) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", _char, style, font)), emptyChar
                            },
                            getFontByName: function getFontByName(name) {
                                for (var i = 0, len = this.fonts.length; i < len;) {
                                    if (this.fonts[i].fName === name) return this.fonts[i];
                                    i += 1
                                }
                                return this.fonts[0]
                            },
                            measureText: function measureText(_char2, fontName, size) {
                                var fontData = this.getFontByName(fontName),
                                    index = _char2;
                                if (!fontData.cache[index]) {
                                    var tHelper = fontData.helper;
                                    if (" " === _char2) {
                                        var doubleSize = tHelper.measureText("|" + _char2 + "|"),
                                            singleSize = tHelper.measureText("||");
                                        fontData.cache[index] = (doubleSize - singleSize) / 100
                                    } else fontData.cache[index] = tHelper.measureText(_char2) / 100
                                }
                                return fontData.cache[index] * size
                            },
                            checkLoadedFonts: function checkLoadedFonts() {
                                var i, node, w, len = this.fonts.length,
                                    loadedCount = len;
                                for (i = 0; i < len; i += 1) this.fonts[i].loaded ? loadedCount -= 1 : "n" === this.fonts[i].fOrigin || 0 === this.fonts[i].origin ? this.fonts[i].loaded = !0 : (node = this.fonts[i].monoCase.node, w = this.fonts[i].monoCase.w, node.offsetWidth !== w ? (loadedCount -= 1, this.fonts[i].loaded = !0) : (node = this.fonts[i].sansCase.node, w = this.fonts[i].sansCase.w, node.offsetWidth !== w && (loadedCount -= 1, this.fonts[i].loaded = !0)), this.fonts[i].loaded && (this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent), this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent)));
                                0 !== loadedCount && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                            },
                            setIsLoaded: function setIsLoaded() {
                                this.isLoaded = !0
                            }
                        };
                        return Font.prototype = fontPrototype, Font
                    }();

                    function SlotManager(animationData) {
                        this.animationData = animationData
                    }

                    function slotFactory(animationData) {
                        return new SlotManager(animationData)
                    }

                    function RenderableElement() {}
                    SlotManager.prototype.getProp = function(data) {
                        return this.animationData.slots && this.animationData.slots[data.sid] ? Object.assign(data, this.animationData.slots[data.sid].p) : data
                    }, RenderableElement.prototype = {
                        initRenderable: function initRenderable() {
                            this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                        },
                        addRenderableComponent: function addRenderableComponent(component) {
                            -1 === this.renderableComponents.indexOf(component) && this.renderableComponents.push(component)
                        },
                        removeRenderableComponent: function removeRenderableComponent(component) {
                            -1 !== this.renderableComponents.indexOf(component) && this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1)
                        },
                        prepareRenderableFrame: function prepareRenderableFrame(num) {
                            this.checkLayerLimits(num)
                        },
                        checkTransparency: function checkTransparency() {
                            this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                        },
                        checkLayerLimits: function checkLayerLimits(num) {
                            this.data.ip - this.data.st <= num && this.data.op - this.data.st > num ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                        },
                        renderRenderable: function renderRenderable() {
                            var i, len = this.renderableComponents.length;
                            for (i = 0; i < len; i += 1) this.renderableComponents[i].renderFrame(this._isFirstFrame)
                        },
                        sourceRectAtTime: function sourceRectAtTime() {
                            return {
                                top: 0,
                                left: 0,
                                width: 100,
                                height: 100
                            }
                        },
                        getLayerSize: function getLayerSize() {
                            return 5 === this.data.ty ? {
                                w: this.data.textData.width,
                                h: this.data.textData.height
                            } : {
                                w: this.data.width,
                                h: this.data.height
                            }
                        }
                    };
                    var getBlendMode = (blendModeEnums = {
                            0: "source-over",
                            1: "multiply",
                            2: "screen",
                            3: "overlay",
                            4: "darken",
                            5: "lighten",
                            6: "color-dodge",
                            7: "color-burn",
                            8: "hard-light",
                            9: "soft-light",
                            10: "difference",
                            11: "exclusion",
                            12: "hue",
                            13: "saturation",
                            14: "color",
                            15: "luminosity"
                        }, function(mode) {
                            return blendModeEnums[mode] || ""
                        }),
                        blendModeEnums;

                    function SliderEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)
                    }

                    function AngleEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)
                    }

                    function ColorEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container)
                    }

                    function PointEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container)
                    }

                    function LayerIndexEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)
                    }

                    function MaskIndexEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)
                    }

                    function CheckboxEffect(data, elem, container) {
                        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container)
                    }

                    function NoValueEffect() {
                        this.p = {}
                    }

                    function EffectsManager(data, element) {
                        var i, effects = data.ef || [];
                        this.effectElements = [];
                        var effectItem, len = effects.length;
                        for (i = 0; i < len; i += 1) effectItem = new GroupEffect(effects[i], element), this.effectElements.push(effectItem)
                    }

                    function GroupEffect(data, element) {
                        this.init(data, element)
                    }

                    function BaseElement() {}

                    function FrameElement() {}

                    function FootageElement(data, globalData, comp) {
                        this.initFrame(), this.initRenderable(), this.assetData = globalData.getAssetData(data.refId), this.footageData = globalData.imageLoader.getAsset(this.assetData), this.initBaseData(data, globalData, comp)
                    }

                    function AudioElement(data, globalData, comp) {
                        this.initFrame(), this.initRenderable(), this.assetData = globalData.getAssetData(data.refId), this.initBaseData(data, globalData, comp), this._isPlaying = !1, this._canPlay = !1;
                        var assetPath = this.globalData.getAssetsPath(this.assetData);
                        this.audio = this.globalData.audioController.createAudio(assetPath), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                            _placeholder: !0
                        }, this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
                            k: [100]
                        }, 1, .01, this)
                    }

                    function BaseRenderer() {}
                    extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(data, element) {
                        var i;
                        this.data = data, this.effectElements = [], this.initDynamicPropertyContainer(element);
                        var eff, len = this.data.ef.length,
                            effects = this.data.ef;
                        for (i = 0; i < len; i += 1) {
                            switch (eff = null, effects[i].ty) {
                                case 0:
                                    eff = new SliderEffect(effects[i], element, this);
                                    break;
                                case 1:
                                    eff = new AngleEffect(effects[i], element, this);
                                    break;
                                case 2:
                                    eff = new ColorEffect(effects[i], element, this);
                                    break;
                                case 3:
                                    eff = new PointEffect(effects[i], element, this);
                                    break;
                                case 4:
                                case 7:
                                    eff = new CheckboxEffect(effects[i], element, this);
                                    break;
                                case 10:
                                    eff = new LayerIndexEffect(effects[i], element, this);
                                    break;
                                case 11:
                                    eff = new MaskIndexEffect(effects[i], element, this);
                                    break;
                                case 5:
                                    eff = new EffectsManager(effects[i], element, this);
                                    break;
                                default:
                                    eff = new NoValueEffect(effects[i], element, this)
                            }
                            eff && this.effectElements.push(eff)
                        }
                    }, BaseElement.prototype = {
                        checkMasks: function checkMasks() {
                            if (!this.data.hasMask) return !1;
                            for (var i = 0, len = this.data.masksProperties.length; i < len;) {
                                if ("n" !== this.data.masksProperties[i].mode && !1 !== this.data.masksProperties[i].cl) return !0;
                                i += 1
                            }
                            return !1
                        },
                        initExpressions: function initExpressions() {
                            var expressionsInterfaces = getExpressionInterfaces();
                            if (expressionsInterfaces) {
                                var LayerExpressionInterface = expressionsInterfaces("layer"),
                                    EffectsExpressionInterface = expressionsInterfaces("effects"),
                                    ShapeExpressionInterface = expressionsInterfaces("shape"),
                                    TextExpressionInterface = expressionsInterfaces("text"),
                                    CompExpressionInterface = expressionsInterfaces("comp");
                                this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                                var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                                this.layerInterface.registerEffectsInterface(effectsInterface), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
                            }
                        },
                        setBlendMode: function setBlendMode() {
                            var blendModeValue = getBlendMode(this.data.bm);
                            (this.baseElement || this.layerElement).style["mix-blend-mode"] = blendModeValue
                        },
                        initBaseData: function initBaseData(data, globalData, comp) {
                            this.globalData = globalData, this.comp = comp, this.data = data, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                        },
                        getType: function getType() {
                            return this.type
                        },
                        sourceRectAtTime: function sourceRectAtTime() {}
                    }, FrameElement.prototype = {
                        initFrame: function initFrame() {
                            this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                        },
                        prepareProperties: function prepareProperties(num, isVisible) {
                            var i, len = this.dynamicProperties.length;
                            for (i = 0; i < len; i += 1)(isVisible || this._isParent && "transform" === this.dynamicProperties[i].propType) && (this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                        },
                        addDynamicProperty: function addDynamicProperty(prop) {
                            -1 === this.dynamicProperties.indexOf(prop) && this.dynamicProperties.push(prop)
                        }
                    }, FootageElement.prototype.prepareFrame = function() {}, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
                        return null
                    }, FootageElement.prototype.renderFrame = function() {}, FootageElement.prototype.destroy = function() {}, FootageElement.prototype.initExpressions = function() {
                        var expressionsInterfaces = getExpressionInterfaces();
                        if (expressionsInterfaces) {
                            var FootageInterface = expressionsInterfaces("footage");
                            this.layerInterface = FootageInterface(this)
                        }
                    }, FootageElement.prototype.getFootageData = function() {
                        return this.footageData
                    }, AudioElement.prototype.prepareFrame = function(num) {
                        if (this.prepareRenderableFrame(num, !0), this.prepareProperties(num, !0), this.tm._placeholder) this._currentTime = num / this.data.sr;
                        else {
                            var timeRemapped = this.tm.v;
                            this._currentTime = timeRemapped
                        }
                        this._volume = this.lv.v[0];
                        var totalVolume = this._volume * this._volumeMultiplier;
                        this._previousVolume !== totalVolume && (this._previousVolume = totalVolume, this.audio.volume(totalVolume))
                    }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
                        this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
                    }, AudioElement.prototype.show = function() {}, AudioElement.prototype.hide = function() {
                        this.audio.pause(), this._isPlaying = !1
                    }, AudioElement.prototype.pause = function() {
                        this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
                    }, AudioElement.prototype.resume = function() {
                        this._canPlay = !0
                    }, AudioElement.prototype.setRate = function(rateValue) {
                        this.audio.rate(rateValue)
                    }, AudioElement.prototype.volume = function(volumeValue) {
                        this._volumeMultiplier = volumeValue, this._previousVolume = volumeValue * this._volume, this.audio.volume(this._previousVolume)
                    }, AudioElement.prototype.getBaseElement = function() {
                        return null
                    }, AudioElement.prototype.destroy = function() {}, AudioElement.prototype.sourceRectAtTime = function() {}, AudioElement.prototype.initExpressions = function() {}, BaseRenderer.prototype.checkLayers = function(num) {
                        var i, data, len = this.layers.length;
                        for (this.completeLayers = !0, i = len - 1; i >= 0; i -= 1) this.elements[i] || (data = this.layers[i]).ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st && this.buildItem(i), this.completeLayers = !!this.elements[i] && this.completeLayers;
                        this.checkPendingElements()
                    }, BaseRenderer.prototype.createItem = function(layer) {
                        switch (layer.ty) {
                            case 2:
                                return this.createImage(layer);
                            case 0:
                                return this.createComp(layer);
                            case 1:
                                return this.createSolid(layer);
                            case 3:
                            default:
                                return this.createNull(layer);
                            case 4:
                                return this.createShape(layer);
                            case 5:
                                return this.createText(layer);
                            case 6:
                                return this.createAudio(layer);
                            case 13:
                                return this.createCamera(layer);
                            case 15:
                                return this.createFootage(layer)
                        }
                    }, BaseRenderer.prototype.createCamera = function() {
                        throw new Error("You're using a 3d camera. Try the html renderer.")
                    }, BaseRenderer.prototype.createAudio = function(data) {
                        return new AudioElement(data, this.globalData, this)
                    }, BaseRenderer.prototype.createFootage = function(data) {
                        return new FootageElement(data, this.globalData, this)
                    }, BaseRenderer.prototype.buildAllItems = function() {
                        var i, len = this.layers.length;
                        for (i = 0; i < len; i += 1) this.buildItem(i);
                        this.checkPendingElements()
                    }, BaseRenderer.prototype.includeLayers = function(newLayers) {
                        var i;
                        this.completeLayers = !1;
                        var j, len = newLayers.length,
                            jLen = this.layers.length;
                        for (i = 0; i < len; i += 1)
                            for (j = 0; j < jLen;) {
                                if (this.layers[j].id === newLayers[i].id) {
                                    this.layers[j] = newLayers[i];
                                    break
                                }
                                j += 1
                            }
                    }, BaseRenderer.prototype.setProjectInterface = function(pInterface) {
                        this.globalData.projectInterface = pInterface
                    }, BaseRenderer.prototype.initItems = function() {
                        this.globalData.progressiveLoad || this.buildAllItems()
                    }, BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
                        for (var elements = this.elements, layers = this.layers, i = 0, len = layers.length; i < len;) layers[i].ind == parentName && (elements[i] && !0 !== elements[i] ? (hierarchy.push(elements[i]), elements[i].setAsParent(), void 0 !== layers[i].parent ? this.buildElementParenting(element, layers[i].parent, hierarchy) : element.setHierarchy(hierarchy)) : (this.buildItem(i), this.addPendingElement(element))), i += 1
                    }, BaseRenderer.prototype.addPendingElement = function(element) {
                        this.pendingElements.push(element)
                    }, BaseRenderer.prototype.searchExtraCompositions = function(assets) {
                        var i, len = assets.length;
                        for (i = 0; i < len; i += 1)
                            if (assets[i].xt) {
                                var comp = this.createComp(assets[i]);
                                comp.initExpressions(), this.globalData.projectInterface.registerComposition(comp)
                            }
                    }, BaseRenderer.prototype.getElementById = function(ind) {
                        var i, len = this.elements.length;
                        for (i = 0; i < len; i += 1)
                            if (this.elements[i].data.ind === ind) return this.elements[i];
                        return null
                    }, BaseRenderer.prototype.getElementByPath = function(path) {
                        var element, pathValue = path.shift();
                        if ("number" == typeof pathValue) element = this.elements[pathValue];
                        else {
                            var i, len = this.elements.length;
                            for (i = 0; i < len; i += 1)
                                if (this.elements[i].data.nm === pathValue) {
                                    element = this.elements[i];
                                    break
                                }
                        }
                        return 0 === path.length ? element : element.getElementByPath(path)
                    }, BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
                        this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(animData), this.globalData.fontManager.addChars(animData.chars), this.globalData.fontManager.addFonts(animData.fonts, fontsContainer), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = animData.fr, this.globalData.nm = animData.nm, this.globalData.compSize = {
                            w: animData.w,
                            h: animData.h
                        }
                    };
                    var effectTypes = {
                        TRANSFORM_EFFECT: "transformEFfect"
                    };

                    function TransformElement() {}

                    function MaskElement(data, element, globalData) {
                        this.data = data, this.element = element, this.globalData = globalData, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                        var i, path, defs = this.globalData.defs,
                            len = this.masksProperties ? this.masksProperties.length : 0;
                        this.viewData = createSizedArray(len), this.solidPath = "";
                        var j, jLen, rect, expansor, feMorph, x, properties = this.masksProperties,
                            count = 0,
                            currentMasks = [],
                            layerId = createElementID(),
                            maskType = "clipPath",
                            maskRef = "clip-path";
                        for (i = 0; i < len; i += 1)
                            if (("a" !== properties[i].mode && "n" !== properties[i].mode || properties[i].inv || 100 !== properties[i].o.k || properties[i].o.x) && (maskType = "mask", maskRef = "mask"), "s" !== properties[i].mode && "i" !== properties[i].mode || 0 !== count ? rect = null : ((rect = createNS("rect")).setAttribute("fill", "#ffffff"), rect.setAttribute("width", this.element.comp.data.w || 0), rect.setAttribute("height", this.element.comp.data.h || 0), currentMasks.push(rect)), path = createNS("path"), "n" === properties[i].mode) this.viewData[i] = {
                                op: PropertyFactory.getProp(this.element, properties[i].o, 0, .01, this.element),
                                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                                elem: path,
                                lastPath: ""
                            }, defs.appendChild(path);
                            else {
                                var filterID;
                                if (count += 1, path.setAttribute("fill", "s" === properties[i].mode ? "#000000" : "#ffffff"), path.setAttribute("clip-rule", "nonzero"), 0 !== properties[i].x.k ? (maskType = "mask", maskRef = "mask", x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element), filterID = createElementID(), (expansor = createNS("filter")).setAttribute("id", filterID), (feMorph = createNS("feMorphology")).setAttribute("operator", "erode"), feMorph.setAttribute("in", "SourceGraphic"), feMorph.setAttribute("radius", "0"), expansor.appendChild(feMorph), defs.appendChild(expansor), path.setAttribute("stroke", "s" === properties[i].mode ? "#000000" : "#ffffff")) : (feMorph = null, x = null), this.storedData[i] = {
                                        elem: path,
                                        x: x,
                                        expan: feMorph,
                                        lastPath: "",
                                        lastOperator: "",
                                        filterId: filterID,
                                        lastRadius: 0
                                    }, "i" === properties[i].mode) {
                                    jLen = currentMasks.length;
                                    var g = createNS("g");
                                    for (j = 0; j < jLen; j += 1) g.appendChild(currentMasks[j]);
                                    var mask = createNS("mask");
                                    mask.setAttribute("mask-type", "alpha"), mask.setAttribute("id", layerId + "_" + count), mask.appendChild(path), defs.appendChild(mask), g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")"), currentMasks.length = 0, currentMasks.push(g)
                                } else currentMasks.push(path);
                                properties[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = {
                                    elem: path,
                                    lastPath: "",
                                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, .01, this.element),
                                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                                    invRect: rect
                                }, this.viewData[i].prop.k || this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i])
                            } for (this.maskElement = createNS(maskType), len = currentMasks.length, i = 0; i < len; i += 1) this.maskElement.appendChild(currentMasks[i]);
                        count > 0 && (this.maskElement.setAttribute("id", layerId), this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")"), defs.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
                    }
                    TransformElement.prototype = {
                        initTransform: function initTransform() {
                            var mat = new Matrix;
                            this.finalTransform = {
                                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                                    o: 0
                                },
                                _matMdf: !1,
                                _localMatMdf: !1,
                                _opMdf: !1,
                                mat: mat,
                                localMat: mat,
                                localOpacity: 1
                            }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                        },
                        renderTransform: function renderTransform() {
                            if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                                var mat, finalMat = this.finalTransform.mat,
                                    i = 0,
                                    len = this.hierarchy.length;
                                if (!this.finalTransform._matMdf)
                                    for (; i < len;) {
                                        if (this.hierarchy[i].finalTransform.mProp._mdf) {
                                            this.finalTransform._matMdf = !0;
                                            break
                                        }
                                        i += 1
                                    }
                                if (this.finalTransform._matMdf)
                                    for (mat = this.finalTransform.mProp.v.props, finalMat.cloneFromProps(mat), i = 0; i < len; i += 1) finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v)
                            }
                            this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
                        },
                        renderLocalTransform: function renderLocalTransform() {
                            if (this.localTransforms) {
                                var i = 0,
                                    len = this.localTransforms.length;
                                if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                                    for (; i < len;) this.localTransforms[i]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[i]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), i += 1;
                                if (this.finalTransform._localMatMdf) {
                                    var localMat = this.finalTransform.localMat;
                                    for (this.localTransforms[0].matrix.clone(localMat), i = 1; i < len; i += 1) {
                                        var lmat = this.localTransforms[i].matrix;
                                        localMat.multiply(lmat)
                                    }
                                    localMat.multiply(this.finalTransform.mat)
                                }
                                if (this.finalTransform._opMdf) {
                                    var localOp = this.finalTransform.localOpacity;
                                    for (i = 0; i < len; i += 1) localOp *= .01 * this.localTransforms[i].opacity;
                                    this.finalTransform.localOpacity = localOp
                                }
                            }
                        },
                        searchEffectTransforms: function searchEffectTransforms() {
                            if (this.renderableEffectsManager) {
                                var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                                if (transformEffects.length) {
                                    this.localTransforms = [], this.finalTransform.localMat = new Matrix;
                                    var i = 0,
                                        len = transformEffects.length;
                                    for (i = 0; i < len; i += 1) this.localTransforms.push(transformEffects[i])
                                }
                            }
                        },
                        globalToLocal: function globalToLocal(pt) {
                            var transforms = [];
                            transforms.push(this.finalTransform);
                            for (var i, flag = !0, comp = this.comp; flag;) comp.finalTransform ? (comp.data.hasMask && transforms.splice(0, 0, comp.finalTransform), comp = comp.comp) : flag = !1;
                            var ptNew, len = transforms.length;
                            for (i = 0; i < len; i += 1) ptNew = transforms[i].mat.applyToPointArray(0, 0, 0), pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
                            return pt
                        },
                        mHelper: new Matrix
                    }, MaskElement.prototype.getMaskProperty = function(pos) {
                        return this.viewData[pos].prop
                    }, MaskElement.prototype.renderFrame = function(isFirstFrame) {
                        var i, finalMat = this.element.finalTransform.mat,
                            len = this.masksProperties.length;
                        for (i = 0; i < len; i += 1)
                            if ((this.viewData[i].prop._mdf || isFirstFrame) && this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]), (this.viewData[i].op._mdf || isFirstFrame) && this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v), "n" !== this.masksProperties[i].mode && (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame) && this.viewData[i].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS()), this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame))) {
                                var feMorph = this.storedData[i].expan;
                                this.storedData[i].x.v < 0 ? ("erode" !== this.storedData[i].lastOperator && (this.storedData[i].lastOperator = "erode", this.storedData[i].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i].filterId + ")")), feMorph.setAttribute("radius", -this.storedData[i].x.v)) : ("dilate" !== this.storedData[i].lastOperator && (this.storedData[i].lastOperator = "dilate", this.storedData[i].elem.setAttribute("filter", null)), this.storedData[i].elem.setAttribute("stroke-width", 2 * this.storedData[i].x.v))
                            }
                    }, MaskElement.prototype.getMaskelement = function() {
                        return this.maskElement
                    }, MaskElement.prototype.createLayerSolidPath = function() {
                        var path = "M0,0 ";
                        return path += " h" + this.globalData.compSize.w, path += " v" + this.globalData.compSize.h, path += " h-" + this.globalData.compSize.w, path += " v-" + this.globalData.compSize.h + " "
                    }, MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
                        var i, len, pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
                        for (len = pathNodes._length, i = 1; i < len; i += 1) pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + "," + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + "," + pathNodes.v[i][1];
                        if (pathNodes.c && len > 1 && (pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1]), viewData.lastPath !== pathString) {
                            var pathShapeValue = "";
                            viewData.elem && (pathNodes.c && (pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString), viewData.elem.setAttribute("d", pathShapeValue)), viewData.lastPath = pathString
                        }
                    }, MaskElement.prototype.destroy = function() {
                        this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
                    };
                    var filtersFactory = function() {
                            var ob = {
                                createFilter: function createFilter(filId, skipCoordinates) {
                                    var fil = createNS("filter");
                                    return fil.setAttribute("id", filId), !0 !== skipCoordinates && (fil.setAttribute("filterUnits", "objectBoundingBox"), fil.setAttribute("x", "0%"), fil.setAttribute("y", "0%"), fil.setAttribute("width", "100%"), fil.setAttribute("height", "100%")), fil
                                },
                                createAlphaToLuminanceFilter: function createAlphaToLuminanceFilter() {
                                    var feColorMatrix = createNS("feColorMatrix");
                                    return feColorMatrix.setAttribute("type", "matrix"), feColorMatrix.setAttribute("color-interpolation-filters", "sRGB"), feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), feColorMatrix
                                }
                            };
                            return ob
                        }(),
                        featureSupport = function() {
                            var ob = {
                                maskType: !0,
                                svgLumaHidden: !0,
                                offscreenCanvas: "undefined" != typeof OffscreenCanvas
                            };
                            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (ob.maskType = !1), /firefox/i.test(navigator.userAgent) && (ob.svgLumaHidden = !1), ob
                        }(),
                        registeredEffects$1 = {},
                        idPrefix = "filter_result_";

                    function SVGEffects(elem) {
                        var i, filterManager, source = "SourceGraphic",
                            len = elem.data.ef ? elem.data.ef.length : 0,
                            filId = createElementID(),
                            fil = filtersFactory.createFilter(filId, !0),
                            count = 0;
                        for (this.filters = [], i = 0; i < len; i += 1) {
                            filterManager = null;
                            var type = elem.data.ef[i].ty;
                            registeredEffects$1[type] && (filterManager = new(0, registeredEffects$1[type].effect)(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source), source = idPrefix + count, registeredEffects$1[type].countsAsEffect && (count += 1)), filterManager && this.filters.push(filterManager)
                        }
                        count && (elem.globalData.defs.appendChild(fil), elem.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")")), this.filters.length && elem.addRenderableComponent(this)
                    }

                    function registerEffect$1(id, effect, countsAsEffect) {
                        registeredEffects$1[id] = {
                            effect: effect,
                            countsAsEffect: countsAsEffect
                        }
                    }

                    function SVGBaseElement() {}

                    function HierarchyElement() {}

                    function RenderableDOMElement() {}

                    function IImageElement(data, globalData, comp) {
                        this.assetData = globalData.getAssetData(data.refId), this.assetData && this.assetData.sid && (this.assetData = globalData.slotManager.getProp(this.assetData)), this.initElement(data, globalData, comp), this.sourceRect = {
                            top: 0,
                            left: 0,
                            width: this.assetData.w,
                            height: this.assetData.h
                        }
                    }

                    function ProcessedElement(element, position) {
                        this.elem = element, this.pos = position
                    }

                    function IShapeElement() {}
                    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
                        var i, len = this.filters.length;
                        for (i = 0; i < len; i += 1) this.filters[i].renderFrame(_isFirstFrame)
                    }, SVGEffects.prototype.getEffects = function(type) {
                        var i, len = this.filters.length,
                            effects = [];
                        for (i = 0; i < len; i += 1) this.filters[i].type === type && effects.push(this.filters[i]);
                        return effects
                    }, SVGBaseElement.prototype = {
                        initRendererElement: function initRendererElement() {
                            this.layerElement = createNS("g")
                        },
                        createContainerElements: function createContainerElements() {
                            this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                            var layerElementParent = null;
                            if (this.data.td) {
                                this.matteMasks = {};
                                var gg = createNS("g");
                                gg.setAttribute("id", this.layerId), gg.appendChild(this.layerElement), layerElementParent = gg, this.globalData.defs.appendChild(gg)
                            } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), layerElementParent = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                            if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) {
                                var cp = createNS("clipPath"),
                                    pt = createNS("path");
                                pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                                var clipId = createElementID();
                                if (cp.setAttribute("id", clipId), cp.appendChild(pt), this.globalData.defs.appendChild(cp), this.checkMasks()) {
                                    var cpGroup = createNS("g");
                                    cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")"), cpGroup.appendChild(this.layerElement), this.transformedElement = cpGroup, layerElementParent ? layerElementParent.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                                } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")")
                            }
                            0 !== this.data.bm && this.setBlendMode()
                        },
                        renderElement: function renderElement() {
                            this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
                        },
                        destroyBaseElement: function destroyBaseElement() {
                            this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                        },
                        getBaseElement: function getBaseElement() {
                            return this.data.hd ? null : this.baseElement
                        },
                        createRenderableComponents: function createRenderableComponents() {
                            this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms()
                        },
                        getMatte: function getMatte(matteType) {
                            if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[matteType]) {
                                var filId, fil, useElement, gg, id = this.layerId + "_" + matteType;
                                if (1 === matteType || 3 === matteType) {
                                    var masker = createNS("mask");
                                    masker.setAttribute("id", id), masker.setAttribute("mask-type", 3 === matteType ? "luminance" : "alpha"), (useElement = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), masker.appendChild(useElement), this.globalData.defs.appendChild(masker), featureSupport.maskType || 1 !== matteType || (masker.setAttribute("mask-type", "luminance"), filId = createElementID(), fil = filtersFactory.createFilter(filId), this.globalData.defs.appendChild(fil), fil.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (gg = createNS("g")).appendChild(useElement), masker.appendChild(gg), gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")"))
                                } else if (2 === matteType) {
                                    var maskGroup = createNS("mask");
                                    maskGroup.setAttribute("id", id), maskGroup.setAttribute("mask-type", "alpha");
                                    var maskGrouper = createNS("g");
                                    maskGroup.appendChild(maskGrouper), filId = createElementID(), fil = filtersFactory.createFilter(filId);
                                    var feCTr = createNS("feComponentTransfer");
                                    feCTr.setAttribute("in", "SourceGraphic"), fil.appendChild(feCTr);
                                    var feFunc = createNS("feFuncA");
                                    feFunc.setAttribute("type", "table"), feFunc.setAttribute("tableValues", "1.0 0.0"), feCTr.appendChild(feFunc), this.globalData.defs.appendChild(fil);
                                    var alphaRect = createNS("rect");
                                    alphaRect.setAttribute("width", this.comp.data.w), alphaRect.setAttribute("height", this.comp.data.h), alphaRect.setAttribute("x", "0"), alphaRect.setAttribute("y", "0"), alphaRect.setAttribute("fill", "#ffffff"), alphaRect.setAttribute("opacity", "0"), maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")"), maskGrouper.appendChild(alphaRect), (useElement = createNS("use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), maskGrouper.appendChild(useElement), featureSupport.maskType || (maskGroup.setAttribute("mask-type", "luminance"), fil.appendChild(filtersFactory.createAlphaToLuminanceFilter()), gg = createNS("g"), maskGrouper.appendChild(alphaRect), gg.appendChild(this.layerElement), maskGrouper.appendChild(gg)), this.globalData.defs.appendChild(maskGroup)
                                }
                                this.matteMasks[matteType] = id
                            }
                            return this.matteMasks[matteType]
                        },
                        setMatte: function setMatte(id) {
                            this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")")
                        }
                    }, HierarchyElement.prototype = {
                        initHierarchy: function initHierarchy() {
                            this.hierarchy = [], this._isParent = !1, this.checkParenting()
                        },
                        setHierarchy: function setHierarchy(hierarchy) {
                            this.hierarchy = hierarchy
                        },
                        setAsParent: function setAsParent() {
                            this._isParent = !0
                        },
                        checkParenting: function checkParenting() {
                            void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
                        }
                    }, extendPrototype([RenderableElement, createProxyFunction({
                        initElement: function initElement(data, globalData, comp) {
                            this.initFrame(), this.initBaseData(data, globalData, comp), this.initTransform(data, globalData, comp), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                        },
                        hide: function hide() {
                            this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
                        },
                        show: function show() {
                            this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
                        },
                        renderFrame: function renderFrame() {
                            this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                        },
                        renderInnerContent: function renderInnerContent() {},
                        prepareFrame: function prepareFrame(num) {
                            this._mdf = !1, this.prepareRenderableFrame(num), this.prepareProperties(num, this.isInRange), this.checkTransparency()
                        },
                        destroy: function destroy() {
                            this.innerElem = null, this.destroyBaseElement()
                        }
                    })], RenderableDOMElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
                        var assetPath = this.globalData.getAssetsPath(this.assetData);
                        this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath), this.layerElement.appendChild(this.innerElem)
                    }, IImageElement.prototype.sourceRectAtTime = function() {
                        return this.sourceRect
                    }, IShapeElement.prototype = {
                        addShapeToModifiers: function addShapeToModifiers(data) {
                            var i, len = this.shapeModifiers.length;
                            for (i = 0; i < len; i += 1) this.shapeModifiers[i].addShape(data)
                        },
                        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
                            for (var len = this.shapeModifiers.length; 0 < len;)
                                if (this.shapeModifiers[0].isAnimatedWithShape(data)) return !0;
                            return !1
                        },
                        renderModifiers: function renderModifiers() {
                            if (this.shapeModifiers.length) {
                                var i, len = this.shapes.length;
                                for (i = 0; i < len; i += 1) this.shapes[i].sh.reset();
                                for (i = (len = this.shapeModifiers.length) - 1; i >= 0 && !this.shapeModifiers[i].processShapes(this._isFirstFrame); i -= 1);
                            }
                        },
                        searchProcessedElement: function searchProcessedElement(elem) {
                            for (var elements = this.processedElements, i = 0, len = elements.length; i < len;) {
                                if (elements[i].elem === elem) return elements[i].pos;
                                i += 1
                            }
                            return 0
                        },
                        addProcessedElement: function addProcessedElement(elem, pos) {
                            for (var elements = this.processedElements, i = elements.length; i;)
                                if (elements[i -= 1].elem === elem) return void(elements[i].pos = pos);
                            elements.push(new ProcessedElement(elem, pos))
                        },
                        prepareFrame: function prepareFrame(num) {
                            this.prepareRenderableFrame(num), this.prepareProperties(num, this.isInRange)
                        }
                    };
                    var lineCapEnum = {
                            1: "butt",
                            2: "round",
                            3: "square"
                        },
                        lineJoinEnum = {
                            1: "miter",
                            2: "round",
                            3: "bevel"
                        };

                    function SVGShapeData(transformers, level, shape) {
                        this.caches = [], this.styles = [], this.transformers = transformers, this.lStr = "", this.sh = shape, this.lvl = level, this._isAnimated = !!shape.k;
                        for (var i = 0, len = transformers.length; i < len;) {
                            if (transformers[i].mProps.dynamicProperties.length) {
                                this._isAnimated = !0;
                                break
                            }
                            i += 1
                        }
                    }

                    function SVGStyleData(data, level) {
                        this.data = data, this.type = data.ty, this.d = "", this.lvl = level, this._mdf = !1, this.closed = !0 === data.hd, this.pElem = createNS("path"), this.msElem = null
                    }

                    function DashProperty(elem, data, renderer, container) {
                        var i;
                        this.elem = elem, this.frameId = -1, this.dataProps = createSizedArray(data.length), this.renderer = renderer, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(container);
                        var prop, len = data.length || 0;
                        for (i = 0; i < len; i += 1) prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this), this.k = prop.k || this.k, this.dataProps[i] = {
                            n: data[i].n,
                            p: prop
                        };
                        this.k || this.getValue(!0), this._isAnimated = this.k
                    }

                    function SVGStrokeStyleData(elem, data, styleOb) {
                        this.initDynamicPropertyContainer(elem), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this), this.w = PropertyFactory.getProp(elem, data.w, 0, null, this), this.d = new DashProperty(elem, data.d || {}, "svg", this), this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this), this.style = styleOb, this._isAnimated = !!this._isAnimated
                    }

                    function SVGFillStyleData(elem, data, styleOb) {
                        this.initDynamicPropertyContainer(elem), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this), this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this), this.style = styleOb
                    }

                    function SVGNoStyleData(elem, data, styleOb) {
                        this.initDynamicPropertyContainer(elem), this.getValue = this.iterateDynamicProperties, this.style = styleOb
                    }

                    function GradientProperty(elem, data, container) {
                        this.data = data, this.c = createTypedArray("uint8c", 4 * data.p);
                        var cLength = data.k.k[0].s ? data.k.k[0].s.length - 4 * data.p : data.k.k.length - 4 * data.p;
                        this.o = createTypedArray("float32", cLength), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = cLength, this.initDynamicPropertyContainer(container), this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
                    }

                    function SVGGradientFillStyleData(elem, data, styleOb) {
                        this.initDynamicPropertyContainer(elem), this.getValue = this.iterateDynamicProperties, this.initGradientData(elem, data, styleOb)
                    }

                    function SVGGradientStrokeStyleData(elem, data, styleOb) {
                        this.initDynamicPropertyContainer(elem), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(elem, data.w, 0, null, this), this.d = new DashProperty(elem, data.d || {}, "svg", this), this.initGradientData(elem, data, styleOb), this._isAnimated = !!this._isAnimated
                    }

                    function ShapeGroupData() {
                        this.it = [], this.prevViewData = [], this.gr = createNS("g")
                    }

                    function SVGTransformData(mProps, op, container) {
                        this.transform = {
                            mProps: mProps,
                            op: op,
                            container: container
                        }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
                    }
                    SVGShapeData.prototype.setAsAnimated = function() {
                        this._isAnimated = !0
                    }, SVGStyleData.prototype.reset = function() {
                        this.d = "", this._mdf = !1
                    }, DashProperty.prototype.getValue = function(forceRender) {
                        if ((this.elem.globalData.frameId !== this.frameId || forceRender) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || forceRender, this._mdf)) {
                            var i = 0,
                                len = this.dataProps.length;
                            for ("svg" === this.renderer && (this.dashStr = ""), i = 0; i < len; i += 1) "o" !== this.dataProps[i].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[i].p.v : this.dashArray[i] = this.dataProps[i].p.v : this.dashoffset[0] = this.dataProps[i].p.v
                        }
                    }, extendPrototype([DynamicPropertyContainer], DashProperty), extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), extendPrototype([DynamicPropertyContainer], SVGNoStyleData), GradientProperty.prototype.comparePoints = function(values, points) {
                        for (var i = 0, len = this.o.length / 2; i < len;) {
                            if (Math.abs(values[4 * i] - values[4 * points + 2 * i]) > .01) return !1;
                            i += 1
                        }
                        return !0
                    }, GradientProperty.prototype.checkCollapsable = function() {
                        if (this.o.length / 2 != this.c.length / 4) return !1;
                        if (this.data.k.k[0].s)
                            for (var i = 0, len = this.data.k.k.length; i < len;) {
                                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) return !1;
                                i += 1
                            } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                        return !0
                    }, GradientProperty.prototype.getValue = function(forceRender) {
                        if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || forceRender) {
                            var i, mult, val, len = 4 * this.data.p;
                            for (i = 0; i < len; i += 1) mult = i % 4 == 0 ? 100 : 255, val = Math.round(this.prop.v[i] * mult), this.c[i] !== val && (this.c[i] = val, this._cmdf = !forceRender);
                            if (this.o.length)
                                for (len = this.prop.v.length, i = 4 * this.data.p; i < len; i += 1) mult = i % 2 == 0 ? 100 : 1, val = i % 2 == 0 ? Math.round(100 * this.prop.v[i]) : this.prop.v[i], this.o[i - 4 * this.data.p] !== val && (this.o[i - 4 * this.data.p] = val, this._omdf = !forceRender);
                            this._mdf = !forceRender
                        }
                    }, extendPrototype([DynamicPropertyContainer], GradientProperty), SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {
                        this.o = PropertyFactory.getProp(elem, data.o, 0, .01, this), this.s = PropertyFactory.getProp(elem, data.s, 1, null, this), this.e = PropertyFactory.getProp(elem, data.e, 1, null, this), this.h = PropertyFactory.getProp(elem, data.h || {
                            k: 0
                        }, 0, .01, this), this.a = PropertyFactory.getProp(elem, data.a || {
                            k: 0
                        }, 0, degToRads, this), this.g = new GradientProperty(elem, data.g, this), this.style = styleOb, this.stops = [], this.setGradientData(styleOb.pElem, data), this.setGradientOpacity(data, styleOb), this._isAnimated = !!this._isAnimated
                    }, SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {
                        var gradientId = createElementID(),
                            gfill = createNS(1 === data.t ? "linearGradient" : "radialGradient");
                        gfill.setAttribute("id", gradientId), gfill.setAttribute("spreadMethod", "pad"), gfill.setAttribute("gradientUnits", "userSpaceOnUse");
                        var stop, j, jLen, stops = [];
                        for (jLen = 4 * data.g.p, j = 0; j < jLen; j += 4) stop = createNS("stop"), gfill.appendChild(stop), stops.push(stop);
                        pathElement.setAttribute("gf" === data.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")"), this.gf = gfill, this.cst = stops
                    }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {
                        if (this.g._hasOpacity && !this.g._collapsable) {
                            var stop, j, jLen, mask = createNS("mask"),
                                maskElement = createNS("path");
                            mask.appendChild(maskElement);
                            var opacityId = createElementID(),
                                maskId = createElementID();
                            mask.setAttribute("id", maskId);
                            var opFill = createNS(1 === data.t ? "linearGradient" : "radialGradient");
                            opFill.setAttribute("id", opacityId), opFill.setAttribute("spreadMethod", "pad"), opFill.setAttribute("gradientUnits", "userSpaceOnUse"), jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
                            var stops = this.stops;
                            for (j = 4 * data.g.p; j < jLen; j += 2)(stop = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), opFill.appendChild(stop), stops.push(stop);
                            maskElement.setAttribute("gf" === data.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")"), "gs" === data.ty && (maskElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]), maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]), 1 === data.lj && maskElement.setAttribute("stroke-miterlimit", data.ml)), this.of = opFill, this.ms = mask, this.ost = stops, this.maskId = maskId, styleOb.msElem = maskElement
                        }
                    }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
                    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
                            if (0 === length) return "";
                            var i, _o = pathNodes.o,
                                _i = pathNodes.i,
                                _v = pathNodes.v,
                                shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
                            for (i = 1; i < length; i += 1) shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
                            return closed && length && (shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]), shapeString += "z"), shapeString
                        },
                        SVGElementsRenderer = function() {
                            var _identityMatrix = new Matrix,
                                _matrixHelper = new Matrix;

                            function renderContentTransform(styleData, itemData, isFirstFrame) {
                                (isFirstFrame || itemData.transform.op._mdf) && itemData.transform.container.setAttribute("opacity", itemData.transform.op.v), (isFirstFrame || itemData.transform.mProps._mdf) && itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS())
                            }

                            function renderNoop() {}

                            function renderPath(styleData, itemData, isFirstFrame) {
                                var j, jLen, pathStringTransformed, redraw, pathNodes, l, paths, mat, iterations, k, lLen = itemData.styles.length,
                                    lvl = itemData.lvl;
                                for (l = 0; l < lLen; l += 1) {
                                    if (redraw = itemData.sh._mdf || isFirstFrame, itemData.styles[l].lvl < lvl) {
                                        for (mat = _matrixHelper.reset(), iterations = lvl - itemData.styles[l].lvl, k = itemData.transformers.length - 1; !redraw && iterations > 0;) redraw = itemData.transformers[k].mProps._mdf || redraw, iterations -= 1, k -= 1;
                                        if (redraw)
                                            for (iterations = lvl - itemData.styles[l].lvl, k = itemData.transformers.length - 1; iterations > 0;) mat.multiply(itemData.transformers[k].mProps.v), iterations -= 1, k -= 1
                                    } else mat = _identityMatrix;
                                    if (jLen = (paths = itemData.sh.paths)._length, redraw) {
                                        for (pathStringTransformed = "", j = 0; j < jLen; j += 1)(pathNodes = paths.shapes[j]) && pathNodes._length && (pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat));
                                        itemData.caches[l] = pathStringTransformed
                                    } else pathStringTransformed = itemData.caches[l];
                                    itemData.styles[l].d += !0 === styleData.hd ? "" : pathStringTransformed, itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf
                                }
                            }

                            function renderFill(styleData, itemData, isFirstFrame) {
                                var styleElem = itemData.style;
                                (itemData.c._mdf || isFirstFrame) && styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")"), (itemData.o._mdf || isFirstFrame) && styleElem.pElem.setAttribute("fill-opacity", itemData.o.v)
                            }

                            function renderGradientStroke(styleData, itemData, isFirstFrame) {
                                renderGradient(styleData, itemData, isFirstFrame), renderStroke(0, itemData, isFirstFrame)
                            }

                            function renderGradient(styleData, itemData, isFirstFrame) {
                                var stops, i, len, stop, rad, gfill = itemData.gf,
                                    hasOpacity = itemData.g._hasOpacity,
                                    pt1 = itemData.s.v,
                                    pt2 = itemData.e.v;
                                if (itemData.o._mdf || isFirstFrame) {
                                    var attr = "gf" === styleData.ty ? "fill-opacity" : "stroke-opacity";
                                    itemData.style.pElem.setAttribute(attr, itemData.o.v)
                                }
                                if (itemData.s._mdf || isFirstFrame) {
                                    var attr1 = 1 === styleData.t ? "x1" : "cx",
                                        attr2 = "x1" === attr1 ? "y1" : "cy";
                                    gfill.setAttribute(attr1, pt1[0]), gfill.setAttribute(attr2, pt1[1]), hasOpacity && !itemData.g._collapsable && (itemData.of.setAttribute(attr1, pt1[0]), itemData.of.setAttribute(attr2, pt1[1]))
                                }
                                if (itemData.g._cmdf || isFirstFrame) {
                                    stops = itemData.cst;
                                    var cValues = itemData.g.c;
                                    for (len = stops.length, i = 0; i < len; i += 1)(stop = stops[i]).setAttribute("offset", cValues[4 * i] + "%"), stop.setAttribute("stop-color", "rgb(" + cValues[4 * i + 1] + "," + cValues[4 * i + 2] + "," + cValues[4 * i + 3] + ")")
                                }
                                if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                                    var oValues = itemData.g.o;
                                    for (len = (stops = itemData.g._collapsable ? itemData.cst : itemData.ost).length, i = 0; i < len; i += 1) stop = stops[i], itemData.g._collapsable || stop.setAttribute("offset", oValues[2 * i] + "%"), stop.setAttribute("stop-opacity", oValues[2 * i + 1])
                                }
                                if (1 === styleData.t)(itemData.e._mdf || isFirstFrame) && (gfill.setAttribute("x2", pt2[0]), gfill.setAttribute("y2", pt2[1]), hasOpacity && !itemData.g._collapsable && (itemData.of.setAttribute("x2", pt2[0]), itemData.of.setAttribute("y2", pt2[1])));
                                else if ((itemData.s._mdf || itemData.e._mdf || isFirstFrame) && (rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)), gfill.setAttribute("r", rad), hasOpacity && !itemData.g._collapsable && itemData.of.setAttribute("r", rad)), itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                                    rad || (rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)));
                                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]),
                                        percent = itemData.h.v;
                                    percent >= 1 ? percent = .99 : percent <= -1 && (percent = -.99);
                                    var dist = rad * percent,
                                        x = Math.cos(ang + itemData.a.v) * dist + pt1[0],
                                        y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                                    gfill.setAttribute("fx", x), gfill.setAttribute("fy", y), hasOpacity && !itemData.g._collapsable && (itemData.of.setAttribute("fx", x), itemData.of.setAttribute("fy", y))
                                }
                            }

                            function renderStroke(styleData, itemData, isFirstFrame) {
                                var styleElem = itemData.style,
                                    d = itemData.d;
                                d && (d._mdf || isFirstFrame) && d.dashStr && (styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr), styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0])), itemData.c && (itemData.c._mdf || isFirstFrame) && styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")"), (itemData.o._mdf || isFirstFrame) && styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v), (itemData.w._mdf || isFirstFrame) && (styleElem.pElem.setAttribute("stroke-width", itemData.w.v), styleElem.msElem && styleElem.msElem.setAttribute("stroke-width", itemData.w.v))
                            }
                            return {
                                createRenderFunction: function createRenderFunction(data) {
                                    switch (data.ty) {
                                        case "fl":
                                            return renderFill;
                                        case "gf":
                                            return renderGradient;
                                        case "gs":
                                            return renderGradientStroke;
                                        case "st":
                                            return renderStroke;
                                        case "sh":
                                        case "el":
                                        case "rc":
                                        case "sr":
                                            return renderPath;
                                        case "tr":
                                            return renderContentTransform;
                                        case "no":
                                            return renderNoop;
                                        default:
                                            return null
                                    }
                                }
                            }
                        }();

                    function SVGShapeElement(data, globalData, comp) {
                        this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(data, globalData, comp), this.prevViewData = []
                    }

                    function LetterProps(o, sw, sc, fc, m, p) {
                        this.o = o, this.sw = sw, this.sc = sc, this.fc = fc, this.m = m, this.p = p, this._mdf = {
                            o: !0,
                            sw: !!sw,
                            sc: !!sc,
                            fc: !!fc,
                            m: !0,
                            p: !0
                        }
                    }

                    function TextProperty(elem, data) {
                        this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, data.d && data.d.sid && (data.d = elem.globalData.slotManager.getProp(data.d)), this.data = data, this.elem = elem, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                            ascent: 0,
                            boxWidth: this.defaultBoxWidth,
                            f: "",
                            fStyle: "",
                            fWeight: "",
                            fc: "",
                            j: "",
                            justifyOffset: "",
                            l: [],
                            lh: 0,
                            lineWidths: [],
                            ls: "",
                            of: "",
                            s: "",
                            sc: "",
                            sw: 0,
                            t: 0,
                            tr: 0,
                            sz: 0,
                            ps: null,
                            fillColorAnim: !1,
                            strokeColorAnim: !1,
                            strokeWidthAnim: !1,
                            yOffset: 0,
                            finalSize: 0,
                            finalText: [],
                            finalLineHeight: 0,
                            __complete: !1
                        }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
                    }
                    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function() {}, SVGShapeElement.prototype.createContent = function() {
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
                    }, SVGShapeElement.prototype.filterUniqueShapes = function() {
                        var i, shape, j, style, len = this.shapes.length,
                            jLen = this.stylesList.length,
                            tempShapes = [],
                            areAnimated = !1;
                        for (j = 0; j < jLen; j += 1) {
                            for (style = this.stylesList[j], areAnimated = !1, tempShapes.length = 0, i = 0; i < len; i += 1) - 1 !== (shape = this.shapes[i]).styles.indexOf(style) && (tempShapes.push(shape), areAnimated = shape._isAnimated || areAnimated);
                            tempShapes.length > 1 && areAnimated && this.setShapesAsAnimated(tempShapes)
                        }
                    }, SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
                        var i, len = shapes.length;
                        for (i = 0; i < len; i += 1) shapes[i].setAsAnimated()
                    }, SVGShapeElement.prototype.createStyleElement = function(data, level) {
                        var elementData, styleOb = new SVGStyleData(data, level),
                            pathElement = styleOb.pElem;
                        return "st" === data.ty ? elementData = new SVGStrokeStyleData(this, data, styleOb) : "fl" === data.ty ? elementData = new SVGFillStyleData(this, data, styleOb) : "gf" === data.ty || "gs" === data.ty ? (elementData = new("gf" === data.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, data, styleOb), this.globalData.defs.appendChild(elementData.gf), elementData.maskId && (this.globalData.defs.appendChild(elementData.ms), this.globalData.defs.appendChild(elementData.of), pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")"))) : "no" === data.ty && (elementData = new SVGNoStyleData(this, data, styleOb)), "st" !== data.ty && "gs" !== data.ty || (pathElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]), pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]), pathElement.setAttribute("fill-opacity", "0"), 1 === data.lj && pathElement.setAttribute("stroke-miterlimit", data.ml)), 2 === data.r && pathElement.setAttribute("fill-rule", "evenodd"), data.ln && pathElement.setAttribute("id", data.ln), data.cl && pathElement.setAttribute("class", data.cl), data.bm && (pathElement.style["mix-blend-mode"] = getBlendMode(data.bm)), this.stylesList.push(styleOb), this.addToAnimatedContents(data, elementData), elementData
                    }, SVGShapeElement.prototype.createGroupElement = function(data) {
                        var elementData = new ShapeGroupData;
                        return data.ln && elementData.gr.setAttribute("id", data.ln), data.cl && elementData.gr.setAttribute("class", data.cl), data.bm && (elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm)), elementData
                    }, SVGShapeElement.prototype.createTransformElement = function(data, container) {
                        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this),
                            elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
                        return this.addToAnimatedContents(data, elementData), elementData
                    }, SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
                        var ty = 4;
                        "rc" === data.ty ? ty = 5 : "el" === data.ty ? ty = 6 : "sr" === data.ty && (ty = 7);
                        var elementData = new SVGShapeData(ownTransformers, level, ShapePropertyFactory.getShapeProp(this, data, ty, this));
                        return this.shapes.push(elementData), this.addShapeToModifiers(elementData), this.addToAnimatedContents(data, elementData), elementData
                    }, SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
                        for (var i = 0, len = this.animatedContents.length; i < len;) {
                            if (this.animatedContents[i].element === element) return;
                            i += 1
                        }
                        this.animatedContents.push({
                            fn: SVGElementsRenderer.createRenderFunction(data),
                            element: element,
                            data: data
                        })
                    }, SVGShapeElement.prototype.setElementStyles = function(elementData) {
                        var j, arr = elementData.styles,
                            jLen = this.stylesList.length;
                        for (j = 0; j < jLen; j += 1) this.stylesList[j].closed || arr.push(this.stylesList[j])
                    }, SVGShapeElement.prototype.reloadShapes = function() {
                        var i;
                        this._isFirstFrame = !0;
                        var len = this.itemsData.length;
                        for (i = 0; i < len; i += 1) this.prevViewData[i] = this.itemsData[i];
                        for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), len = this.dynamicProperties.length, i = 0; i < len; i += 1) this.dynamicProperties[i].getValue();
                        this.renderModifiers()
                    }, SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
                        var i, j, jLen, currentTransform, modifier, processedPos, ownTransformers = [].concat(transformers),
                            len = arr.length - 1,
                            ownStyles = [],
                            ownModifiers = [];
                        for (i = len; i >= 0; i -= 1) {
                            if ((processedPos = this.searchProcessedElement(arr[i])) ? itemsData[i] = prevViewData[processedPos - 1] : arr[i]._render = render, "fl" === arr[i].ty || "st" === arr[i].ty || "gf" === arr[i].ty || "gs" === arr[i].ty || "no" === arr[i].ty) processedPos ? itemsData[i].style.closed = !1 : itemsData[i] = this.createStyleElement(arr[i], level), arr[i]._render && itemsData[i].style.pElem.parentNode !== container && container.appendChild(itemsData[i].style.pElem), ownStyles.push(itemsData[i].style);
                            else if ("gr" === arr[i].ty) {
                                if (processedPos)
                                    for (jLen = itemsData[i].it.length, j = 0; j < jLen; j += 1) itemsData[i].prevViewData[j] = itemsData[i].it[j];
                                else itemsData[i] = this.createGroupElement(arr[i]);
                                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render), arr[i]._render && itemsData[i].gr.parentNode !== container && container.appendChild(itemsData[i].gr)
                            } else "tr" === arr[i].ty ? (processedPos || (itemsData[i] = this.createTransformElement(arr[i], container)), currentTransform = itemsData[i].transform, ownTransformers.push(currentTransform)) : "sh" === arr[i].ty || "rc" === arr[i].ty || "el" === arr[i].ty || "sr" === arr[i].ty ? (processedPos || (itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level)), this.setElementStyles(itemsData[i])) : "tm" === arr[i].ty || "rd" === arr[i].ty || "ms" === arr[i].ty || "pb" === arr[i].ty || "zz" === arr[i].ty || "op" === arr[i].ty ? (processedPos ? (modifier = itemsData[i]).closed = !1 : ((modifier = ShapeModifiers.getModifier(arr[i].ty)).init(this, arr[i]), itemsData[i] = modifier, this.shapeModifiers.push(modifier)), ownModifiers.push(modifier)) : "rp" === arr[i].ty && (processedPos ? (modifier = itemsData[i]).closed = !0 : (modifier = ShapeModifiers.getModifier(arr[i].ty), itemsData[i] = modifier, modifier.init(this, arr, i, itemsData), this.shapeModifiers.push(modifier), render = !1), ownModifiers.push(modifier));
                            this.addProcessedElement(arr[i], i + 1)
                        }
                        for (len = ownStyles.length, i = 0; i < len; i += 1) ownStyles[i].closed = !0;
                        for (len = ownModifiers.length, i = 0; i < len; i += 1) ownModifiers[i].closed = !0
                    }, SVGShapeElement.prototype.renderInnerContent = function() {
                        var i;
                        this.renderModifiers();
                        var len = this.stylesList.length;
                        for (i = 0; i < len; i += 1) this.stylesList[i].reset();
                        for (this.renderShape(), i = 0; i < len; i += 1)(this.stylesList[i]._mdf || this._isFirstFrame) && (this.stylesList[i].msElem && (this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d), this.stylesList[i].d = "M0 0" + this.stylesList[i].d), this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0"))
                    }, SVGShapeElement.prototype.renderShape = function() {
                        var i, animatedContent, len = this.animatedContents.length;
                        for (i = 0; i < len; i += 1) animatedContent = this.animatedContents[i], (this._isFirstFrame || animatedContent.element._isAnimated) && !0 !== animatedContent.data && animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame)
                    }, SVGShapeElement.prototype.destroy = function() {
                        this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
                    }, LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
                        this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
                        var updated = !1;
                        return this.o !== o && (this.o = o, this._mdf.o = !0, updated = !0), this.sw !== sw && (this.sw = sw, this._mdf.sw = !0, updated = !0), this.sc !== sc && (this.sc = sc, this._mdf.sc = !0, updated = !0), this.fc !== fc && (this.fc = fc, this._mdf.fc = !0, updated = !0), this.m !== m && (this.m = m, this._mdf.m = !0, updated = !0), !p.length || this.p[0] === p[0] && this.p[1] === p[1] && this.p[4] === p[4] && this.p[5] === p[5] && this.p[12] === p[12] && this.p[13] === p[13] || (this.p = p, this._mdf.p = !0, updated = !0), updated
                    }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(obj, data) {
                        for (var s in data) Object.prototype.hasOwnProperty.call(data, s) && (obj[s] = data[s]);
                        return obj
                    }, TextProperty.prototype.setCurrentData = function(data) {
                        data.__complete || this.completeTextData(data), this.currentData = data, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
                    }, TextProperty.prototype.searchProperty = function() {
                        return this.searchKeyframes()
                    }, TextProperty.prototype.searchKeyframes = function() {
                        return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
                    }, TextProperty.prototype.addEffect = function(effectFunction) {
                        this.effectsSequence.push(effectFunction), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.getValue = function(_finalValue) {
                        if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || _finalValue) {
                            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                            var currentValue = this.currentData,
                                currentIndex = this.keysIndex;
                            if (this.lock) this.setCurrentData(this.currentData);
                            else {
                                var i;
                                this.lock = !0, this._mdf = !1;
                                var len = this.effectsSequence.length,
                                    finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
                                for (i = 0; i < len; i += 1) finalValue = currentIndex !== this.keysIndex ? this.effectsSequence[i](finalValue, finalValue.t) : this.effectsSequence[i](this.currentData, finalValue.t);
                                currentValue !== finalValue && this.setCurrentData(finalValue), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
                            }
                        }
                    }, TextProperty.prototype.getKeyframeValue = function() {
                        for (var textKeys = this.data.d.k, frameNum = this.elem.comp.renderedFrame, i = 0, len = textKeys.length; i <= len - 1 && !(i === len - 1 || textKeys[i + 1].t > frameNum);) i += 1;
                        return this.keysIndex !== i && (this.keysIndex = i), this.data.d.k[this.keysIndex].s
                    }, TextProperty.prototype.buildFinalText = function(text) {
                        for (var charCode, secondCharCode, charactersArray = [], i = 0, len = text.length, shouldCombine = !1, shouldCombineNext = !1, currentChars = ""; i < len;) shouldCombine = shouldCombineNext, shouldCombineNext = !1, charCode = text.charCodeAt(i), currentChars = text.charAt(i), FontManager.isCombinedCharacter(charCode) ? shouldCombine = !0 : charCode >= 55296 && charCode <= 56319 ? FontManager.isRegionalFlag(text, i) ? currentChars = text.substr(i, 14) : (secondCharCode = text.charCodeAt(i + 1)) >= 56320 && secondCharCode <= 57343 && (FontManager.isModifier(charCode, secondCharCode) ? (currentChars = text.substr(i, 2), shouldCombine = !0) : currentChars = FontManager.isFlagEmoji(text.substr(i, 4)) ? text.substr(i, 4) : text.substr(i, 2)) : charCode > 56319 ? (secondCharCode = text.charCodeAt(i + 1), FontManager.isVariationSelector(charCode) && (shouldCombine = !0)) : FontManager.isZeroWidthJoiner(charCode) && (shouldCombine = !0, shouldCombineNext = !0), shouldCombine ? (charactersArray[charactersArray.length - 1] += currentChars, shouldCombine = !1) : charactersArray.push(currentChars), i += currentChars.length;
                        return charactersArray
                    }, TextProperty.prototype.completeTextData = function(documentData) {
                        documentData.__complete = !0;
                        var i, len, newLineFlag, val, j, jLen, charData, fontManager = this.elem.globalData.fontManager,
                            data = this.data,
                            letters = [],
                            index = 0,
                            anchorGrouping = data.m.g,
                            currentSize = 0,
                            currentPos = 0,
                            currentLine = 0,
                            lineWidths = [],
                            lineWidth = 0,
                            maxLineWidth = 0,
                            fontData = fontManager.getFontByName(documentData.f),
                            cLength = 0,
                            fontProps = getFontProperties(fontData);
                        documentData.fWeight = fontProps.weight, documentData.fStyle = fontProps.style, documentData.finalSize = documentData.s, documentData.finalText = this.buildFinalText(documentData.t), len = documentData.finalText.length, documentData.finalLineHeight = documentData.lh;
                        var charCode, trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
                        if (documentData.sz)
                            for (var currentHeight, finalText, flag = !0, boxWidth = documentData.sz[0], boxHeight = documentData.sz[1]; flag;) {
                                currentHeight = 0, lineWidth = 0, len = (finalText = this.buildFinalText(documentData.t)).length, trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
                                var lastSpaceIndex = -1;
                                for (i = 0; i < len; i += 1) charCode = finalText[i].charCodeAt(0), newLineFlag = !1, " " === finalText[i] ? lastSpaceIndex = i : 13 !== charCode && 3 !== charCode || (lineWidth = 0, newLineFlag = !0, currentHeight += documentData.finalLineHeight || 1.2 * documentData.finalSize), fontManager.chars ? (charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily), cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100) : cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize), lineWidth + cLength > boxWidth && " " !== finalText[i] ? (-1 === lastSpaceIndex ? len += 1 : i = lastSpaceIndex, currentHeight += documentData.finalLineHeight || 1.2 * documentData.finalSize, finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r"), lastSpaceIndex = -1, lineWidth = 0) : (lineWidth += cLength, lineWidth += trackingOffset);
                                currentHeight += fontData.ascent * documentData.finalSize / 100, this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight ? (documentData.finalSize -= 1, documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s) : (documentData.finalText = finalText, len = documentData.finalText.length, flag = !1)
                            }
                        lineWidth = -trackingOffset, cLength = 0;
                        var currentChar, uncollapsedSpaces = 0;
                        for (i = 0; i < len; i += 1)
                            if (newLineFlag = !1, 13 === (charCode = (currentChar = documentData.finalText[i]).charCodeAt(0)) || 3 === charCode ? (uncollapsedSpaces = 0, lineWidths.push(lineWidth), maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth, lineWidth = -2 * trackingOffset, val = "", newLineFlag = !0, currentLine += 1) : val = currentChar, fontManager.chars ? (charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily), cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100) : cLength = fontManager.measureText(val, documentData.f, documentData.finalSize), " " === currentChar ? uncollapsedSpaces += cLength + trackingOffset : (lineWidth += cLength + trackingOffset + uncollapsedSpaces, uncollapsedSpaces = 0), letters.push({
                                    l: cLength,
                                    an: cLength,
                                    add: currentSize,
                                    n: newLineFlag,
                                    anIndexes: [],
                                    val: val,
                                    line: currentLine,
                                    animatorJustifyOffset: 0
                                }), 2 == anchorGrouping) {
                                if (currentSize += cLength, "" === val || " " === val || i === len - 1) {
                                    for ("" !== val && " " !== val || (currentSize -= cLength); currentPos <= i;) letters[currentPos].an = currentSize, letters[currentPos].ind = index, letters[currentPos].extra = cLength, currentPos += 1;
                                    index += 1, currentSize = 0
                                }
                            } else if (3 == anchorGrouping) {
                            if (currentSize += cLength, "" === val || i === len - 1) {
                                for ("" === val && (currentSize -= cLength); currentPos <= i;) letters[currentPos].an = currentSize, letters[currentPos].ind = index, letters[currentPos].extra = cLength, currentPos += 1;
                                currentSize = 0, index += 1
                            }
                        } else letters[index].ind = index, letters[index].extra = 0, index += 1;
                        if (documentData.l = letters, maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth, lineWidths.push(lineWidth), documentData.sz) documentData.boxWidth = documentData.sz[0], documentData.justifyOffset = 0;
                        else switch (documentData.boxWidth = maxLineWidth, documentData.j) {
                            case 1:
                                documentData.justifyOffset = -documentData.boxWidth;
                                break;
                            case 2:
                                documentData.justifyOffset = -documentData.boxWidth / 2;
                                break;
                            default:
                                documentData.justifyOffset = 0
                        }
                        documentData.lineWidths = lineWidths;
                        var animatorData, letterData, based, ind, animators = data.a;
                        jLen = animators.length;
                        var indexes = [];
                        for (j = 0; j < jLen; j += 1) {
                            for ((animatorData = animators[j]).a.sc && (documentData.strokeColorAnim = !0), animatorData.a.sw && (documentData.strokeWidthAnim = !0), (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) && (documentData.fillColorAnim = !0), ind = 0, based = animatorData.s.b, i = 0; i < len; i += 1)(letterData = letters[i]).anIndexes[j] = ind, (1 == based && "" !== letterData.val || 2 == based && "" !== letterData.val && " " !== letterData.val || 3 == based && (letterData.n || " " == letterData.val || i == len - 1) || 4 == based && (letterData.n || i == len - 1)) && (1 === animatorData.s.rn && indexes.push(ind), ind += 1);
                            data.a[j].s.totalChars = ind;
                            var newInd, currentInd = -1;
                            if (1 === animatorData.s.rn)
                                for (i = 0; i < len; i += 1) currentInd != (letterData = letters[i]).anIndexes[j] && (currentInd = letterData.anIndexes[j], newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0]), letterData.anIndexes[j] = newInd
                        }
                        documentData.yOffset = documentData.finalLineHeight || 1.2 * documentData.finalSize, documentData.ls = documentData.ls || 0, documentData.ascent = fontData.ascent * documentData.finalSize / 100
                    }, TextProperty.prototype.updateDocumentData = function(newData, index) {
                        index = void 0 === index ? this.keysIndex : index;
                        var dData = this.copyData({}, this.data.d.k[index].s);
                        dData = this.copyData(dData, newData), this.data.d.k[index].s = dData, this.recalculate(index), this.setCurrentData(dData), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.recalculate = function(index) {
                        var dData = this.data.d.k[index].s;
                        dData.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(dData)
                    }, TextProperty.prototype.canResizeFont = function(_canResize) {
                        this.canResize = _canResize, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                    }, TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
                        this.minimumFontSize = Math.floor(_fontValue) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                    };
                    var TextSelectorProp = function() {
                        var max = Math.max,
                            min = Math.min,
                            floor = Math.floor;

                        function TextSelectorPropFactory(elem, data) {
                            this._currentTextLength = -1, this.k = !1, this.data = data, this.elem = elem, this.comp = elem.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(elem), this.s = PropertyFactory.getProp(elem, data.s || {
                                k: 0
                            }, 0, 0, this), this.e = "e" in data ? PropertyFactory.getProp(elem, data.e, 0, 0, this) : {
                                v: 100
                            }, this.o = PropertyFactory.getProp(elem, data.o || {
                                k: 0
                            }, 0, 0, this), this.xe = PropertyFactory.getProp(elem, data.xe || {
                                k: 0
                            }, 0, 0, this), this.ne = PropertyFactory.getProp(elem, data.ne || {
                                k: 0
                            }, 0, 0, this), this.sm = PropertyFactory.getProp(elem, data.sm || {
                                k: 100
                            }, 0, 0, this), this.a = PropertyFactory.getProp(elem, data.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                        }
                        return TextSelectorPropFactory.prototype = {
                            getMult: function getMult(ind) {
                                this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                                var x1 = 0,
                                    y1 = 0,
                                    x2 = 1,
                                    y2 = 1;
                                this.ne.v > 0 ? x1 = this.ne.v / 100 : y1 = -this.ne.v / 100, this.xe.v > 0 ? x2 = 1 - this.xe.v / 100 : y2 = 1 + this.xe.v / 100;
                                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get,
                                    mult = 0,
                                    s = this.finalS,
                                    e = this.finalE,
                                    type = this.data.sh;
                                if (2 === type) mult = easer(mult = e === s ? ind >= e ? 1 : 0 : max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1)));
                                else if (3 === type) mult = easer(mult = e === s ? ind >= e ? 0 : 1 : 1 - max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1)));
                                else if (4 === type) e === s ? mult = 0 : (mult = max(0, min(.5 / (e - s) + (ind - s) / (e - s), 1))) < .5 ? mult *= 2 : mult = 1 - 2 * (mult - .5), mult = easer(mult);
                                else if (5 === type) {
                                    if (e === s) mult = 0;
                                    else {
                                        var tot = e - s,
                                            x = -tot / 2 + (ind = min(max(0, ind + .5 - s), e - s)),
                                            a = tot / 2;
                                        mult = Math.sqrt(1 - x * x / (a * a))
                                    }
                                    mult = easer(mult)
                                } else 6 === type ? (e === s ? mult = 0 : (ind = min(max(0, ind + .5 - s), e - s), mult = (1 + Math.cos(Math.PI + 2 * Math.PI * ind / (e - s))) / 2), mult = easer(mult)) : (ind >= floor(s) && (mult = max(0, min(ind - s < 0 ? min(e, 1) - (s - ind) : e - ind, 1))), mult = easer(mult));
                                if (100 !== this.sm.v) {
                                    var smoothness = .01 * this.sm.v;
                                    0 === smoothness && (smoothness = 1e-8);
                                    var threshold = .5 - .5 * smoothness;
                                    mult < threshold ? mult = 0 : (mult = (mult - threshold) / smoothness) > 1 && (mult = 1)
                                }
                                return mult * this.a.v
                            },
                            getValue: function getValue(newCharsFlag) {
                                this.iterateDynamicProperties(), this._mdf = newCharsFlag || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, newCharsFlag && 2 === this.data.r && (this.e.v = this._currentTextLength);
                                var divisor = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                                    o = this.o.v / divisor,
                                    s = this.s.v / divisor + o,
                                    e = this.e.v / divisor + o;
                                if (s > e) {
                                    var _s = s;
                                    s = e, e = _s
                                }
                                this.finalS = s, this.finalE = e
                            }
                        }, extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory), {
                            getTextSelectorProp: function getTextSelectorProp(elem, data, arr) {
                                return new TextSelectorPropFactory(elem, data, arr)
                            }
                        }
                    }();

                    function TextAnimatorDataProperty(elem, animatorProps, container) {
                        var defaultData = {
                                propType: !1
                            },
                            getProp = PropertyFactory.getProp,
                            textAnimatorAnimatables = animatorProps.a;
                        this.a = {
                            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
                            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
                            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
                            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
                            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
                            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, .01, container) : defaultData,
                            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
                            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, .01, container) : defaultData,
                            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
                            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
                            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
                            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
                            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
                            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, .01, container) : defaultData,
                            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, .01, container) : defaultData,
                            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
                        }, this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container), this.s.t = animatorProps.s.t
                    }

                    function TextAnimatorProperty(textData, renderType, elem) {
                        this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = textData, this._renderType = renderType, this._elem = elem, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                            alignment: {}
                        }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(elem)
                    }

                    function ITextElement() {}
                    TextAnimatorProperty.prototype.searchProperties = function() {
                        var i, animatorProps, len = this._textData.a.length,
                            getProp = PropertyFactory.getProp;
                        for (i = 0; i < len; i += 1) animatorProps = this._textData.a[i], this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
                        this._textData.p && "m" in this._textData.p ? (this._pathData = {
                            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                        }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this)
                    }, TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
                        if (this.lettersChangedFlag = lettersChangedFlag, this._mdf || this._isFirstFrame || lettersChangedFlag || this._hasMaskedPath && this._pathData.m._mdf) {
                            this._isFirstFrame = !1;
                            var xPos, yPos, i, len, pathInfo, currentLength, currentPoint, segmentLength, flag, pointInd, segmentInd, prevPoint, points, segments, partialLength, totalLength, perc, tanAngle, mask, alignment = this._moreOptions.alignment.v,
                                animators = this._animatorsData,
                                textData = this._textData,
                                matrixHelper = this.mHelper,
                                renderType = this._renderType,
                                renderedLettersCount = this.renderedLetters.length,
                                letters = documentData.l;
                            if (this._hasMaskedPath) {
                                if (mask = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                                    var bezierData, paths = mask.v;
                                    for (this._pathData.r.v && (paths = paths.reverse()), pathInfo = {
                                            tLength: 0,
                                            segments: []
                                        }, len = paths._length - 1, totalLength = 0, i = 0; i < len; i += 1) bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]), pathInfo.tLength += bezierData.segmentLength, pathInfo.segments.push(bezierData), totalLength += bezierData.segmentLength;
                                    i = len, mask.v.c && (bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]), pathInfo.tLength += bezierData.segmentLength, pathInfo.segments.push(bezierData), totalLength += bezierData.segmentLength), this._pathData.pi = pathInfo
                                }
                                if (pathInfo = this._pathData.pi, currentLength = this._pathData.f.v, segmentInd = 0, pointInd = 1, segmentLength = 0, flag = !0, segments = pathInfo.segments, currentLength < 0 && mask.v.c)
                                    for (pathInfo.tLength < Math.abs(currentLength) && (currentLength = -Math.abs(currentLength) % pathInfo.tLength), pointInd = (points = segments[segmentInd = segments.length - 1].points).length - 1; currentLength < 0;) currentLength += points[pointInd].partialLength, (pointInd -= 1) < 0 && (pointInd = (points = segments[segmentInd -= 1].points).length - 1);
                                prevPoint = (points = segments[segmentInd].points)[pointInd - 1], partialLength = (currentPoint = points[pointInd]).partialLength
                            }
                            len = letters.length, xPos = 0, yPos = 0;
                            var animatorProps, j, jLen, letterValue, mult, yOff = 1.2 * documentData.finalSize * .714,
                                firstLine = !0;
                            jLen = animators.length;
                            var offf, xPathPos, yPathPos, elemOpacity, sc, sw, fc, k, letterSw, letterSc, letterFc, letterO, ind = -1,
                                initPathPos = currentLength,
                                initSegmentInd = segmentInd,
                                initPointInd = pointInd,
                                currentLine = -1,
                                letterM = "",
                                letterP = this.defaultPropsArray;
                            if (2 === documentData.j || 1 === documentData.j) {
                                var animatorJustifyOffset = 0,
                                    animatorFirstCharOffset = 0,
                                    justifyOffsetMult = 2 === documentData.j ? -.5 : -1,
                                    lastIndex = 0,
                                    isNewLine = !0;
                                for (i = 0; i < len; i += 1)
                                    if (letters[i].n) {
                                        for (animatorJustifyOffset && (animatorJustifyOffset += animatorFirstCharOffset); lastIndex < i;) letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset, lastIndex += 1;
                                        animatorJustifyOffset = 0, isNewLine = !0
                                    } else {
                                        for (j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).t.propType && (isNewLine && 2 === documentData.j && (animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult), (mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)).length ? animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult : animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult);
                                        isNewLine = !1
                                    } for (animatorJustifyOffset && (animatorJustifyOffset += animatorFirstCharOffset); lastIndex < i;) letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset, lastIndex += 1
                            }
                            for (i = 0; i < len; i += 1) {
                                if (matrixHelper.reset(), elemOpacity = 1, letters[i].n) xPos = 0, yPos += documentData.yOffset, yPos += firstLine ? 1 : 0, currentLength = initPathPos, firstLine = !1, this._hasMaskedPath && (pointInd = initPointInd, prevPoint = (points = segments[segmentInd = initSegmentInd].points)[pointInd - 1], partialLength = (currentPoint = points[pointInd]).partialLength, segmentLength = 0), letterM = "", letterFc = "", letterSw = "", letterO = "", letterP = this.defaultPropsArray;
                                else {
                                    if (this._hasMaskedPath) {
                                        if (currentLine !== letters[i].line) {
                                            switch (documentData.j) {
                                                case 1:
                                                    currentLength += totalLength - documentData.lineWidths[letters[i].line];
                                                    break;
                                                case 2:
                                                    currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2
                                            }
                                            currentLine = letters[i].line
                                        }
                                        ind !== letters[i].ind && (letters[ind] && (currentLength += letters[ind].extra), currentLength += letters[i].an / 2, ind = letters[i].ind), currentLength += alignment[0] * letters[i].an * .005;
                                        var animatorOffset = 0;
                                        for (j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).p.propType && ((mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)).length ? animatorOffset += animatorProps.p.v[0] * mult[0] : animatorOffset += animatorProps.p.v[0] * mult), animatorProps.a.propType && ((mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)).length ? animatorOffset += animatorProps.a.v[0] * mult[0] : animatorOffset += animatorProps.a.v[0] * mult);
                                        for (flag = !0, this._pathData.a.v && (currentLength = .5 * letters[0].an + (totalLength - this._pathData.f.v - .5 * letters[0].an - .5 * letters[letters.length - 1].an) * ind / (len - 1), currentLength += this._pathData.f.v); flag;) segmentLength + partialLength >= currentLength + animatorOffset || !points ? (perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength, xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc, yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc, matrixHelper.translate(-alignment[0] * letters[i].an * .005, -alignment[1] * yOff * .01), flag = !1) : points && (segmentLength += currentPoint.partialLength, (pointInd += 1) >= points.length && (pointInd = 0, segments[segmentInd += 1] ? points = segments[segmentInd].points : mask.v.c ? (pointInd = 0, points = segments[segmentInd = 0].points) : (segmentLength -= currentPoint.partialLength, points = null)), points && (prevPoint = currentPoint, partialLength = (currentPoint = points[pointInd]).partialLength));
                                        offf = letters[i].an / 2 - letters[i].add, matrixHelper.translate(-offf, 0, 0)
                                    } else offf = letters[i].an / 2 - letters[i].add, matrixHelper.translate(-offf, 0, 0), matrixHelper.translate(-alignment[0] * letters[i].an * .005, -alignment[1] * yOff * .01, 0);
                                    for (j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).t.propType && (mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars), 0 === xPos && 0 === documentData.j || (this._hasMaskedPath ? mult.length ? currentLength += animatorProps.t.v * mult[0] : currentLength += animatorProps.t.v * mult : mult.length ? xPos += animatorProps.t.v * mult[0] : xPos += animatorProps.t.v * mult));
                                    for (documentData.strokeWidthAnim && (sw = documentData.sw || 0), documentData.strokeColorAnim && (sc = documentData.sc ? [documentData.sc[0], documentData.sc[1], documentData.sc[2]] : [0, 0, 0]), documentData.fillColorAnim && documentData.fc && (fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]]), j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).a.propType && ((mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)).length ? matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]) : matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult));
                                    for (j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).s.propType && ((mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars)).length ? matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1) : matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1));
                                    for (j = 0; j < jLen; j += 1) {
                                        if (animatorProps = animators[j].a, mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars), animatorProps.sk.propType && (mult.length ? matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]) : matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult)), animatorProps.r.propType && (mult.length ? matrixHelper.rotateZ(-animatorProps.r.v * mult[2]) : matrixHelper.rotateZ(-animatorProps.r.v * mult)), animatorProps.ry.propType && (mult.length ? matrixHelper.rotateY(animatorProps.ry.v * mult[1]) : matrixHelper.rotateY(animatorProps.ry.v * mult)), animatorProps.rx.propType && (mult.length ? matrixHelper.rotateX(animatorProps.rx.v * mult[0]) : matrixHelper.rotateX(animatorProps.rx.v * mult)), animatorProps.o.propType && (mult.length ? elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0] : elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult), documentData.strokeWidthAnim && animatorProps.sw.propType && (mult.length ? sw += animatorProps.sw.v * mult[0] : sw += animatorProps.sw.v * mult), documentData.strokeColorAnim && animatorProps.sc.propType)
                                            for (k = 0; k < 3; k += 1) mult.length ? sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0] : sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                                        if (documentData.fillColorAnim && documentData.fc) {
                                            if (animatorProps.fc.propType)
                                                for (k = 0; k < 3; k += 1) mult.length ? fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0] : fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                                            animatorProps.fh.propType && (fc = mult.length ? addHueToRGB(fc, animatorProps.fh.v * mult[0]) : addHueToRGB(fc, animatorProps.fh.v * mult)), animatorProps.fs.propType && (fc = mult.length ? addSaturationToRGB(fc, animatorProps.fs.v * mult[0]) : addSaturationToRGB(fc, animatorProps.fs.v * mult)), animatorProps.fb.propType && (fc = mult.length ? addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]) : addBrightnessToRGB(fc, animatorProps.fb.v * mult))
                                        }
                                    }
                                    for (j = 0; j < jLen; j += 1)(animatorProps = animators[j].a).p.propType && (mult = animators[j].s.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars), this._hasMaskedPath ? mult.length ? matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]) : matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult) : mult.length ? matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]) : matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult));
                                    if (documentData.strokeWidthAnim && (letterSw = sw < 0 ? 0 : sw), documentData.strokeColorAnim && (letterSc = "rgb(" + Math.round(255 * sc[0]) + "," + Math.round(255 * sc[1]) + "," + Math.round(255 * sc[2]) + ")"), documentData.fillColorAnim && documentData.fc && (letterFc = "rgb(" + Math.round(255 * fc[0]) + "," + Math.round(255 * fc[1]) + "," + Math.round(255 * fc[2]) + ")"), this._hasMaskedPath) {
                                        if (matrixHelper.translate(0, -documentData.ls), matrixHelper.translate(0, alignment[1] * yOff * .01 + yPos, 0), this._pathData.p.v) {
                                            tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                                            var rot = 180 * Math.atan(tanAngle) / Math.PI;
                                            currentPoint.point[0] < prevPoint.point[0] && (rot += 180), matrixHelper.rotate(-rot * Math.PI / 180)
                                        }
                                        matrixHelper.translate(xPathPos, yPathPos, 0), currentLength -= alignment[0] * letters[i].an * .005, letters[i + 1] && ind !== letters[i + 1].ind && (currentLength += letters[i].an / 2, currentLength += .001 * documentData.tr * documentData.finalSize)
                                    } else {
                                        switch (matrixHelper.translate(xPos, yPos, 0), documentData.ps && matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0), documentData.j) {
                                            case 1:
                                                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                                                break;
                                            case 2:
                                                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0)
                                        }
                                        matrixHelper.translate(0, -documentData.ls), matrixHelper.translate(offf, 0, 0), matrixHelper.translate(alignment[0] * letters[i].an * .005, alignment[1] * yOff * .01, 0), xPos += letters[i].l + .001 * documentData.tr * documentData.finalSize
                                    }
                                    "html" === renderType ? letterM = matrixHelper.toCSS() : "svg" === renderType ? letterM = matrixHelper.to2dCSS() : letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]], letterO = elemOpacity
                                }
                                renderedLettersCount <= i ? (letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP), this.renderedLetters.push(letterValue), renderedLettersCount += 1, this.lettersChangedFlag = !0) : (letterValue = this.renderedLetters[i], this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag)
                            }
                        }
                    }, TextAnimatorProperty.prototype.getValue = function() {
                        this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
                    }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), ITextElement.prototype.initElement = function(data, globalData, comp) {
                        this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(data, globalData, comp), this.textProperty = new TextProperty(this, data.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this), this.initTransform(data, globalData, comp), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
                    }, ITextElement.prototype.prepareFrame = function(num) {
                        this._mdf = !1, this.prepareRenderableFrame(num), this.prepareProperties(num, this.isInRange)
                    }, ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
                        var j, pathNodes, jLen = shapes.length,
                            shapeStr = "";
                        for (j = 0; j < jLen; j += 1) "sh" === shapes[j].ty && (pathNodes = shapes[j].ks.k, shapeStr += buildShapeString(pathNodes, pathNodes.i.length, !0, matrixHelper));
                        return shapeStr
                    }, ITextElement.prototype.updateDocumentData = function(newData, index) {
                        this.textProperty.updateDocumentData(newData, index)
                    }, ITextElement.prototype.canResizeFont = function(_canResize) {
                        this.textProperty.canResizeFont(_canResize)
                    }, ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
                        this.textProperty.setMinimumFontSize(_fontSize)
                    }, ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
                        switch (documentData.ps && matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0), matrixHelper.translate(0, -documentData.ls, 0), documentData.j) {
                            case 1:
                                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
                                break;
                            case 2:
                                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0)
                        }
                        matrixHelper.translate(xPos, yPos, 0)
                    }, ITextElement.prototype.buildColor = function(colorData) {
                        return "rgb(" + Math.round(255 * colorData[0]) + "," + Math.round(255 * colorData[1]) + "," + Math.round(255 * colorData[2]) + ")"
                    }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function() {}, ITextElement.prototype.validateText = function() {
                        (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
                    };
                    var emptyShapeData = {
                        shapes: []
                    };

                    function SVGTextLottieElement(data, globalData, comp) {
                        this.textSpans = [], this.renderType = "svg", this.initElement(data, globalData, comp)
                    }

                    function ISolidElement(data, globalData, comp) {
                        this.initElement(data, globalData, comp)
                    }

                    function NullElement(data, globalData, comp) {
                        this.initFrame(), this.initBaseData(data, globalData, comp), this.initFrame(), this.initTransform(data, globalData, comp), this.initHierarchy()
                    }

                    function SVGRendererBase() {}

                    function ICompElement() {}

                    function SVGCompElement(data, globalData, comp) {
                        this.layers = data.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(data, globalData, comp), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function SVGRenderer(animationItem, config) {
                        this.animationItem = animationItem, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                        var ariaLabel = "";
                        if (config && config.title) {
                            var titleElement = createNS("title"),
                                titleId = createElementID();
                            titleElement.setAttribute("id", titleId), titleElement.textContent = config.title, this.svgElement.appendChild(titleElement), ariaLabel += titleId
                        }
                        if (config && config.description) {
                            var descElement = createNS("desc"),
                                descId = createElementID();
                            descElement.setAttribute("id", descId), descElement.textContent = config.description, this.svgElement.appendChild(descElement), ariaLabel += " " + descId
                        }
                        ariaLabel && this.svgElement.setAttribute("aria-labelledby", ariaLabel);
                        var defs = createNS("defs");
                        this.svgElement.appendChild(defs);
                        var maskElement = createNS("g");
                        this.svgElement.appendChild(maskElement), this.layerElement = maskElement, this.renderConfig = {
                            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
                            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                            contentVisibility: config && config.contentVisibility || "visible",
                            progressiveLoad: config && config.progressiveLoad || !1,
                            hideOnTransparent: !(config && !1 === config.hideOnTransparent),
                            viewBoxOnly: config && config.viewBoxOnly || !1,
                            viewBoxSize: config && config.viewBoxSize || !1,
                            className: config && config.className || "",
                            id: config && config.id || "",
                            focusable: config && config.focusable,
                            filterSize: {
                                width: config && config.filterSize && config.filterSize.width || "100%",
                                height: config && config.filterSize && config.filterSize.height || "100%",
                                x: config && config.filterSize && config.filterSize.x || "0%",
                                y: config && config.filterSize && config.filterSize.y || "0%"
                            },
                            width: config && config.width,
                            height: config && config.height,
                            runExpressions: !config || void 0 === config.runExpressions || config.runExpressions
                        }, this.globalData = {
                            _mdf: !1,
                            frameNum: -1,
                            defs: defs,
                            renderConfig: this.renderConfig
                        }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
                    }

                    function ShapeTransformManager() {
                        this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
                    }
                    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
                        this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
                    }, SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
                        for (var i = 0, len = textArray.length, textContents = [], currentTextContent = ""; i < len;) textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3) ? (textContents.push(currentTextContent), currentTextContent = "") : currentTextContent += textArray[i], i += 1;
                        return textContents.push(currentTextContent), textContents
                    }, SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {
                        if (data.shapes && data.shapes.length) {
                            var shape = data.shapes[0];
                            if (shape.it) {
                                var shapeItem = shape.it[shape.it.length - 1];
                                shapeItem.s && (shapeItem.s.k[0] = scale, shapeItem.s.k[1] = scale)
                            }
                        }
                        return data
                    }, SVGTextLottieElement.prototype.buildNewText = function() {
                        var i, len;
                        this.addDynamicProperty(this);
                        var documentData = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0), documentData.fc ? this.layerElement.setAttribute("fill", this.buildColor(documentData.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), documentData.sc && (this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc)), this.layerElement.setAttribute("stroke-width", documentData.sw)), this.layerElement.setAttribute("font-size", documentData.finalSize);
                        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
                        if (fontData.fClass) this.layerElement.setAttribute("class", fontData.fClass);
                        else {
                            this.layerElement.setAttribute("font-family", fontData.fFamily);
                            var fWeight = documentData.fWeight,
                                fStyle = documentData.fStyle;
                            this.layerElement.setAttribute("font-style", fStyle), this.layerElement.setAttribute("font-weight", fWeight)
                        }
                        this.layerElement.setAttribute("aria-label", documentData.t);
                        var tSpan, letters = documentData.l || [],
                            usesGlyphs = !!this.globalData.fontManager.chars;
                        len = letters.length;
                        var matrixHelper = this.mHelper,
                            singleShape = this.data.singleShape,
                            xPos = 0,
                            yPos = 0,
                            firstLine = !0,
                            trackingOffset = .001 * documentData.tr * documentData.finalSize;
                        if (!singleShape || usesGlyphs || documentData.sz) {
                            var charData, cachedSpansLength = this.textSpans.length;
                            for (i = 0; i < len; i += 1) {
                                if (this.textSpans[i] || (this.textSpans[i] = {
                                        span: null,
                                        childSpan: null,
                                        glyph: null
                                    }), !usesGlyphs || !singleShape || 0 === i) {
                                    if (tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? "g" : "text"), cachedSpansLength <= i) {
                                        if (tSpan.setAttribute("stroke-linecap", "butt"), tSpan.setAttribute("stroke-linejoin", "round"), tSpan.setAttribute("stroke-miterlimit", "4"), this.textSpans[i].span = tSpan, usesGlyphs) {
                                            var childSpan = createNS("g");
                                            tSpan.appendChild(childSpan), this.textSpans[i].childSpan = childSpan
                                        }
                                        this.textSpans[i].span = tSpan, this.layerElement.appendChild(tSpan)
                                    }
                                    tSpan.style.display = "inherit"
                                }
                                if (matrixHelper.reset(), singleShape && (letters[i].n && (xPos = -trackingOffset, yPos += documentData.yOffset, yPos += firstLine ? 1 : 0, firstLine = !1), this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos), xPos += letters[i].l || 0, xPos += trackingOffset), usesGlyphs) {
                                    var glyphElement;
                                    if (1 === (charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily)).t) glyphElement = new SVGCompElement(charData.data, this.globalData, this);
                                    else {
                                        var data = emptyShapeData;
                                        charData.data && charData.data.shapes && (data = this.buildShapeData(charData.data, documentData.finalSize)), glyphElement = new SVGShapeElement(data, this.globalData, this)
                                    }
                                    if (this.textSpans[i].glyph) {
                                        var glyph = this.textSpans[i].glyph;
                                        this.textSpans[i].childSpan.removeChild(glyph.layerElement), glyph.destroy()
                                    }
                                    this.textSpans[i].glyph = glyphElement, glyphElement._debug = !0, glyphElement.prepareFrame(0), glyphElement.renderFrame(), this.textSpans[i].childSpan.appendChild(glyphElement.layerElement), 1 === charData.t && this.textSpans[i].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")")
                                } else singleShape && tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")"), tSpan.textContent = letters[i].val, tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                            }
                            singleShape && tSpan && tSpan.setAttribute("d", "")
                        } else {
                            var tElement = this.textContainer,
                                justify = "start";
                            switch (documentData.j) {
                                case 1:
                                    justify = "end";
                                    break;
                                case 2:
                                    justify = "middle";
                                    break;
                                default:
                                    justify = "start"
                            }
                            tElement.setAttribute("text-anchor", justify), tElement.setAttribute("letter-spacing", trackingOffset);
                            var textContent = this.buildTextContents(documentData.finalText);
                            for (len = textContent.length, yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0, i = 0; i < len; i += 1)(tSpan = this.textSpans[i].span || createNS("tspan")).textContent = textContent[i], tSpan.setAttribute("x", 0), tSpan.setAttribute("y", yPos), tSpan.style.display = "inherit", tElement.appendChild(tSpan), this.textSpans[i] || (this.textSpans[i] = {
                                span: null,
                                glyph: null
                            }), this.textSpans[i].span = tSpan, yPos += documentData.finalLineHeight;
                            this.layerElement.appendChild(tElement)
                        }
                        for (; i < this.textSpans.length;) this.textSpans[i].span.style.display = "none", i += 1;
                        this._sizeChanged = !0
                    }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
                        if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                            this._sizeChanged = !1;
                            var textBox = this.layerElement.getBBox();
                            this.bbox = {
                                top: textBox.y,
                                left: textBox.x,
                                width: textBox.width,
                                height: textBox.height
                            }
                        }
                        return this.bbox
                    }, SVGTextLottieElement.prototype.getValue = function() {
                        var i, glyphElement, len = this.textSpans.length;
                        for (this.renderedFrame = this.comp.renderedFrame, i = 0; i < len; i += 1)(glyphElement = this.textSpans[i].glyph) && (glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st), glyphElement._mdf && (this._mdf = !0))
                    }, SVGTextLottieElement.prototype.renderInnerContent = function() {
                        if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                            var i, len;
                            this._sizeChanged = !0;
                            var renderedLetter, textSpan, glyphElement, renderedLetters = this.textAnimator.renderedLetters,
                                letters = this.textProperty.currentData.l;
                            for (len = letters.length, i = 0; i < len; i += 1) letters[i].n || (renderedLetter = renderedLetters[i], textSpan = this.textSpans[i].span, (glyphElement = this.textSpans[i].glyph) && glyphElement.renderFrame(), renderedLetter._mdf.m && textSpan.setAttribute("transform", renderedLetter.m), renderedLetter._mdf.o && textSpan.setAttribute("opacity", renderedLetter.o), renderedLetter._mdf.sw && textSpan.setAttribute("stroke-width", renderedLetter.sw), renderedLetter._mdf.sc && textSpan.setAttribute("stroke", renderedLetter.sc), renderedLetter._mdf.fc && textSpan.setAttribute("fill", renderedLetter.fc))
                        }
                    }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
                        var rect = createNS("rect");
                        rect.setAttribute("width", this.data.sw), rect.setAttribute("height", this.data.sh), rect.setAttribute("fill", this.data.sc), this.layerElement.appendChild(rect)
                    }, NullElement.prototype.prepareFrame = function(num) {
                        this.prepareProperties(num, !0)
                    }, NullElement.prototype.renderFrame = function() {}, NullElement.prototype.getBaseElement = function() {
                        return null
                    }, NullElement.prototype.destroy = function() {}, NullElement.prototype.sourceRectAtTime = function() {}, NullElement.prototype.hide = function() {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function(data) {
                        return new NullElement(data, this.globalData, this)
                    }, SVGRendererBase.prototype.createShape = function(data) {
                        return new SVGShapeElement(data, this.globalData, this)
                    }, SVGRendererBase.prototype.createText = function(data) {
                        return new SVGTextLottieElement(data, this.globalData, this)
                    }, SVGRendererBase.prototype.createImage = function(data) {
                        return new IImageElement(data, this.globalData, this)
                    }, SVGRendererBase.prototype.createSolid = function(data) {
                        return new ISolidElement(data, this.globalData, this)
                    }, SVGRendererBase.prototype.configAnimation = function(animData) {
                        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", animData.w), this.svgElement.setAttribute("height", animData.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                        var defs = this.globalData.defs;
                        this.setupGlobalData(animData, defs), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = animData;
                        var maskElement = createNS("clipPath"),
                            rect = createNS("rect");
                        rect.setAttribute("width", animData.w), rect.setAttribute("height", animData.h), rect.setAttribute("x", 0), rect.setAttribute("y", 0);
                        var maskId = createElementID();
                        maskElement.setAttribute("id", maskId), maskElement.appendChild(rect), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")"), defs.appendChild(maskElement), this.layers = animData.layers, this.elements = createSizedArray(animData.layers.length)
                    }, SVGRendererBase.prototype.destroy = function() {
                        var i;
                        this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                        var len = this.layers ? this.layers.length : 0;
                        for (i = 0; i < len; i += 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
                        this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                    }, SVGRendererBase.prototype.updateContainerSize = function() {}, SVGRendererBase.prototype.findIndexByInd = function(ind) {
                        var i = 0,
                            len = this.layers.length;
                        for (i = 0; i < len; i += 1)
                            if (this.layers[i].ind === ind) return i;
                        return -1
                    }, SVGRendererBase.prototype.buildItem = function(pos) {
                        var elements = this.elements;
                        if (!elements[pos] && 99 !== this.layers[pos].ty) {
                            elements[pos] = !0;
                            var element = this.createItem(this.layers[pos]);
                            if (elements[pos] = element, getExpressionsPlugin() && (0 === this.layers[pos].ty && this.globalData.projectInterface.registerComposition(element), element.initExpressions()), this.appendElementInPos(element, pos), this.layers[pos].tt) {
                                var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
                                if (-1 === elementIndex) return;
                                if (this.elements[elementIndex] && !0 !== this.elements[elementIndex]) {
                                    var matteMask = elements[elementIndex].getMatte(this.layers[pos].tt);
                                    element.setMatte(matteMask)
                                } else this.buildItem(elementIndex), this.addPendingElement(element)
                            }
                        }
                    }, SVGRendererBase.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) {
                            var element = this.pendingElements.pop();
                            if (element.checkParenting(), element.data.tt)
                                for (var i = 0, len = this.elements.length; i < len;) {
                                    if (this.elements[i] === element) {
                                        var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i - 1,
                                            matteMask = this.elements[elementIndex].getMatte(this.layers[i].tt);
                                        element.setMatte(matteMask);
                                        break
                                    }
                                    i += 1
                                }
                        }
                    }, SVGRendererBase.prototype.renderFrame = function(num) {
                        if (this.renderedFrame !== num && !this.destroyed) {
                            var i;
                            null === num ? num = this.renderedFrame : this.renderedFrame = num, this.globalData.frameNum = num, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = num, this.globalData._mdf = !1;
                            var len = this.layers.length;
                            for (this.completeLayers || this.checkLayers(num), i = len - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(num - this.layers[i].st);
                            if (this.globalData._mdf)
                                for (i = 0; i < len; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                        }
                    }, SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
                        var newElement = element.getBaseElement();
                        if (newElement) {
                            for (var nextElement, i = 0; i < pos;) this.elements[i] && !0 !== this.elements[i] && this.elements[i].getBaseElement() && (nextElement = this.elements[i].getBaseElement()), i += 1;
                            nextElement ? this.layerElement.insertBefore(newElement, nextElement) : this.layerElement.appendChild(newElement)
                        }
                    }, SVGRendererBase.prototype.hide = function() {
                        this.layerElement.style.display = "none"
                    }, SVGRendererBase.prototype.show = function() {
                        this.layerElement.style.display = "block"
                    }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(data, globalData, comp) {
                        this.initFrame(), this.initBaseData(data, globalData, comp), this.initTransform(data, globalData, comp), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && globalData.progressiveLoad || this.buildAllItems(), this.hide()
                    }, ICompElement.prototype.prepareFrame = function(num) {
                        if (this._mdf = !1, this.prepareRenderableFrame(num), this.prepareProperties(num, this.isInRange), this.isInRange || this.data.xt) {
                            if (this.tm._placeholder) this.renderedFrame = num / this.data.sr;
                            else {
                                var timeRemapped = this.tm.v;
                                timeRemapped === this.data.op && (timeRemapped = this.data.op - 1), this.renderedFrame = timeRemapped
                            }
                            var i, len = this.elements.length;
                            for (this.completeLayers || this.checkLayers(this.renderedFrame), i = len - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st), this.elements[i]._mdf && (this._mdf = !0))
                        }
                    }, ICompElement.prototype.renderInnerContent = function() {
                        var i, len = this.layers.length;
                        for (i = 0; i < len; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                    }, ICompElement.prototype.setElements = function(elems) {
                        this.elements = elems
                    }, ICompElement.prototype.getElements = function() {
                        return this.elements
                    }, ICompElement.prototype.destroyElements = function() {
                        var i, len = this.layers.length;
                        for (i = 0; i < len; i += 1) this.elements[i] && this.elements[i].destroy()
                    }, ICompElement.prototype.destroy = function() {
                        this.destroyElements(), this.destroyBaseElement()
                    }, extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function(data) {
                        return new SVGCompElement(data, this.globalData, this)
                    }, extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function(data) {
                        return new SVGCompElement(data, this.globalData, this)
                    }, ShapeTransformManager.prototype = {
                        addTransformSequence: function addTransformSequence(transforms) {
                            var i, len = transforms.length,
                                key = "_";
                            for (i = 0; i < len; i += 1) key += transforms[i].transform.key + "_";
                            var sequence = this.sequences[key];
                            return sequence || (sequence = {
                                transforms: [].concat(transforms),
                                finalTransform: new Matrix,
                                _mdf: !1
                            }, this.sequences[key] = sequence, this.sequenceList.push(sequence)), sequence
                        },
                        processSequence: function processSequence(sequence, isFirstFrame) {
                            for (var i = 0, len = sequence.transforms.length, _mdf = isFirstFrame; i < len && !isFirstFrame;) {
                                if (sequence.transforms[i].transform.mProps._mdf) {
                                    _mdf = !0;
                                    break
                                }
                                i += 1
                            }
                            if (_mdf)
                                for (sequence.finalTransform.reset(), i = len - 1; i >= 0; i -= 1) sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
                            sequence._mdf = _mdf
                        },
                        processSequences: function processSequences(isFirstFrame) {
                            var i, len = this.sequenceList.length;
                            for (i = 0; i < len; i += 1) this.processSequence(this.sequenceList[i], isFirstFrame)
                        },
                        getNewKey: function getNewKey() {
                            return this.transform_key_count += 1, "_" + this.transform_key_count
                        }
                    };
                    var lumaLoader = function lumaLoader() {
                        var id = "__lottie_element_luma_buffer",
                            lumaBuffer = null,
                            lumaBufferCtx = null,
                            svg = null;

                        function loadLuma() {
                            lumaBuffer || (svg = function createLumaSvgFilter() {
                                var _svg = createNS("svg"),
                                    fil = createNS("filter"),
                                    matrix = createNS("feColorMatrix");
                                return fil.setAttribute("id", id), matrix.setAttribute("type", "matrix"), matrix.setAttribute("color-interpolation-filters", "sRGB"), matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), fil.appendChild(matrix), _svg.appendChild(fil), _svg.setAttribute("id", id + "_svg"), featureSupport.svgLumaHidden && (_svg.style.display = "none"), _svg
                            }(), document.body.appendChild(svg), lumaBuffer = createTag("canvas"), (lumaBufferCtx = lumaBuffer.getContext("2d")).filter = "url(#" + id + ")", lumaBufferCtx.fillStyle = "rgba(0,0,0,0)", lumaBufferCtx.fillRect(0, 0, 1, 1))
                        }
                        return {
                            load: loadLuma,
                            get: function getLuma(canvas) {
                                return lumaBuffer || loadLuma(), lumaBuffer.width = canvas.width, lumaBuffer.height = canvas.height, lumaBufferCtx.filter = "url(#" + id + ")", lumaBuffer
                            }
                        }
                    };

                    function createCanvas(width, height) {
                        if (featureSupport.offscreenCanvas) return new OffscreenCanvas(width, height);
                        var canvas = createTag("canvas");
                        return canvas.width = width, canvas.height = height, canvas
                    }
                    var assetLoader = {
                            loadLumaCanvas: lumaLoader.load,
                            getLumaCanvas: lumaLoader.get,
                            createCanvas: createCanvas
                        },
                        registeredEffects = {};

                    function CVEffects(elem) {
                        var i, filterManager, len = elem.data.ef ? elem.data.ef.length : 0;
                        for (this.filters = [], i = 0; i < len; i += 1) {
                            filterManager = null;
                            var type = elem.data.ef[i].ty;
                            registeredEffects[type] && (filterManager = new(0, registeredEffects[type].effect)(elem.effectsManager.effectElements[i], elem)), filterManager && this.filters.push(filterManager)
                        }
                        this.filters.length && elem.addRenderableComponent(this)
                    }

                    function registerEffect(id, effect) {
                        registeredEffects[id] = {
                            effect: effect
                        }
                    }

                    function CVMaskElement(data, element) {
                        var i;
                        this.data = data, this.element = element, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                        var len = this.masksProperties.length,
                            hasMasks = !1;
                        for (i = 0; i < len; i += 1) "n" !== this.masksProperties[i].mode && (hasMasks = !0), this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
                        this.hasMasks = hasMasks, hasMasks && this.element.addRenderableComponent(this)
                    }

                    function CVBaseElement() {}
                    CVEffects.prototype.renderFrame = function(_isFirstFrame) {
                        var i, len = this.filters.length;
                        for (i = 0; i < len; i += 1) this.filters[i].renderFrame(_isFirstFrame)
                    }, CVEffects.prototype.getEffects = function(type) {
                        var i, len = this.filters.length,
                            effects = [];
                        for (i = 0; i < len; i += 1) this.filters[i].type === type && effects.push(this.filters[i]);
                        return effects
                    }, CVMaskElement.prototype.renderFrame = function() {
                        if (this.hasMasks) {
                            var i, pt, pts, data, transform = this.element.finalTransform.mat,
                                ctx = this.element.canvasContext,
                                len = this.masksProperties.length;
                            for (ctx.beginPath(), i = 0; i < len; i += 1)
                                if ("n" !== this.masksProperties[i].mode) {
                                    var j;
                                    this.masksProperties[i].inv && (ctx.moveTo(0, 0), ctx.lineTo(this.element.globalData.compSize.w, 0), ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), ctx.lineTo(0, this.element.globalData.compSize.h), ctx.lineTo(0, 0)), data = this.viewData[i].v, pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0), ctx.moveTo(pt[0], pt[1]);
                                    var jLen = data._length;
                                    for (j = 1; j < jLen; j += 1) pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]), ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]), ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5])
                                } this.element.globalData.renderer.save(!0), ctx.clip()
                        }
                    }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
                        this.element = null
                    };
                    var operationsMap = {
                        1: "source-in",
                        2: "source-out",
                        3: "source-in",
                        4: "source-out"
                    };

                    function CVShapeData(element, data, styles, transformsManager) {
                        this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                        var i, ty = 4;
                        "rc" === data.ty ? ty = 5 : "el" === data.ty ? ty = 6 : "sr" === data.ty && (ty = 7), this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
                        var styledShape, len = styles.length;
                        for (i = 0; i < len; i += 1) styles[i].closed || (styledShape = {
                            transforms: transformsManager.addTransformSequence(styles[i].transforms),
                            trNodes: []
                        }, this.styledShapes.push(styledShape), styles[i].elements.push(styledShape))
                    }

                    function CVShapeElement(data, globalData, comp) {
                        this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(data, globalData, comp)
                    }

                    function CVTextElement(data, globalData, comp) {
                        this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                            fill: "rgba(0,0,0,0)",
                            stroke: "rgba(0,0,0,0)",
                            sWidth: 0,
                            fValue: ""
                        }, this.initElement(data, globalData, comp)
                    }

                    function CVImageElement(data, globalData, comp) {
                        this.assetData = globalData.getAssetData(data.refId), this.img = globalData.imageLoader.getAsset(this.assetData), this.initElement(data, globalData, comp)
                    }

                    function CVSolidElement(data, globalData, comp) {
                        this.initElement(data, globalData, comp)
                    }

                    function CanvasRendererBase() {}

                    function CanvasContext() {
                        this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random()
                    }

                    function CVContextData() {
                        var i;
                        for (this.stack = [], this.cArrPos = 0, this.cTr = new Matrix, i = 0; i < 15; i += 1) {
                            var canvasContext = new CanvasContext;
                            this.stack[i] = canvasContext
                        }
                        this._length = 15, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = ""
                    }

                    function CVCompElement(data, globalData, comp) {
                        this.completeLayers = !1, this.layers = data.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(data, globalData, comp), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function CanvasRenderer(animationItem, config) {
                        this.animationItem = animationItem, this.renderConfig = {
                            clearCanvas: !config || void 0 === config.clearCanvas || config.clearCanvas,
                            context: config && config.context || null,
                            progressiveLoad: config && config.progressiveLoad || !1,
                            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
                            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                            contentVisibility: config && config.contentVisibility || "visible",
                            className: config && config.className || "",
                            id: config && config.id || "",
                            runExpressions: !config || void 0 === config.runExpressions || config.runExpressions
                        }, this.renderConfig.dpr = config && config.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                            frameNum: -1,
                            _mdf: !1,
                            renderConfig: this.renderConfig,
                            currentGlobalAlpha: -1
                        }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData))
                    }

                    function HBaseElement() {}

                    function HSolidElement(data, globalData, comp) {
                        this.initElement(data, globalData, comp)
                    }

                    function HShapeElement(data, globalData, comp) {
                        this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(data, globalData, comp), this.prevViewData = [], this.currentBBox = {
                            x: 999999,
                            y: -999999,
                            h: 0,
                            w: 0
                        }
                    }

                    function HTextElement(data, globalData, comp) {
                        this.textSpans = [], this.textPaths = [], this.currentBBox = {
                            x: 999999,
                            y: -999999,
                            h: 0,
                            w: 0
                        }, this.renderType = "svg", this.isMasked = !1, this.initElement(data, globalData, comp)
                    }

                    function HCameraElement(data, globalData, comp) {
                        this.initFrame(), this.initBaseData(data, globalData, comp), this.initHierarchy();
                        var getProp = PropertyFactory.getProp;
                        if (this.pe = getProp(this, data.pe, 0, 0, this), data.ks.p.s ? (this.px = getProp(this, data.ks.p.x, 1, 0, this), this.py = getProp(this, data.ks.p.y, 1, 0, this), this.pz = getProp(this, data.ks.p.z, 1, 0, this)) : this.p = getProp(this, data.ks.p, 1, 0, this), data.ks.a && (this.a = getProp(this, data.ks.a, 1, 0, this)), data.ks.or.k.length && data.ks.or.k[0].to) {
                            var i, len = data.ks.or.k.length;
                            for (i = 0; i < len; i += 1) data.ks.or.k[i].to = null, data.ks.or.k[i].ti = null
                        }
                        this.or = getProp(this, data.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = getProp(this, data.ks.rx, 0, degToRads, this), this.ry = getProp(this, data.ks.ry, 0, degToRads, this), this.rz = getProp(this, data.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                            mProp: this
                        }
                    }

                    function HImageElement(data, globalData, comp) {
                        this.assetData = globalData.getAssetData(data.refId), this.initElement(data, globalData, comp)
                    }

                    function HybridRendererBase(animationItem, config) {
                        this.animationItem = animationItem, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                            className: config && config.className || "",
                            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                            hideOnTransparent: !(config && !1 === config.hideOnTransparent),
                            filterSize: {
                                width: config && config.filterSize && config.filterSize.width || "400%",
                                height: config && config.filterSize && config.filterSize.height || "400%",
                                x: config && config.filterSize && config.filterSize.x || "-100%",
                                y: config && config.filterSize && config.filterSize.y || "-100%"
                            }
                        }, this.globalData = {
                            _mdf: !1,
                            frameNum: -1,
                            renderConfig: this.renderConfig
                        }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
                    }

                    function HCompElement(data, globalData, comp) {
                        this.layers = data.layers, this.supports3d = !data.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(data, globalData, comp), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
                            _placeholder: !0
                        }
                    }

                    function HybridRenderer(animationItem, config) {
                        this.animationItem = animationItem, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                            className: config && config.className || "",
                            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
                            hideOnTransparent: !(config && !1 === config.hideOnTransparent),
                            filterSize: {
                                width: config && config.filterSize && config.filterSize.width || "400%",
                                height: config && config.filterSize && config.filterSize.height || "400%",
                                x: config && config.filterSize && config.filterSize.x || "-100%",
                                y: config && config.filterSize && config.filterSize.y || "-100%"
                            },
                            runExpressions: !config || void 0 === config.runExpressions || config.runExpressions
                        }, this.globalData = {
                            _mdf: !1,
                            frameNum: -1,
                            renderConfig: this.renderConfig
                        }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
                    }
                    CVBaseElement.prototype = {
                        createElements: function createElements() {},
                        initRendererElement: function initRendererElement() {},
                        createContainerElements: function createContainerElements() {
                            if (this.data.tt >= 1) {
                                this.buffers = [];
                                var canvasContext = this.globalData.canvasContext,
                                    bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                                this.buffers.push(bufferCanvas);
                                var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
                                this.buffers.push(bufferCanvas2), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                            }
                            this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms()
                        },
                        createContent: function createContent() {},
                        setBlendMode: function setBlendMode() {
                            var globalData = this.globalData;
                            if (globalData.blendMode !== this.data.bm) {
                                globalData.blendMode = this.data.bm;
                                var blendModeValue = getBlendMode(this.data.bm);
                                globalData.canvasContext.globalCompositeOperation = blendModeValue
                            }
                        },
                        createRenderableComponents: function createRenderableComponents() {
                            this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
                        },
                        hideElement: function hideElement() {
                            this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
                        },
                        showElement: function showElement() {
                            this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                        },
                        clearCanvas: function clearCanvas(canvasContext) {
                            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
                        },
                        prepareLayer: function prepareLayer() {
                            if (this.data.tt >= 1) {
                                var bufferCtx = this.buffers[0].getContext("2d");
                                this.clearCanvas(bufferCtx), bufferCtx.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform)
                            }
                        },
                        exitLayer: function exitLayer() {
                            if (this.data.tt >= 1) {
                                var buffer = this.buffers[1],
                                    bufferCtx = buffer.getContext("2d");
                                if (this.clearCanvas(bufferCtx), bufferCtx.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform), this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1).renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
                                    var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                                    lumaBuffer.getContext("2d").drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(lumaBuffer, 0, 0)
                                }
                                this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(buffer, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over"
                            }
                        },
                        renderFrame: function renderFrame(forceRender) {
                            if (!this.hidden && !this.data.hd && (1 !== this.data.td || forceRender)) {
                                this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
                                var forceRealStack = 0 === this.data.ty;
                                this.prepareLayer(), this.globalData.renderer.save(forceRealStack), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(forceRealStack), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                            }
                        },
                        destroy: function destroy() {
                            this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                        },
                        mHelper: new Matrix
                    }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                        opacity: 1,
                        _opMdf: !1
                    }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
                    }, CVShapeElement.prototype.createStyleElement = function(data, transforms) {
                        var styleElem = {
                                data: data,
                                type: data.ty,
                                preTransforms: this.transformsManager.addTransformSequence(transforms),
                                transforms: [],
                                elements: [],
                                closed: !0 === data.hd
                            },
                            elementData = {};
                        if ("fl" === data.ty || "st" === data.ty ? (elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this), elementData.c.k || (styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")")) : "gf" !== data.ty && "gs" !== data.ty || (elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this), elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this), elementData.h = PropertyFactory.getProp(this, data.h || {
                                k: 0
                            }, 0, .01, this), elementData.a = PropertyFactory.getProp(this, data.a || {
                                k: 0
                            }, 0, degToRads, this), elementData.g = new GradientProperty(this, data.g, this)), elementData.o = PropertyFactory.getProp(this, data.o, 0, .01, this), "st" === data.ty || "gs" === data.ty) {
                            if (styleElem.lc = lineCapEnum[data.lc || 2], styleElem.lj = lineJoinEnum[data.lj || 2], 1 == data.lj && (styleElem.ml = data.ml), elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this), elementData.w.k || (styleElem.wi = elementData.w.v), data.d) {
                                var d = new DashProperty(this, data.d, "canvas", this);
                                elementData.d = d, elementData.d.k || (styleElem.da = elementData.d.dashArray, styleElem.do = elementData.d.dashoffset[0])
                            }
                        } else styleElem.r = 2 === data.r ? "evenodd" : "nonzero";
                        return this.stylesList.push(styleElem), elementData.style = styleElem, elementData
                    }, CVShapeElement.prototype.createGroupElement = function() {
                        return {
                            it: [],
                            prevViewData: []
                        }
                    }, CVShapeElement.prototype.createTransformElement = function(data) {
                        return {
                            transform: {
                                opacity: 1,
                                _opMdf: !1,
                                key: this.transformsManager.getNewKey(),
                                op: PropertyFactory.getProp(this, data.o, 0, .01, this),
                                mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
                            }
                        }
                    }, CVShapeElement.prototype.createShapeElement = function(data) {
                        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
                        return this.shapes.push(elementData), this.addShapeToModifiers(elementData), elementData
                    }, CVShapeElement.prototype.reloadShapes = function() {
                        var i;
                        this._isFirstFrame = !0;
                        var len = this.itemsData.length;
                        for (i = 0; i < len; i += 1) this.prevViewData[i] = this.itemsData[i];
                        for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), len = this.dynamicProperties.length, i = 0; i < len; i += 1) this.dynamicProperties[i].getValue();
                        this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
                    }, CVShapeElement.prototype.addTransformToStyleList = function(transform) {
                        var i, len = this.stylesList.length;
                        for (i = 0; i < len; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.push(transform)
                    }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
                        var i, len = this.stylesList.length;
                        for (i = 0; i < len; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.pop()
                    }, CVShapeElement.prototype.closeStyles = function(styles) {
                        var i, len = styles.length;
                        for (i = 0; i < len; i += 1) styles[i].closed = !0
                    }, CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
                        var i, j, jLen, processedPos, modifier, currentTransform, len = arr.length - 1,
                            ownStyles = [],
                            ownModifiers = [],
                            ownTransforms = [].concat(transforms);
                        for (i = len; i >= 0; i -= 1) {
                            if ((processedPos = this.searchProcessedElement(arr[i])) ? itemsData[i] = prevViewData[processedPos - 1] : arr[i]._shouldRender = shouldRender, "fl" === arr[i].ty || "st" === arr[i].ty || "gf" === arr[i].ty || "gs" === arr[i].ty) processedPos ? itemsData[i].style.closed = !1 : itemsData[i] = this.createStyleElement(arr[i], ownTransforms), ownStyles.push(itemsData[i].style);
                            else if ("gr" === arr[i].ty) {
                                if (processedPos)
                                    for (jLen = itemsData[i].it.length, j = 0; j < jLen; j += 1) itemsData[i].prevViewData[j] = itemsData[i].it[j];
                                else itemsData[i] = this.createGroupElement(arr[i]);
                                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms)
                            } else "tr" === arr[i].ty ? (processedPos || (currentTransform = this.createTransformElement(arr[i]), itemsData[i] = currentTransform), ownTransforms.push(itemsData[i]), this.addTransformToStyleList(itemsData[i])) : "sh" === arr[i].ty || "rc" === arr[i].ty || "el" === arr[i].ty || "sr" === arr[i].ty ? processedPos || (itemsData[i] = this.createShapeElement(arr[i])) : "tm" === arr[i].ty || "rd" === arr[i].ty || "pb" === arr[i].ty || "zz" === arr[i].ty || "op" === arr[i].ty ? (processedPos ? (modifier = itemsData[i]).closed = !1 : ((modifier = ShapeModifiers.getModifier(arr[i].ty)).init(this, arr[i]), itemsData[i] = modifier, this.shapeModifiers.push(modifier)), ownModifiers.push(modifier)) : "rp" === arr[i].ty && (processedPos ? (modifier = itemsData[i]).closed = !0 : (modifier = ShapeModifiers.getModifier(arr[i].ty), itemsData[i] = modifier, modifier.init(this, arr, i, itemsData), this.shapeModifiers.push(modifier), shouldRender = !1), ownModifiers.push(modifier));
                            this.addProcessedElement(arr[i], i + 1)
                        }
                        for (this.removeTransformFromStyleList(), this.closeStyles(ownStyles), len = ownModifiers.length, i = 0; i < len; i += 1) ownModifiers[i].closed = !0
                    }, CVShapeElement.prototype.renderInnerContent = function() {
                        this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
                    }, CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
                        (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) && (groupTransform.opacity = parentTransform.opacity, groupTransform.opacity *= groupTransform.op.v, groupTransform._opMdf = !0)
                    }, CVShapeElement.prototype.drawLayer = function() {
                        var i, j, jLen, k, kLen, elems, nodes, type, currentStyle, len = this.stylesList.length,
                            renderer = this.globalData.renderer,
                            ctx = this.globalData.canvasContext;
                        for (i = 0; i < len; i += 1)
                            if (("st" !== (type = (currentStyle = this.stylesList[i]).type) && "gs" !== type || 0 !== currentStyle.wi) && currentStyle.data._shouldRender && 0 !== currentStyle.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                                for (renderer.save(), elems = currentStyle.elements, "st" === type || "gs" === type ? (renderer.ctxStrokeStyle("st" === type ? currentStyle.co : currentStyle.grd), renderer.ctxLineWidth(currentStyle.wi), renderer.ctxLineCap(currentStyle.lc), renderer.ctxLineJoin(currentStyle.lj), renderer.ctxMiterLimit(currentStyle.ml || 0)) : renderer.ctxFillStyle("fl" === type ? currentStyle.co : currentStyle.grd), renderer.ctxOpacity(currentStyle.coOp), "st" !== type && "gs" !== type && ctx.beginPath(), renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props), jLen = elems.length, j = 0; j < jLen; j += 1) {
                                    for ("st" !== type && "gs" !== type || (ctx.beginPath(), currentStyle.da && (ctx.setLineDash(currentStyle.da), ctx.lineDashOffset = currentStyle.do)), kLen = (nodes = elems[j].trNodes).length, k = 0; k < kLen; k += 1) "m" === nodes[k].t ? ctx.moveTo(nodes[k].p[0], nodes[k].p[1]) : "c" === nodes[k].t ? ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]) : ctx.closePath();
                                    "st" !== type && "gs" !== type || (renderer.ctxStroke(), currentStyle.da && ctx.setLineDash(this.dashResetter))
                                }
                                "st" !== type && "gs" !== type && this.globalData.renderer.ctxFill(currentStyle.r), renderer.restore()
                            }
                    }, CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {
                        var i, groupTransform;
                        for (groupTransform = parentTransform, i = items.length - 1; i >= 0; i -= 1) "tr" === items[i].ty ? (groupTransform = data[i].transform, this.renderShapeTransform(parentTransform, groupTransform)) : "sh" === items[i].ty || "el" === items[i].ty || "rc" === items[i].ty || "sr" === items[i].ty ? this.renderPath(items[i], data[i]) : "fl" === items[i].ty ? this.renderFill(items[i], data[i], groupTransform) : "st" === items[i].ty ? this.renderStroke(items[i], data[i], groupTransform) : "gf" === items[i].ty || "gs" === items[i].ty ? this.renderGradientFill(items[i], data[i], groupTransform) : "gr" === items[i].ty ? this.renderShape(groupTransform, items[i].it, data[i].it) : items[i].ty;
                        isMain && this.drawLayer()
                    }, CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
                        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
                            var i, len, j, shapeNodes = styledShape.trNodes,
                                paths = shape.paths,
                                jLen = paths._length;
                            shapeNodes.length = 0;
                            var groupTransformMat = styledShape.transforms.finalTransform;
                            for (j = 0; j < jLen; j += 1) {
                                var pathNodes = paths.shapes[j];
                                if (pathNodes && pathNodes.v) {
                                    for (len = pathNodes._length, i = 1; i < len; i += 1) 1 === i && shapeNodes.push({
                                        t: "m",
                                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                                    }), shapeNodes.push({
                                        t: "c",
                                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                                    });
                                    1 === len && shapeNodes.push({
                                        t: "m",
                                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                                    }), pathNodes.c && len && (shapeNodes.push({
                                        t: "c",
                                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                                    }), shapeNodes.push({
                                        t: "z"
                                    }))
                                }
                            }
                            styledShape.trNodes = shapeNodes
                        }
                    }, CVShapeElement.prototype.renderPath = function(pathData, itemData) {
                        if (!0 !== pathData.hd && pathData._shouldRender) {
                            var i, len = itemData.styledShapes.length;
                            for (i = 0; i < len; i += 1) this.renderStyledShape(itemData.styledShapes[i], itemData.sh)
                        }
                    }, CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
                        var styleElem = itemData.style;
                        (itemData.c._mdf || this._isFirstFrame) && (styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")"), (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) && (styleElem.coOp = itemData.o.v * groupTransform.opacity)
                    }, CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
                        var grd, styleElem = itemData.style;
                        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || 1 !== styleData.t && (itemData.h._mdf || itemData.a._mdf)) {
                            var i, ctx = this.globalData.canvasContext,
                                pt1 = itemData.s.v,
                                pt2 = itemData.e.v;
                            if (1 === styleData.t) grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
                            else {
                                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)),
                                    ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]),
                                    percent = itemData.h.v;
                                percent >= 1 ? percent = .99 : percent <= -1 && (percent = -.99);
                                var dist = rad * percent,
                                    x = Math.cos(ang + itemData.a.v) * dist + pt1[0],
                                    y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad)
                            }
                            var len = styleData.g.p,
                                cValues = itemData.g.c,
                                opacity = 1;
                            for (i = 0; i < len; i += 1) itemData.g._hasOpacity && itemData.g._collapsable && (opacity = itemData.g.o[2 * i + 1]), grd.addColorStop(cValues[4 * i] / 100, "rgba(" + cValues[4 * i + 1] + "," + cValues[4 * i + 2] + "," + cValues[4 * i + 3] + "," + opacity + ")");
                            styleElem.grd = grd
                        }
                        styleElem.coOp = itemData.o.v * groupTransform.opacity
                    }, CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
                        var styleElem = itemData.style,
                            d = itemData.d;
                        d && (d._mdf || this._isFirstFrame) && (styleElem.da = d.dashArray, styleElem.do = d.dashoffset[0]), (itemData.c._mdf || this._isFirstFrame) && (styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")"), (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) && (styleElem.coOp = itemData.o.v * groupTransform.opacity), (itemData.w._mdf || this._isFirstFrame) && (styleElem.wi = itemData.w.v)
                    }, CVShapeElement.prototype.destroy = function() {
                        this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
                        var documentData = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
                        var hasFill = !1;
                        documentData.fc ? (hasFill = !0, this.values.fill = this.buildColor(documentData.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = hasFill;
                        var hasStroke = !1;
                        documentData.sc && (hasStroke = !0, this.values.stroke = this.buildColor(documentData.sc), this.values.sWidth = documentData.sw);
                        var i, len, charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, fontData = this.globalData.fontManager.getFontByName(documentData.f),
                            letters = documentData.l,
                            matrixHelper = this.mHelper;
                        this.stroke = hasStroke, this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily, len = documentData.finalText.length;
                        var singleShape = this.data.singleShape,
                            trackingOffset = .001 * documentData.tr * documentData.finalSize,
                            xPos = 0,
                            yPos = 0,
                            firstLine = !0,
                            cnt = 0;
                        for (i = 0; i < len; i += 1) {
                            shapeData = (charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily)) && charData.data || {}, matrixHelper.reset(), singleShape && letters[i].n && (xPos = -trackingOffset, yPos += documentData.yOffset, yPos += firstLine ? 1 : 0, firstLine = !1), jLen = (shapes = shapeData.shapes ? shapeData.shapes[0].it : []).length, matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100), singleShape && this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos), commands = createSizedArray(jLen - 1);
                            var commandsCounter = 0;
                            for (j = 0; j < jLen; j += 1)
                                if ("sh" === shapes[j].ty) {
                                    for (kLen = shapes[j].ks.k.i.length, pathNodes = shapes[j].ks.k, pathArr = [], k = 1; k < kLen; k += 1) 1 === k && pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0)), pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
                                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0)), commands[commandsCounter] = pathArr, commandsCounter += 1
                                } singleShape && (xPos += letters[i].l, xPos += trackingOffset), this.textSpans[cnt] ? this.textSpans[cnt].elem = commands : this.textSpans[cnt] = {
                                elem: commands
                            }, cnt += 1
                        }
                    }, CVTextElement.prototype.renderInnerContent = function() {
                        var i, len, j, jLen, k, kLen;
                        this.validateText(), this.canvasContext.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                        var renderedLetter, renderedLetters = this.textAnimator.renderedLetters,
                            letters = this.textProperty.currentData.l;
                        len = letters.length;
                        var commands, pathArr, lastFill = null,
                            lastStroke = null,
                            lastStrokeW = null,
                            renderer = this.globalData.renderer;
                        for (i = 0; i < len; i += 1)
                            if (!letters[i].n) {
                                if ((renderedLetter = renderedLetters[i]) && (renderer.save(), renderer.ctxTransform(renderedLetter.p), renderer.ctxOpacity(renderedLetter.o)), this.fill) {
                                    for (renderedLetter && renderedLetter.fc ? lastFill !== renderedLetter.fc && (renderer.ctxFillStyle(renderedLetter.fc), lastFill = renderedLetter.fc) : lastFill !== this.values.fill && (lastFill = this.values.fill, renderer.ctxFillStyle(this.values.fill)), jLen = (commands = this.textSpans[i].elem).length, this.globalData.canvasContext.beginPath(), j = 0; j < jLen; j += 1)
                                        for (kLen = (pathArr = commands[j]).length, this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]), k = 2; k < kLen; k += 6) this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                                    this.globalData.canvasContext.closePath(), renderer.ctxFill()
                                }
                                if (this.stroke) {
                                    for (renderedLetter && renderedLetter.sw ? lastStrokeW !== renderedLetter.sw && (lastStrokeW = renderedLetter.sw, renderer.ctxLineWidth(renderedLetter.sw)) : lastStrokeW !== this.values.sWidth && (lastStrokeW = this.values.sWidth, renderer.ctxLineWidth(this.values.sWidth)), renderedLetter && renderedLetter.sc ? lastStroke !== renderedLetter.sc && (lastStroke = renderedLetter.sc, renderer.ctxStrokeStyle(renderedLetter.sc)) : lastStroke !== this.values.stroke && (lastStroke = this.values.stroke, renderer.ctxStrokeStyle(this.values.stroke)), jLen = (commands = this.textSpans[i].elem).length, this.globalData.canvasContext.beginPath(), j = 0; j < jLen; j += 1)
                                        for (kLen = (pathArr = commands[j]).length, this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]), k = 2; k < kLen; k += 6) this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                                    this.globalData.canvasContext.closePath(), renderer.ctxStroke()
                                }
                                renderedLetter && this.globalData.renderer.restore()
                            }
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
                        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                            var canvas = createTag("canvas");
                            canvas.width = this.assetData.w, canvas.height = this.assetData.h;
                            var widthCrop, heightCrop, ctx = canvas.getContext("2d"),
                                imgW = this.img.width,
                                imgH = this.img.height,
                                imgRel = imgW / imgH,
                                canvasRel = this.assetData.w / this.assetData.h,
                                par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                            imgRel > canvasRel && "xMidYMid slice" === par || imgRel < canvasRel && "xMidYMid slice" !== par ? widthCrop = (heightCrop = imgH) * canvasRel : heightCrop = (widthCrop = imgW) / canvasRel, ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h), this.img = canvas
                        }
                    }, CVImageElement.prototype.renderInnerContent = function() {
                        this.canvasContext.drawImage(this.img, 0, 0)
                    }, CVImageElement.prototype.destroy = function() {
                        this.img = null
                    }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
                        this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
                    }, extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function(data) {
                        return new CVShapeElement(data, this.globalData, this)
                    }, CanvasRendererBase.prototype.createText = function(data) {
                        return new CVTextElement(data, this.globalData, this)
                    }, CanvasRendererBase.prototype.createImage = function(data) {
                        return new CVImageElement(data, this.globalData, this)
                    }, CanvasRendererBase.prototype.createSolid = function(data) {
                        return new CVSolidElement(data, this.globalData, this)
                    }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function(props) {
                        1 === props[0] && 0 === props[1] && 0 === props[4] && 1 === props[5] && 0 === props[12] && 0 === props[13] || this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13])
                    }, CanvasRendererBase.prototype.ctxOpacity = function(op) {
                        this.canvasContext.globalAlpha *= op < 0 ? 0 : op
                    }, CanvasRendererBase.prototype.ctxFillStyle = function(value) {
                        this.canvasContext.fillStyle = value
                    }, CanvasRendererBase.prototype.ctxStrokeStyle = function(value) {
                        this.canvasContext.strokeStyle = value
                    }, CanvasRendererBase.prototype.ctxLineWidth = function(value) {
                        this.canvasContext.lineWidth = value
                    }, CanvasRendererBase.prototype.ctxLineCap = function(value) {
                        this.canvasContext.lineCap = value
                    }, CanvasRendererBase.prototype.ctxLineJoin = function(value) {
                        this.canvasContext.lineJoin = value
                    }, CanvasRendererBase.prototype.ctxMiterLimit = function(value) {
                        this.canvasContext.miterLimit = value
                    }, CanvasRendererBase.prototype.ctxFill = function(rule) {
                        this.canvasContext.fill(rule)
                    }, CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {
                        this.canvasContext.fillRect(x, y, w, h)
                    }, CanvasRendererBase.prototype.ctxStroke = function() {
                        this.canvasContext.stroke()
                    }, CanvasRendererBase.prototype.reset = function() {
                        this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
                    }, CanvasRendererBase.prototype.save = function() {
                        this.canvasContext.save()
                    }, CanvasRendererBase.prototype.restore = function(actionFlag) {
                        this.renderConfig.clearCanvas ? (actionFlag && (this.globalData.blendMode = "source-over"), this.contextData.restore(actionFlag)) : this.canvasContext.restore()
                    }, CanvasRendererBase.prototype.configAnimation = function(animData) {
                        if (this.animationItem.wrapper) {
                            this.animationItem.container = createTag("canvas");
                            var containerStyle = this.animationItem.container.style;
                            containerStyle.width = "100%", containerStyle.height = "100%";
                            var origin = "0px 0px 0px";
                            containerStyle.transformOrigin = origin, containerStyle.mozTransformOrigin = origin, containerStyle.webkitTransformOrigin = origin, containerStyle["-webkit-transform"] = origin, containerStyle.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
                        } else this.canvasContext = this.renderConfig.context;
                        this.contextData.setContext(this.canvasContext), this.data = animData, this.layers = animData.layers, this.transformCanvas = {
                            w: animData.w,
                            h: animData.h,
                            sx: 0,
                            sy: 0,
                            tx: 0,
                            ty: 0
                        }, this.setupGlobalData(animData, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(animData.layers.length), this.updateContainerSize()
                    }, CanvasRendererBase.prototype.updateContainerSize = function(width, height) {
                        var elementWidth, elementHeight, elementRel, animationRel;
                        if (this.reset(), width ? (elementWidth = width, elementHeight = height, this.canvasContext.canvas.width = elementWidth, this.canvasContext.canvas.height = elementHeight) : (this.animationItem.wrapper && this.animationItem.container ? (elementWidth = this.animationItem.wrapper.offsetWidth, elementHeight = this.animationItem.wrapper.offsetHeight) : (elementWidth = this.canvasContext.canvas.width, elementHeight = this.canvasContext.canvas.height), this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr, this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
                            var par = this.renderConfig.preserveAspectRatio.split(" "),
                                fillType = par[1] || "meet",
                                pos = par[0] || "xMidYMid",
                                xPos = pos.substr(0, 4),
                                yPos = pos.substr(4);
                            elementRel = elementWidth / elementHeight, (animationRel = this.transformCanvas.w / this.transformCanvas.h) > elementRel && "meet" === fillType || animationRel < elementRel && "slice" === fillType ? (this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === xPos && (animationRel < elementRel && "meet" === fillType || animationRel > elementRel && "slice" === fillType) ? (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === xPos && (animationRel < elementRel && "meet" === fillType || animationRel > elementRel && "slice" === fillType) ? (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === yPos && (animationRel > elementRel && "meet" === fillType || animationRel < elementRel && "slice" === fillType) ? (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === yPos && (animationRel > elementRel && "meet" === fillType || animationRel < elementRel && "slice" === fillType) ? (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr : 0
                        } else "none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
                        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
                    }, CanvasRendererBase.prototype.destroy = function() {
                        var i;
                        for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), i = (this.layers ? this.layers.length : 0) - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
                        this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
                    }, CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
                        if ((this.renderedFrame !== num || !0 !== this.renderConfig.clearCanvas || forceRender) && !this.destroyed && -1 !== num) {
                            var i;
                            this.renderedFrame = num, this.globalData.frameNum = num - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender, this.globalData.projectInterface.currentFrame = num;
                            var len = this.layers.length;
                            for (this.completeLayers || this.checkLayers(num), i = len - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(num - this.layers[i].st);
                            if (this.globalData._mdf) {
                                for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), i = len - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame();
                                !0 !== this.renderConfig.clearCanvas && this.restore()
                            }
                        }
                    }, CanvasRendererBase.prototype.buildItem = function(pos) {
                        var elements = this.elements;
                        if (!elements[pos] && 99 !== this.layers[pos].ty) {
                            var element = this.createItem(this.layers[pos], this, this.globalData);
                            elements[pos] = element, element.initExpressions()
                        }
                    }, CanvasRendererBase.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                    }, CanvasRendererBase.prototype.hide = function() {
                        this.animationItem.container.style.display = "none"
                    }, CanvasRendererBase.prototype.show = function() {
                        this.animationItem.container.style.display = "block"
                    }, CVContextData.prototype.duplicate = function() {
                        var newLength = 2 * this._length,
                            i = 0;
                        for (i = this._length; i < newLength; i += 1) this.stack[i] = new CanvasContext;
                        this._length = newLength
                    }, CVContextData.prototype.reset = function() {
                        this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1
                    }, CVContextData.prototype.restore = function(forceRestore) {
                        this.cArrPos -= 1;
                        var i, currentContext = this.stack[this.cArrPos],
                            transform = currentContext.transform,
                            arr = this.cTr.props;
                        for (i = 0; i < 16; i += 1) arr[i] = transform[i];
                        if (forceRestore) {
                            this.nativeContext.restore();
                            var prevStack = this.stack[this.cArrPos + 1];
                            this.appliedFillStyle = prevStack.fillStyle, this.appliedStrokeStyle = prevStack.strokeStyle, this.appliedLineWidth = prevStack.lineWidth, this.appliedLineCap = prevStack.lineCap, this.appliedLineJoin = prevStack.lineJoin, this.appliedMiterLimit = prevStack.miterLimit
                        }
                        this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]), (forceRestore || -1 !== currentContext.opacity && this.currentOpacity !== currentContext.opacity) && (this.nativeContext.globalAlpha = currentContext.opacity, this.currentOpacity = currentContext.opacity), this.currentFillStyle = currentContext.fillStyle, this.currentStrokeStyle = currentContext.strokeStyle, this.currentLineWidth = currentContext.lineWidth, this.currentLineCap = currentContext.lineCap, this.currentLineJoin = currentContext.lineJoin, this.currentMiterLimit = currentContext.miterLimit
                    }, CVContextData.prototype.save = function(saveOnNativeFlag) {
                        saveOnNativeFlag && this.nativeContext.save();
                        var props = this.cTr.props;
                        this._length <= this.cArrPos && this.duplicate();
                        var i, currentStack = this.stack[this.cArrPos];
                        for (i = 0; i < 16; i += 1) currentStack.transform[i] = props[i];
                        this.cArrPos += 1;
                        var newStack = this.stack[this.cArrPos];
                        newStack.opacity = currentStack.opacity, newStack.fillStyle = currentStack.fillStyle, newStack.strokeStyle = currentStack.strokeStyle, newStack.lineWidth = currentStack.lineWidth, newStack.lineCap = currentStack.lineCap, newStack.lineJoin = currentStack.lineJoin, newStack.miterLimit = currentStack.miterLimit
                    }, CVContextData.prototype.setOpacity = function(value) {
                        this.stack[this.cArrPos].opacity = value
                    }, CVContextData.prototype.setContext = function(value) {
                        this.nativeContext = value
                    }, CVContextData.prototype.fillStyle = function(value) {
                        this.stack[this.cArrPos].fillStyle !== value && (this.currentFillStyle = value, this.stack[this.cArrPos].fillStyle = value)
                    }, CVContextData.prototype.strokeStyle = function(value) {
                        this.stack[this.cArrPos].strokeStyle !== value && (this.currentStrokeStyle = value, this.stack[this.cArrPos].strokeStyle = value)
                    }, CVContextData.prototype.lineWidth = function(value) {
                        this.stack[this.cArrPos].lineWidth !== value && (this.currentLineWidth = value, this.stack[this.cArrPos].lineWidth = value)
                    }, CVContextData.prototype.lineCap = function(value) {
                        this.stack[this.cArrPos].lineCap !== value && (this.currentLineCap = value, this.stack[this.cArrPos].lineCap = value)
                    }, CVContextData.prototype.lineJoin = function(value) {
                        this.stack[this.cArrPos].lineJoin !== value && (this.currentLineJoin = value, this.stack[this.cArrPos].lineJoin = value)
                    }, CVContextData.prototype.miterLimit = function(value) {
                        this.stack[this.cArrPos].miterLimit !== value && (this.currentMiterLimit = value, this.stack[this.cArrPos].miterLimit = value)
                    }, CVContextData.prototype.transform = function(props) {
                        this.transformMat.cloneFromProps(props);
                        var currentTransform = this.cTr;
                        this.transformMat.multiply(currentTransform), currentTransform.cloneFromProps(this.transformMat.props);
                        var trProps = currentTransform.props;
                        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13])
                    }, CVContextData.prototype.opacity = function(op) {
                        var currentOpacity = this.stack[this.cArrPos].opacity;
                        currentOpacity *= op < 0 ? 0 : op, this.stack[this.cArrPos].opacity !== currentOpacity && (this.currentOpacity !== op && (this.nativeContext.globalAlpha = op, this.currentOpacity = op), this.stack[this.cArrPos].opacity = currentOpacity)
                    }, CVContextData.prototype.fill = function(rule) {
                        this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(rule)
                    }, CVContextData.prototype.fillRect = function(x, y, w, h) {
                        this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(x, y, w, h)
                    }, CVContextData.prototype.stroke = function() {
                        this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke()
                    }, extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
                        var i, ctx = this.canvasContext;
                        for (ctx.beginPath(), ctx.moveTo(0, 0), ctx.lineTo(this.data.w, 0), ctx.lineTo(this.data.w, this.data.h), ctx.lineTo(0, this.data.h), ctx.lineTo(0, 0), ctx.clip(), i = this.layers.length - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                    }, CVCompElement.prototype.destroy = function() {
                        var i;
                        for (i = this.layers.length - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy();
                        this.layers = null, this.elements = null
                    }, CVCompElement.prototype.createComp = function(data) {
                        return new CVCompElement(data, this.globalData, this)
                    }, extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function(data) {
                        return new CVCompElement(data, this.globalData, this)
                    }, HBaseElement.prototype = {
                        checkBlendMode: function checkBlendMode() {},
                        initRendererElement: function initRendererElement() {
                            this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                        },
                        createContainerElements: function createContainerElements() {
                            this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
                        },
                        renderElement: function renderElement() {
                            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
                            if (this.finalTransform._matMdf) {
                                var matrixValue = this.finalTransform.mat.toCSS();
                                transformedElementStyle.transform = matrixValue, transformedElementStyle.webkitTransform = matrixValue
                            }
                            this.finalTransform._opMdf && (transformedElementStyle.opacity = this.finalTransform.mProp.o.v)
                        },
                        renderFrame: function renderFrame() {
                            this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                        },
                        destroy: function destroy() {
                            this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                        },
                        createRenderableComponents: function createRenderableComponents() {
                            this.maskManager = new MaskElement(this.data, this, this.globalData)
                        },
                        addEffects: function addEffects() {},
                        setMatte: function setMatte() {}
                    }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
                        var rect;
                        this.data.hasMask ? ((rect = createNS("rect")).setAttribute("width", this.data.sw), rect.setAttribute("height", this.data.sh), rect.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((rect = createTag("div")).style.width = this.data.sw + "px", rect.style.height = this.data.sh + "px", rect.style.backgroundColor = this.data.sc), this.layerElement.appendChild(rect)
                    }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
                        var cont;
                        if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), cont = this.svgElement;
                        else {
                            cont = createNS("svg");
                            var size = this.comp.data ? this.comp.data : this.globalData.compSize;
                            cont.setAttribute("width", size.w), cont.setAttribute("height", size.h), cont.appendChild(this.shapesContainer), this.layerElement.appendChild(cont)
                        }
                        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = cont
                    }, HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
                        var i, len = transformers.length;
                        for (i = 0; i < len; i += 1) point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
                        return point
                    }, HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
                        var i, vPoint, oPoint, nextIPoint, nextVPoint, shape = item.sh.v,
                            transformers = item.transformers,
                            len = shape._length;
                        if (!(len <= 1)) {
                            for (i = 0; i < len - 1; i += 1) vPoint = this.getTransformedPoint(transformers, shape.v[i]), oPoint = this.getTransformedPoint(transformers, shape.o[i]), nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]), nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]), this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
                            shape.c && (vPoint = this.getTransformedPoint(transformers, shape.v[i]), oPoint = this.getTransformedPoint(transformers, shape.o[i]), nextIPoint = this.getTransformedPoint(transformers, shape.i[0]), nextVPoint = this.getTransformedPoint(transformers, shape.v[0]), this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox))
                        }
                    }, HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
                        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
                        var bounds = this.shapeBoundingBox;
                        boundingBox.x = bmMin(bounds.left, boundingBox.x), boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax), boundingBox.y = bmMin(bounds.top, boundingBox.y), boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax)
                    }, HShapeElement.prototype.shapeBoundingBox = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, HShapeElement.prototype.tempBoundingBox = {
                        x: 0,
                        xMax: 0,
                        y: 0,
                        yMax: 0,
                        width: 0,
                        height: 0
                    }, HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
                        for (var a, b, c, t, b2ac, t1, t2, bounds = [
                                [p0[0], p3[0]],
                                [p0[1], p3[1]]
                            ], i = 0; i < 2; ++i) b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i], a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i], c = 3 * p1[i] - 3 * p0[i], b |= 0, c |= 0, 0 == (a |= 0) && 0 === b || (0 === a ? (t = -c / b) > 0 && t < 1 && bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i)) : (b2ac = b * b - 4 * c * a) >= 0 && ((t1 = (-b + bmSqrt(b2ac)) / (2 * a)) > 0 && t1 < 1 && bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i)), (t2 = (-b - bmSqrt(b2ac)) / (2 * a)) > 0 && t2 < 1 && bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i))));
                        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]), this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]), this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1])
                    }, HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
                        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i]
                    }, HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
                        var i, len = itemsData.length;
                        for (i = 0; i < len; i += 1) itemsData[i] && itemsData[i].sh ? this.calculateShapeBoundingBox(itemsData[i], boundingBox) : itemsData[i] && itemsData[i].it ? this.calculateBoundingBox(itemsData[i].it, boundingBox) : itemsData[i] && itemsData[i].style && itemsData[i].w && this.expandStrokeBoundingBox(itemsData[i].w, boundingBox)
                    }, HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
                        var width = 0;
                        if (widthProperty.keyframes) {
                            for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
                                var kfw = widthProperty.keyframes[i].s;
                                kfw > width && (width = kfw)
                            }
                            width *= widthProperty.mult
                        } else width = widthProperty.v * widthProperty.mult;
                        boundingBox.x -= width, boundingBox.xMax += width, boundingBox.y -= width, boundingBox.yMax += width
                    }, HShapeElement.prototype.currentBoxContains = function(box) {
                        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height
                    }, HShapeElement.prototype.renderInnerContent = function() {
                        if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                            var tempBoundingBox = this.tempBoundingBox,
                                max = 999999;
                            if (tempBoundingBox.x = max, tempBoundingBox.xMax = -max, tempBoundingBox.y = max, tempBoundingBox.yMax = -max, this.calculateBoundingBox(this.itemsData, tempBoundingBox), tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x, tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y, this.currentBoxContains(tempBoundingBox)) return;
                            var changed = !1;
                            if (this.currentBBox.w !== tempBoundingBox.width && (this.currentBBox.w = tempBoundingBox.width, this.shapeCont.setAttribute("width", tempBoundingBox.width), changed = !0), this.currentBBox.h !== tempBoundingBox.height && (this.currentBBox.h = tempBoundingBox.height, this.shapeCont.setAttribute("height", tempBoundingBox.height), changed = !0), changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
                                this.currentBBox.w = tempBoundingBox.width, this.currentBBox.h = tempBoundingBox.height, this.currentBBox.x = tempBoundingBox.x, this.currentBBox.y = tempBoundingBox.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                                var shapeStyle = this.shapeCont.style,
                                    shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                                shapeStyle.transform = shapeTransform, shapeStyle.webkitTransform = shapeTransform
                            }
                        }
                    }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
                        if (this.isMasked = this.checkMasks(), this.isMasked) {
                            this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                            var g = createNS("g");
                            this.maskedElement.appendChild(g), this.innerElem = g
                        } else this.renderType = "html", this.innerElem = this.layerElement;
                        this.checkParenting()
                    }, HTextElement.prototype.buildNewText = function() {
                        var documentData = this.textProperty.currentData;
                        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
                        var innerElemStyle = this.innerElem.style,
                            textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
                        innerElemStyle.fill = textColor, innerElemStyle.color = textColor, documentData.sc && (innerElemStyle.stroke = this.buildColor(documentData.sc), innerElemStyle.strokeWidth = documentData.sw + "px");
                        var i, len, fontData = this.globalData.fontManager.getFontByName(documentData.f);
                        if (!this.globalData.fontManager.chars)
                            if (innerElemStyle.fontSize = documentData.finalSize + "px", innerElemStyle.lineHeight = documentData.finalSize + "px", fontData.fClass) this.innerElem.className = fontData.fClass;
                            else {
                                innerElemStyle.fontFamily = fontData.fFamily;
                                var fWeight = documentData.fWeight,
                                    fStyle = documentData.fStyle;
                                innerElemStyle.fontStyle = fStyle, innerElemStyle.fontWeight = fWeight
                            } var tSpan, tParent, tCont, letters = documentData.l;
                        len = letters.length;
                        var shapes, matrixHelper = this.mHelper,
                            shapeStr = "",
                            cnt = 0;
                        for (i = 0; i < len; i += 1) {
                            if (this.globalData.fontManager.chars ? (this.textPaths[cnt] ? tSpan = this.textPaths[cnt] : ((tSpan = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]), tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]), tSpan.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[cnt] ? tCont = (tParent = this.textSpans[cnt]).children[0] : ((tParent = createTag("div")).style.lineHeight = 0, (tCont = createNS("svg")).appendChild(tSpan), styleDiv(tParent)))) : this.isMasked ? tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text") : this.textSpans[cnt] ? (tParent = this.textSpans[cnt], tSpan = this.textPaths[cnt]) : (styleDiv(tParent = createTag("span")), styleDiv(tSpan = createTag("span")), tParent.appendChild(tSpan)), this.globalData.fontManager.chars) {
                                var shapeData, charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                                if (shapeData = charData ? charData.data : null, matrixHelper.reset(), shapeData && shapeData.shapes && shapeData.shapes.length && (shapes = shapeData.shapes[0].it, matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100), shapeStr = this.createPathShape(matrixHelper, shapes), tSpan.setAttribute("d", shapeStr)), this.isMasked) this.innerElem.appendChild(tSpan);
                                else {
                                    if (this.innerElem.appendChild(tParent), shapeData && shapeData.shapes) {
                                        document.body.appendChild(tCont);
                                        var boundingBox = tCont.getBBox();
                                        tCont.setAttribute("width", boundingBox.width + 2), tCont.setAttribute("height", boundingBox.height + 2), tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                                        var tContStyle = tCont.style,
                                            tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                                        tContStyle.transform = tContTranslation, tContStyle.webkitTransform = tContTranslation, letters[i].yOffset = boundingBox.y - 1
                                    } else tCont.setAttribute("width", 1), tCont.setAttribute("height", 1);
                                    tParent.appendChild(tCont)
                                }
                            } else if (tSpan.textContent = letters[i].val, tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(tSpan);
                            else {
                                this.innerElem.appendChild(tParent);
                                var tStyle = tSpan.style,
                                    tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                                tStyle.transform = tSpanTranslation, tStyle.webkitTransform = tSpanTranslation
                            }
                            this.isMasked ? this.textSpans[cnt] = tSpan : this.textSpans[cnt] = tParent, this.textSpans[cnt].style.display = "block", this.textPaths[cnt] = tSpan, cnt += 1
                        }
                        for (; cnt < this.textSpans.length;) this.textSpans[cnt].style.display = "none", cnt += 1
                    }, HTextElement.prototype.renderInnerContent = function() {
                        var svgStyle;
                        if (this.validateText(), this.data.singleShape) {
                            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                            if (this.isMasked && this.finalTransform._matMdf) {
                                this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), svgStyle = this.svgElement.style;
                                var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                                svgStyle.transform = translation, svgStyle.webkitTransform = translation
                            }
                        }
                        if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                            var i, len, renderedLetter, textSpan, textPath, count = 0,
                                renderedLetters = this.textAnimator.renderedLetters,
                                letters = this.textProperty.currentData.l;
                            for (len = letters.length, i = 0; i < len; i += 1) letters[i].n ? count += 1 : (textSpan = this.textSpans[i], textPath = this.textPaths[i], renderedLetter = renderedLetters[count], count += 1, renderedLetter._mdf.m && (this.isMasked ? textSpan.setAttribute("transform", renderedLetter.m) : (textSpan.style.webkitTransform = renderedLetter.m, textSpan.style.transform = renderedLetter.m)), textSpan.style.opacity = renderedLetter.o, renderedLetter.sw && renderedLetter._mdf.sw && textPath.setAttribute("stroke-width", renderedLetter.sw), renderedLetter.sc && renderedLetter._mdf.sc && textPath.setAttribute("stroke", renderedLetter.sc), renderedLetter.fc && renderedLetter._mdf.fc && (textPath.setAttribute("fill", renderedLetter.fc), textPath.style.color = renderedLetter.fc));
                            if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                                var boundingBox = this.innerElem.getBBox();
                                if (this.currentBBox.w !== boundingBox.width && (this.currentBBox.w = boundingBox.width, this.svgElement.setAttribute("width", boundingBox.width)), this.currentBBox.h !== boundingBox.height && (this.currentBBox.h = boundingBox.height, this.svgElement.setAttribute("height", boundingBox.height)), this.currentBBox.w !== boundingBox.width + 2 || this.currentBBox.h !== boundingBox.height + 2 || this.currentBBox.x !== boundingBox.x - 1 || this.currentBBox.y !== boundingBox.y - 1) {
                                    this.currentBBox.w = boundingBox.width + 2, this.currentBBox.h = boundingBox.height + 2, this.currentBBox.x = boundingBox.x - 1, this.currentBBox.y = boundingBox.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), svgStyle = this.svgElement.style;
                                    var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                                    svgStyle.transform = svgTransform, svgStyle.webkitTransform = svgTransform
                                }
                            }
                        }
                    }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
                        var i, comp, perspectiveStyle, containerStyle, len = this.comp.threeDElements.length;
                        for (i = 0; i < len; i += 1)
                            if ("3d" === (comp = this.comp.threeDElements[i]).type) {
                                perspectiveStyle = comp.perspectiveElem.style, containerStyle = comp.container.style;
                                var perspective = this.pe.v + "px",
                                    matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                                perspectiveStyle.perspective = perspective, perspectiveStyle.webkitPerspective = perspective, containerStyle.transformOrigin = "0px 0px 0px", containerStyle.mozTransformOrigin = "0px 0px 0px", containerStyle.webkitTransformOrigin = "0px 0px 0px", perspectiveStyle.transform = matrix, perspectiveStyle.webkitTransform = matrix
                            }
                    }, HCameraElement.prototype.createElements = function() {}, HCameraElement.prototype.hide = function() {}, HCameraElement.prototype.renderFrame = function() {
                        var i, len, _mdf = this._isFirstFrame;
                        if (this.hierarchy)
                            for (len = this.hierarchy.length, i = 0; i < len; i += 1) _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
                        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                            if (this.mat.reset(), this.hierarchy)
                                for (i = len = this.hierarchy.length - 1; i >= 0; i -= 1) {
                                    var mTransf = this.hierarchy[i].finalTransform.mProp;
                                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]), this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]), this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v), this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]), this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2])
                                }
                            if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                                var diffVector;
                                diffVector = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                                var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)),
                                    lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag],
                                    lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]),
                                    mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ),
                                    mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
                                this.mat.rotateY(mRotationY).rotateX(-mRotationX)
                            }
                            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                            var hasMatrixChanged = !this._prevMat.equals(this.mat);
                            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
                                var comp, perspectiveStyle, containerStyle;
                                for (len = this.comp.threeDElements.length, i = 0; i < len; i += 1)
                                    if ("3d" === (comp = this.comp.threeDElements[i]).type) {
                                        if (hasMatrixChanged) {
                                            var matValue = this.mat.toCSS();
                                            (containerStyle = comp.container.style).transform = matValue, containerStyle.webkitTransform = matValue
                                        }
                                        this.pe._mdf && ((perspectiveStyle = comp.perspectiveElem.style).perspective = this.pe.v + "px", perspectiveStyle.webkitPerspective = this.pe.v + "px")
                                    } this.mat.clone(this._prevMat)
                            }
                        }
                        this._isFirstFrame = !1
                    }, HCameraElement.prototype.prepareFrame = function(num) {
                        this.prepareProperties(num, !0)
                    }, HCameraElement.prototype.destroy = function() {}, HCameraElement.prototype.getBaseElement = function() {
                        return null
                    }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
                        var assetPath = this.globalData.getAssetsPath(this.assetData),
                            img = new Image;
                        this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(img), img.crossOrigin = "anonymous", img.src = assetPath, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
                    }, extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function() {
                        for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                    }, HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
                        var newDOMElement = element.getBaseElement();
                        if (newDOMElement) {
                            var layer = this.layers[pos];
                            if (layer.ddd && this.supports3d) this.addTo3dContainer(newDOMElement, pos);
                            else if (this.threeDElements) this.addTo3dContainer(newDOMElement, pos);
                            else {
                                for (var nextDOMElement, nextLayer, i = 0; i < pos;) this.elements[i] && !0 !== this.elements[i] && this.elements[i].getBaseElement && (nextLayer = this.elements[i], nextDOMElement = (this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement()) || nextDOMElement), i += 1;
                                nextDOMElement ? layer.ddd && this.supports3d || this.layerElement.insertBefore(newDOMElement, nextDOMElement) : layer.ddd && this.supports3d || this.layerElement.appendChild(newDOMElement)
                            }
                        }
                    }, HybridRendererBase.prototype.createShape = function(data) {
                        return this.supports3d ? new HShapeElement(data, this.globalData, this) : new SVGShapeElement(data, this.globalData, this)
                    }, HybridRendererBase.prototype.createText = function(data) {
                        return this.supports3d ? new HTextElement(data, this.globalData, this) : new SVGTextLottieElement(data, this.globalData, this)
                    }, HybridRendererBase.prototype.createCamera = function(data) {
                        return this.camera = new HCameraElement(data, this.globalData, this), this.camera
                    }, HybridRendererBase.prototype.createImage = function(data) {
                        return this.supports3d ? new HImageElement(data, this.globalData, this) : new IImageElement(data, this.globalData, this)
                    }, HybridRendererBase.prototype.createSolid = function(data) {
                        return this.supports3d ? new HSolidElement(data, this.globalData, this) : new ISolidElement(data, this.globalData, this)
                    }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
                        for (var i = 0, len = this.threeDElements.length; i < len;) {
                            if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) return this.threeDElements[i].perspectiveElem;
                            i += 1
                        }
                        return null
                    }, HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
                        var style, containerStyle, perspectiveElem = createTag("div");
                        styleDiv(perspectiveElem);
                        var container = createTag("div");
                        if (styleDiv(container), "3d" === type) {
                            (style = perspectiveElem.style).width = this.globalData.compSize.w + "px", style.height = this.globalData.compSize.h + "px", style.webkitTransformOrigin = "50% 50%", style.mozTransformOrigin = "50% 50%", style.transformOrigin = "50% 50%";
                            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                            (containerStyle = container.style).transform = matrix, containerStyle.webkitTransform = matrix
                        }
                        perspectiveElem.appendChild(container);
                        var threeDContainerData = {
                            container: container,
                            perspectiveElem: perspectiveElem,
                            startPos: pos,
                            endPos: pos,
                            type: type
                        };
                        return this.threeDElements.push(threeDContainerData), threeDContainerData
                    }, HybridRendererBase.prototype.build3dContainers = function() {
                        var i, lastThreeDContainerData, len = this.layers.length,
                            currentContainer = "";
                        for (i = 0; i < len; i += 1) this.layers[i].ddd && 3 !== this.layers[i].ty ? ("3d" !== currentContainer && (currentContainer = "3d", lastThreeDContainerData = this.createThreeDContainer(i, "3d")), lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i)) : ("2d" !== currentContainer && (currentContainer = "2d", lastThreeDContainerData = this.createThreeDContainer(i, "2d")), lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i));
                        for (i = (len = this.threeDElements.length) - 1; i >= 0; i -= 1) this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem)
                    }, HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {
                        for (var i = 0, len = this.threeDElements.length; i < len;) {
                            if (pos <= this.threeDElements[i].endPos) {
                                for (var nextElement, j = this.threeDElements[i].startPos; j < pos;) this.elements[j] && this.elements[j].getBaseElement && (nextElement = this.elements[j].getBaseElement()), j += 1;
                                nextElement ? this.threeDElements[i].container.insertBefore(elem, nextElement) : this.threeDElements[i].container.appendChild(elem);
                                break
                            }
                            i += 1
                        }
                    }, HybridRendererBase.prototype.configAnimation = function(animData) {
                        var resizerElem = createTag("div"),
                            wrapper = this.animationItem.wrapper,
                            style = resizerElem.style;
                        style.width = animData.w + "px", style.height = animData.h + "px", this.resizerElem = resizerElem, styleDiv(resizerElem), style.transformStyle = "flat", style.mozTransformStyle = "flat", style.webkitTransformStyle = "flat", this.renderConfig.className && resizerElem.setAttribute("class", this.renderConfig.className), wrapper.appendChild(resizerElem), style.overflow = "hidden";
                        var svg = createNS("svg");
                        svg.setAttribute("width", "1"), svg.setAttribute("height", "1"), styleDiv(svg), this.resizerElem.appendChild(svg);
                        var defs = createNS("defs");
                        svg.appendChild(defs), this.data = animData, this.setupGlobalData(animData, svg), this.globalData.defs = defs, this.layers = animData.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
                    }, HybridRendererBase.prototype.destroy = function() {
                        var i;
                        this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                        var len = this.layers ? this.layers.length : 0;
                        for (i = 0; i < len; i += 1) this.elements[i] && this.elements[i].destroy && this.elements[i].destroy();
                        this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                    }, HybridRendererBase.prototype.updateContainerSize = function() {
                        var sx, sy, tx, ty, elementWidth = this.animationItem.wrapper.offsetWidth,
                            elementHeight = this.animationItem.wrapper.offsetHeight,
                            elementRel = elementWidth / elementHeight;
                        this.globalData.compSize.w / this.globalData.compSize.h > elementRel ? (sx = elementWidth / this.globalData.compSize.w, sy = elementWidth / this.globalData.compSize.w, tx = 0, ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2) : (sx = elementHeight / this.globalData.compSize.h, sy = elementHeight / this.globalData.compSize.h, tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2, ty = 0);
                        var style = this.resizerElem.style;
                        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)", style.transform = style.webkitTransform
                    }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function() {
                        this.resizerElem.style.display = "none"
                    }, HybridRendererBase.prototype.show = function() {
                        this.resizerElem.style.display = "block"
                    }, HybridRendererBase.prototype.initItems = function() {
                        if (this.buildAllItems(), this.camera) this.camera.setup();
                        else {
                            var i, cWidth = this.globalData.compSize.w,
                                cHeight = this.globalData.compSize.h,
                                len = this.threeDElements.length;
                            for (i = 0; i < len; i += 1) {
                                var style = this.threeDElements[i].perspectiveElem.style;
                                style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px", style.perspective = style.webkitPerspective
                            }
                        }
                    }, HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
                        var i, len = assets.length,
                            floatingContainer = createTag("div");
                        for (i = 0; i < len; i += 1)
                            if (assets[i].xt) {
                                var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
                                comp.initExpressions(), this.globalData.projectInterface.registerComposition(comp)
                            }
                    }, extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
                        this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
                    }, HCompElement.prototype.addTo3dContainer = function(elem, pos) {
                        for (var nextElement, j = 0; j < pos;) this.elements[j] && this.elements[j].getBaseElement && (nextElement = this.elements[j].getBaseElement()), j += 1;
                        nextElement ? this.layerElement.insertBefore(elem, nextElement) : this.layerElement.appendChild(elem)
                    }, HCompElement.prototype.createComp = function(data) {
                        return this.supports3d ? new HCompElement(data, this.globalData, this) : new SVGCompElement(data, this.globalData, this)
                    }, extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function(data) {
                        return this.supports3d ? new HCompElement(data, this.globalData, this) : new SVGCompElement(data, this.globalData, this)
                    };
                    var CompExpressionInterface = function(comp) {
                        function _thisLayerFunction(name) {
                            for (var i = 0, len = comp.layers.length; i < len;) {
                                if (comp.layers[i].nm === name || comp.layers[i].ind === name) return comp.elements[i].layerInterface;
                                i += 1
                            }
                            return null
                        }
                        return Object.defineProperty(_thisLayerFunction, "_name", {
                            value: comp.data.nm
                        }), _thisLayerFunction.layer = _thisLayerFunction, _thisLayerFunction.pixelAspect = 1, _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h, _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w, _thisLayerFunction.pixelAspect = 1, _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate, _thisLayerFunction.displayStartTime = 0, _thisLayerFunction.numLayers = comp.layers.length, _thisLayerFunction
                    };

                    function _typeof$2(obj) {
                        return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$2(obj)
                    }

                    function seedRandom(pool, math) {
                        var nodecrypto, global = this,
                            width = 256,
                            startdenom = math.pow(width, 6),
                            significance = math.pow(2, 52),
                            overflow = 2 * significance,
                            mask = width - 1;

                        function ARC4(key) {
                            var t, keylen = key.length,
                                me = this,
                                i = 0,
                                j = me.i = me.j = 0,
                                s = me.S = [];
                            for (keylen || (key = [keylen++]); i < width;) s[i] = i++;
                            for (i = 0; i < width; i++) s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])], s[j] = t;
                            me.g = function(count) {
                                for (var t, r = 0, i = me.i, j = me.j, s = me.S; count--;) t = s[i = mask & i + 1], r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
                                return me.i = i, me.j = j, r
                            }
                        }

                        function copy(f, t) {
                            return t.i = f.i, t.j = f.j, t.S = f.S.slice(), t
                        }

                        function flatten(obj, depth) {
                            var prop, result = [],
                                typ = _typeof$2(obj);
                            if (depth && "object" == typ)
                                for (prop in obj) try {
                                    result.push(flatten(obj[prop], depth - 1))
                                } catch (e) {}
                            return result.length ? result : "string" == typ ? obj : obj + "\0"
                        }

                        function mixkey(seed, key) {
                            for (var smear, stringseed = seed + "", j = 0; j < stringseed.length;) key[mask & j] = mask & (smear ^= 19 * key[mask & j]) + stringseed.charCodeAt(j++);
                            return tostring(key)
                        }

                        function tostring(a) {
                            return String.fromCharCode.apply(0, a)
                        }
                        math.seedrandom = function seedrandom(seed, options, callback) {
                            var key = [],
                                shortseed = mixkey(flatten((options = !0 === options ? {
                                    entropy: !0
                                } : options || {}).entropy ? [seed, tostring(pool)] : null === seed ? function autoseed() {
                                    try {
                                        if (nodecrypto) return tostring(nodecrypto.randomBytes(width));
                                        var out = new Uint8Array(width);
                                        return (global.crypto || global.msCrypto).getRandomValues(out), tostring(out)
                                    } catch (e) {
                                        var browser = global.navigator,
                                            plugins = browser && browser.plugins;
                                        return [+new Date, global, plugins, global.screen, tostring(pool)]
                                    }
                                }() : seed, 3), key),
                                arc4 = new ARC4(key),
                                prng = function prng() {
                                    for (var n = arc4.g(6), d = startdenom, x = 0; n < significance;) n = (n + x) * width, d *= width, x = arc4.g(1);
                                    for (; n >= overflow;) n /= 2, d /= 2, x >>>= 1;
                                    return (n + x) / d
                                };
                            return prng.int32 = function() {
                                return 0 | arc4.g(4)
                            }, prng.quick = function() {
                                return arc4.g(4) / 4294967296
                            }, prng.double = prng, mixkey(tostring(arc4.S), pool), (options.pass || callback || function(prng, seed, is_math_call, state) {
                                return state && (state.S && copy(state, arc4), prng.state = function() {
                                    return copy(arc4, {})
                                }), is_math_call ? (math.random = prng, seed) : prng
                            })(prng, shortseed, "global" in options ? options.global : this == math, options.state)
                        }, mixkey(math.random(), pool)
                    }

                    function initialize$2(BMMath) {
                        seedRandom([], BMMath)
                    }
                    var propTypes = {
                        SHAPE: "shape"
                    };

                    function _typeof$1(obj) {
                        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof$1(obj)
                    }
                    var ExpressionManager = function() {
                            var ob = {},
                                Math = BMMath,
                                window = null,
                                document = null,
                                XMLHttpRequest = null,
                                fetch = null,
                                frames = null,
                                _lottieGlobal = {};

                            function resetFrame() {
                                _lottieGlobal = {}
                            }

                            function $bm_isInstanceOfArray(arr) {
                                return arr.constructor === Array || arr.constructor === Float32Array
                            }

                            function isNumerable(tOfV, v) {
                                return "number" === tOfV || v instanceof Number || "boolean" === tOfV || "string" === tOfV
                            }

                            function $bm_neg(a) {
                                var tOfA = _typeof$1(a);
                                if ("number" === tOfA || a instanceof Number || "boolean" === tOfA) return -a;
                                if ($bm_isInstanceOfArray(a)) {
                                    var i, lenA = a.length,
                                        retArr = [];
                                    for (i = 0; i < lenA; i += 1) retArr[i] = -a[i];
                                    return retArr
                                }
                                return a.propType ? a.v : -a
                            }
                            initialize$2(BMMath);
                            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                                easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                                easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                            function sum(a, b) {
                                var tOfA = _typeof$1(a),
                                    tOfB = _typeof$1(b);
                                if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || "string" === tOfA || "string" === tOfB) return a + b;
                                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) return (a = a.slice(0))[0] += b, a;
                                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) return (b = b.slice(0))[0] = a + b[0], b;
                                if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                                    for (var i = 0, lenA = a.length, lenB = b.length, retArr = []; i < lenA || i < lenB;)("number" == typeof a[i] || a[i] instanceof Number) && ("number" == typeof b[i] || b[i] instanceof Number) ? retArr[i] = a[i] + b[i] : retArr[i] = void 0 === b[i] ? a[i] : a[i] || b[i], i += 1;
                                    return retArr
                                }
                                return 0
                            }
                            var add = sum;

                            function sub(a, b) {
                                var tOfA = _typeof$1(a),
                                    tOfB = _typeof$1(b);
                                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return "string" === tOfA && (a = parseInt(a, 10)), "string" === tOfB && (b = parseInt(b, 10)), a - b;
                                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) return (a = a.slice(0))[0] -= b, a;
                                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) return (b = b.slice(0))[0] = a - b[0], b;
                                if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                                    for (var i = 0, lenA = a.length, lenB = b.length, retArr = []; i < lenA || i < lenB;)("number" == typeof a[i] || a[i] instanceof Number) && ("number" == typeof b[i] || b[i] instanceof Number) ? retArr[i] = a[i] - b[i] : retArr[i] = void 0 === b[i] ? a[i] : a[i] || b[i], i += 1;
                                    return retArr
                                }
                                return 0
                            }

                            function mul(a, b) {
                                var arr, i, len, tOfA = _typeof$1(a),
                                    tOfB = _typeof$1(b);
                                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a * b;
                                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                                    for (len = a.length, arr = createTypedArray("float32", len), i = 0; i < len; i += 1) arr[i] = a[i] * b;
                                    return arr
                                }
                                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                                    for (len = b.length, arr = createTypedArray("float32", len), i = 0; i < len; i += 1) arr[i] = a * b[i];
                                    return arr
                                }
                                return 0
                            }

                            function div(a, b) {
                                var arr, i, len, tOfA = _typeof$1(a),
                                    tOfB = _typeof$1(b);
                                if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a / b;
                                if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                                    for (len = a.length, arr = createTypedArray("float32", len), i = 0; i < len; i += 1) arr[i] = a[i] / b;
                                    return arr
                                }
                                if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                                    for (len = b.length, arr = createTypedArray("float32", len), i = 0; i < len; i += 1) arr[i] = a / b[i];
                                    return arr
                                }
                                return 0
                            }

                            function mod(a, b) {
                                return "string" == typeof a && (a = parseInt(a, 10)), "string" == typeof b && (b = parseInt(b, 10)), a % b
                            }
                            var $bm_sum = sum,
                                $bm_sub = sub,
                                $bm_mul = mul,
                                $bm_div = div,
                                $bm_mod = mod;

                            function clamp(num, min, max) {
                                if (min > max) {
                                    var mm = max;
                                    max = min, min = mm
                                }
                                return Math.min(Math.max(num, min), max)
                            }

                            function radiansToDegrees(val) {
                                return val / degToRads
                            }
                            var radians_to_degrees = radiansToDegrees;

                            function degreesToRadians(val) {
                                return val * degToRads
                            }
                            var degrees_to_radians = radiansToDegrees,
                                helperLengthArray = [0, 0, 0, 0, 0, 0];

                            function length(arr1, arr2) {
                                if ("number" == typeof arr1 || arr1 instanceof Number) return arr2 = arr2 || 0, Math.abs(arr1 - arr2);
                                var i;
                                arr2 || (arr2 = helperLengthArray);
                                var len = Math.min(arr1.length, arr2.length),
                                    addedLength = 0;
                                for (i = 0; i < len; i += 1) addedLength += Math.pow(arr2[i] - arr1[i], 2);
                                return Math.sqrt(addedLength)
                            }

                            function normalize(vec) {
                                return div(vec, length(vec))
                            }

                            function rgbToHsl(val) {
                                var h, s, r = val[0],
                                    g = val[1],
                                    b = val[2],
                                    max = Math.max(r, g, b),
                                    min = Math.min(r, g, b),
                                    l = (max + min) / 2;
                                if (max === min) h = 0, s = 0;
                                else {
                                    var d = max - min;
                                    switch (s = l > .5 ? d / (2 - max - min) : d / (max + min), max) {
                                        case r:
                                            h = (g - b) / d + (g < b ? 6 : 0);
                                            break;
                                        case g:
                                            h = (b - r) / d + 2;
                                            break;
                                        case b:
                                            h = (r - g) / d + 4
                                    }
                                    h /= 6
                                }
                                return [h, s, l, val[3]]
                            }

                            function hue2rgb(p, q, t) {
                                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p
                            }

                            function hslToRgb(val) {
                                var r, g, b, h = val[0],
                                    s = val[1],
                                    l = val[2];
                                if (0 === s) r = l, b = l, g = l;
                                else {
                                    var q = l < .5 ? l * (1 + s) : l + s - l * s,
                                        p = 2 * l - q;
                                    r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3)
                                }
                                return [r, g, b, val[3]]
                            }

                            function linear(t, tMin, tMax, value1, value2) {
                                if (void 0 !== value1 && void 0 !== value2 || (value1 = tMin, value2 = tMax, tMin = 0, tMax = 1), tMax < tMin) {
                                    var _tMin = tMax;
                                    tMax = tMin, tMin = _tMin
                                }
                                if (t <= tMin) return value1;
                                if (t >= tMax) return value2;
                                var i, perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
                                if (!value1.length) return value1 + (value2 - value1) * perc;
                                var len = value1.length,
                                    arr = createTypedArray("float32", len);
                                for (i = 0; i < len; i += 1) arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
                                return arr
                            }

                            function random(min, max) {
                                if (void 0 === max && (void 0 === min ? (min = 0, max = 1) : (max = min, min = void 0)), max.length) {
                                    var i, len = max.length;
                                    min || (min = createTypedArray("float32", len));
                                    var arr = createTypedArray("float32", len),
                                        rnd = BMMath.random();
                                    for (i = 0; i < len; i += 1) arr[i] = min[i] + rnd * (max[i] - min[i]);
                                    return arr
                                }
                                return void 0 === min && (min = 0), min + BMMath.random() * (max - min)
                            }

                            function createPath(points, inTangents, outTangents, closed) {
                                var i, len = points.length,
                                    path = shapePool.newElement();
                                path.setPathData(!!closed, len);
                                var inVertexPoint, outVertexPoint, arrPlaceholder = [0, 0];
                                for (i = 0; i < len; i += 1) inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder, outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder, path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, !0);
                                return path
                            }

                            function initiateExpression(elem, data, property) {
                                function noOp(_value) {
                                    return _value
                                }
                                if (!elem.globalData.renderConfig.runExpressions) return noOp;
                                var val = data.x,
                                    needsVelocity = /velocity(?![\w\d])/.test(val),
                                    _needsRandom = -1 !== val.indexOf("random"),
                                    elemType = elem.data.ty,
                                    transform, $bm_transform, content, effect, thisProperty = property;
                                thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                                    get: function get() {
                                        return thisProperty.v
                                    }
                                }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                                var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                                    outPoint = elem.data.op / elem.comp.globalData.frameRate,
                                    width = elem.data.sw ? elem.data.sw : 0,
                                    height = elem.data.sh ? elem.data.sh : 0,
                                    name = elem.data.nm,
                                    loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                                    numKeys = property.kf ? data.k.length : 0,
                                    active = !this.data || !0 !== this.data.hd,
                                    wiggle = function wiggle(freq, amp) {
                                        var iWiggle, j, lenWiggle = this.pv.length ? this.pv.length : 1,
                                            addedAmps = createTypedArray("float32", lenWiggle),
                                            iterations = Math.floor(5 * time);
                                        for (iWiggle = 0, j = 0; iWiggle < iterations;) {
                                            for (j = 0; j < lenWiggle; j += 1) addedAmps[j] += -amp + 2 * amp * BMMath.random();
                                            iWiggle += 1
                                        }
                                        var periods = 5 * time,
                                            perc = periods - Math.floor(periods),
                                            arr = createTypedArray("float32", lenWiggle);
                                        if (lenWiggle > 1) {
                                            for (j = 0; j < lenWiggle; j += 1) arr[j] = this.pv[j] + addedAmps[j] + (-amp + 2 * amp * BMMath.random()) * perc;
                                            return arr
                                        }
                                        return this.pv + addedAmps[0] + (-amp + 2 * amp * BMMath.random()) * perc
                                    }.bind(this);

                                function loopInDuration(type, duration) {
                                    return loopIn(type, duration, !0)
                                }

                                function loopOutDuration(type, duration) {
                                    return loopOut(type, duration, !0)
                                }
                                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                                    time, velocity, value, text, textIndex, textTotal, selectorValue;

                                function lookAt(elem1, elem2) {
                                    var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]],
                                        pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
                                    return [-Math.atan2(fVec[1], fVec[2]) / degToRads, pitch, 0]
                                }

                                function easeOut(t, tMin, tMax, val1, val2) {
                                    return applyEase(easeOutBez, t, tMin, tMax, val1, val2)
                                }

                                function easeIn(t, tMin, tMax, val1, val2) {
                                    return applyEase(easeInBez, t, tMin, tMax, val1, val2)
                                }

                                function ease(t, tMin, tMax, val1, val2) {
                                    return applyEase(easeInOutBez, t, tMin, tMax, val1, val2)
                                }

                                function applyEase(fn, t, tMin, tMax, val1, val2) {
                                    void 0 === val1 ? (val1 = tMin, val2 = tMax) : t = (t - tMin) / (tMax - tMin), t > 1 ? t = 1 : t < 0 && (t = 0);
                                    var mult = fn(t);
                                    if ($bm_isInstanceOfArray(val1)) {
                                        var iKey, lenKey = val1.length,
                                            arr = createTypedArray("float32", lenKey);
                                        for (iKey = 0; iKey < lenKey; iKey += 1) arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                                        return arr
                                    }
                                    return (val2 - val1) * mult + val1
                                }

                                function nearestKey(time) {
                                    var iKey, index, keyTime, lenKey = data.k.length;
                                    if (data.k.length && "number" != typeof data.k[0])
                                        if (index = -1, (time *= elem.comp.globalData.frameRate) < data.k[0].t) index = 1, keyTime = data.k[0].t;
                                        else {
                                            for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                                                if (time === data.k[iKey].t) {
                                                    index = iKey + 1, keyTime = data.k[iKey].t;
                                                    break
                                                }
                                                if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                                                    time - data.k[iKey].t > data.k[iKey + 1].t - time ? (index = iKey + 2, keyTime = data.k[iKey + 1].t) : (index = iKey + 1, keyTime = data.k[iKey].t);
                                                    break
                                                }
                                            } - 1 === index && (index = iKey + 1, keyTime = data.k[iKey].t)
                                        }
                                    else index = 0, keyTime = 0;
                                    var obKey = {};
                                    return obKey.index = index, obKey.time = keyTime / elem.comp.globalData.frameRate, obKey
                                }

                                function key(ind) {
                                    var obKey, iKey, lenKey;
                                    if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + ind);
                                    ind -= 1, obKey = {
                                        time: data.k[ind].t / elem.comp.globalData.frameRate,
                                        value: []
                                    };
                                    var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
                                    for (lenKey = arr.length, iKey = 0; iKey < lenKey; iKey += 1) obKey[iKey] = arr[iKey], obKey.value[iKey] = arr[iKey];
                                    return obKey
                                }

                                function framesToTime(fr, fps) {
                                    return fps || (fps = elem.comp.globalData.frameRate), fr / fps
                                }

                                function timeToFrames(t, fps) {
                                    return t || 0 === t || (t = time), fps || (fps = elem.comp.globalData.frameRate), t * fps
                                }

                                function seedRandom(seed) {
                                    BMMath.seedrandom(randSeed + seed)
                                }

                                function sourceRectAtTime() {
                                    return elem.sourceRectAtTime()
                                }

                                function substring(init, end) {
                                    return "string" == typeof value ? void 0 === end ? value.substring(init) : value.substring(init, end) : ""
                                }

                                function substr(init, end) {
                                    return "string" == typeof value ? void 0 === end ? value.substr(init) : value.substr(init, end) : ""
                                }

                                function posterizeTime(framesPerSecond) {
                                    time = 0 === framesPerSecond ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond, value = valueAtTime(time)
                                }
                                var index = elem.data.ind,
                                    hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                                    parent, randSeed = Math.floor(1e6 * Math.random()),
                                    globalData = elem.globalData;

                                function executeExpression(_value) {
                                    return value = _value, this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt)
                                }
                                return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression
                            }
                            return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob
                        }(),
                        Expressions = function() {
                            var ob = {
                                initExpressions: function initExpressions(animation) {
                                    var stackCount = 0,
                                        registers = [];
                                    animation.renderer.compInterface = CompExpressionInterface(animation.renderer), animation.renderer.globalData.projectInterface.registerComposition(animation.renderer), animation.renderer.globalData.pushExpression = function pushExpression() {
                                        stackCount += 1
                                    }, animation.renderer.globalData.popExpression = function popExpression() {
                                        0 == (stackCount -= 1) && function releaseInstances() {
                                            var i, len = registers.length;
                                            for (i = 0; i < len; i += 1) registers[i].release();
                                            registers.length = 0
                                        }()
                                    }, animation.renderer.globalData.registerExpressionProperty = function registerExpressionProperty(expression) {
                                        -1 === registers.indexOf(expression) && registers.push(expression)
                                    }
                                }
                            };
                            return ob.resetFrame = ExpressionManager.resetFrame, ob
                        }(),
                        MaskManagerInterface = function() {
                            function MaskInterface(mask, data) {
                                this._mask = mask, this._data = data
                            }
                            return Object.defineProperty(MaskInterface.prototype, "maskPath", {
                                    get: function get() {
                                        return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                                    }
                                }), Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
                                    get: function get() {
                                        return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                                    }
                                }),
                                function MaskManager(maskManager) {
                                    var i, _masksInterfaces = createSizedArray(maskManager.viewData.length),
                                        len = maskManager.viewData.length;
                                    for (i = 0; i < len; i += 1) _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
                                    return function maskFunction(name) {
                                        for (i = 0; i < len;) {
                                            if (maskManager.masksProperties[i].nm === name) return _masksInterfaces[i];
                                            i += 1
                                        }
                                        return null
                                    }
                                }
                        }(),
                        ExpressionPropertyInterface = function() {
                            var defaultUnidimensionalValue = {
                                    pv: 0,
                                    v: 0,
                                    mult: 1
                                },
                                defaultMultidimensionalValue = {
                                    pv: [0, 0, 0],
                                    v: [0, 0, 0],
                                    mult: 1
                                };

                            function completeProperty(expressionValue, property, type) {
                                Object.defineProperty(expressionValue, "velocity", {
                                    get: function get() {
                                        return property.getVelocityAtTime(property.comp.currentFrame)
                                    }
                                }), expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0, expressionValue.key = function(pos) {
                                    if (!expressionValue.numKeys) return 0;
                                    var value = "";
                                    value = "s" in property.keyframes[pos - 1] ? property.keyframes[pos - 1].s : "e" in property.keyframes[pos - 2] ? property.keyframes[pos - 2].e : property.keyframes[pos - 2].s;
                                    var valueProp = "unidimensional" === type ? new Number(value) : Object.assign({}, value);
                                    return valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate, valueProp.value = "unidimensional" === type ? value[0] : value, valueProp
                                }, expressionValue.valueAtTime = property.getValueAtTime, expressionValue.speedAtTime = property.getSpeedAtTime, expressionValue.velocityAtTime = property.getVelocityAtTime, expressionValue.propertyGroup = property.propertyGroup
                            }

                            function defaultGetter() {
                                return defaultUnidimensionalValue
                            }
                            return function(property) {
                                return property ? "unidimensional" === property.propType ? function UnidimensionalPropertyInterface(property) {
                                    property && "pv" in property || (property = defaultUnidimensionalValue);
                                    var mult = 1 / property.mult,
                                        val = property.pv * mult,
                                        expressionValue = new Number(val);
                                    return expressionValue.value = val, completeProperty(expressionValue, property, "unidimensional"),
                                        function() {
                                            return property.k && property.getValue(), val = property.v * mult, expressionValue.value !== val && ((expressionValue = new Number(val)).value = val, completeProperty(expressionValue, property, "unidimensional")), expressionValue
                                        }
                                }(property) : function MultidimensionalPropertyInterface(property) {
                                    property && "pv" in property || (property = defaultMultidimensionalValue);
                                    var mult = 1 / property.mult,
                                        len = property.data && property.data.l || property.pv.length,
                                        expressionValue = createTypedArray("float32", len),
                                        arrValue = createTypedArray("float32", len);
                                    return expressionValue.value = arrValue, completeProperty(expressionValue, property, "multidimensional"),
                                        function() {
                                            property.k && property.getValue();
                                            for (var i = 0; i < len; i += 1) arrValue[i] = property.v[i] * mult, expressionValue[i] = arrValue[i];
                                            return expressionValue
                                        }
                                }(property) : defaultGetter
                            }
                        }(),
                        TransformExpressionInterface = function(transform) {
                            function _thisFunction(name) {
                                switch (name) {
                                    case "scale":
                                    case "Scale":
                                    case "ADBE Scale":
                                    case 6:
                                        return _thisFunction.scale;
                                    case "rotation":
                                    case "Rotation":
                                    case "ADBE Rotation":
                                    case "ADBE Rotate Z":
                                    case 10:
                                        return _thisFunction.rotation;
                                    case "ADBE Rotate X":
                                        return _thisFunction.xRotation;
                                    case "ADBE Rotate Y":
                                        return _thisFunction.yRotation;
                                    case "position":
                                    case "Position":
                                    case "ADBE Position":
                                    case 2:
                                        return _thisFunction.position;
                                    case "ADBE Position_0":
                                        return _thisFunction.xPosition;
                                    case "ADBE Position_1":
                                        return _thisFunction.yPosition;
                                    case "ADBE Position_2":
                                        return _thisFunction.zPosition;
                                    case "anchorPoint":
                                    case "AnchorPoint":
                                    case "Anchor Point":
                                    case "ADBE AnchorPoint":
                                    case 1:
                                        return _thisFunction.anchorPoint;
                                    case "opacity":
                                    case "Opacity":
                                    case 11:
                                        return _thisFunction.opacity;
                                    default:
                                        return null
                                }
                            }
                            var _px, _py, _pz, _transformFactory;
                            return Object.defineProperty(_thisFunction, "rotation", {
                                get: ExpressionPropertyInterface(transform.r || transform.rz)
                            }), Object.defineProperty(_thisFunction, "zRotation", {
                                get: ExpressionPropertyInterface(transform.rz || transform.r)
                            }), Object.defineProperty(_thisFunction, "xRotation", {
                                get: ExpressionPropertyInterface(transform.rx)
                            }), Object.defineProperty(_thisFunction, "yRotation", {
                                get: ExpressionPropertyInterface(transform.ry)
                            }), Object.defineProperty(_thisFunction, "scale", {
                                get: ExpressionPropertyInterface(transform.s)
                            }), transform.p ? _transformFactory = ExpressionPropertyInterface(transform.p) : (_px = ExpressionPropertyInterface(transform.px), _py = ExpressionPropertyInterface(transform.py), transform.pz && (_pz = ExpressionPropertyInterface(transform.pz))), Object.defineProperty(_thisFunction, "position", {
                                get: function get() {
                                    return transform.p ? _transformFactory() : [_px(), _py(), _pz ? _pz() : 0]
                                }
                            }), Object.defineProperty(_thisFunction, "xPosition", {
                                get: ExpressionPropertyInterface(transform.px)
                            }), Object.defineProperty(_thisFunction, "yPosition", {
                                get: ExpressionPropertyInterface(transform.py)
                            }), Object.defineProperty(_thisFunction, "zPosition", {
                                get: ExpressionPropertyInterface(transform.pz)
                            }), Object.defineProperty(_thisFunction, "anchorPoint", {
                                get: ExpressionPropertyInterface(transform.a)
                            }), Object.defineProperty(_thisFunction, "opacity", {
                                get: ExpressionPropertyInterface(transform.o)
                            }), Object.defineProperty(_thisFunction, "skew", {
                                get: ExpressionPropertyInterface(transform.sk)
                            }), Object.defineProperty(_thisFunction, "skewAxis", {
                                get: ExpressionPropertyInterface(transform.sa)
                            }), Object.defineProperty(_thisFunction, "orientation", {
                                get: ExpressionPropertyInterface(transform.or)
                            }), _thisFunction
                        },
                        LayerExpressionInterface = function() {
                            function getMatrix(time) {
                                var toWorldMat = new Matrix;
                                return void 0 !== time ? this._elem.finalTransform.mProp.getValueAtTime(time).clone(toWorldMat) : this._elem.finalTransform.mProp.applyToMatrix(toWorldMat), toWorldMat
                            }

                            function toWorldVec(arr, time) {
                                var toWorldMat = this.getMatrix(time);
                                return toWorldMat.props[12] = 0, toWorldMat.props[13] = 0, toWorldMat.props[14] = 0, this.applyPoint(toWorldMat, arr)
                            }

                            function toWorld(arr, time) {
                                var toWorldMat = this.getMatrix(time);
                                return this.applyPoint(toWorldMat, arr)
                            }

                            function fromWorldVec(arr, time) {
                                var toWorldMat = this.getMatrix(time);
                                return toWorldMat.props[12] = 0, toWorldMat.props[13] = 0, toWorldMat.props[14] = 0, this.invertPoint(toWorldMat, arr)
                            }

                            function fromWorld(arr, time) {
                                var toWorldMat = this.getMatrix(time);
                                return this.invertPoint(toWorldMat, arr)
                            }

                            function applyPoint(matrix, arr) {
                                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var i, len = this._elem.hierarchy.length;
                                    for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix)
                                }
                                return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0)
                            }

                            function invertPoint(matrix, arr) {
                                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var i, len = this._elem.hierarchy.length;
                                    for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix)
                                }
                                return matrix.inversePoint(arr)
                            }

                            function fromComp(arr) {
                                var toWorldMat = new Matrix;
                                if (toWorldMat.reset(), this._elem.finalTransform.mProp.applyToMatrix(toWorldMat), this._elem.hierarchy && this._elem.hierarchy.length) {
                                    var i, len = this._elem.hierarchy.length;
                                    for (i = 0; i < len; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                                    return toWorldMat.inversePoint(arr)
                                }
                                return toWorldMat.inversePoint(arr)
                            }

                            function sampleImage() {
                                return [1, 1, 1, 1]
                            }
                            return function(elem) {
                                var transformInterface;

                                function _thisLayerFunction(name) {
                                    switch (name) {
                                        case "ADBE Root Vectors Group":
                                        case "Contents":
                                        case 2:
                                            return _thisLayerFunction.shapeInterface;
                                        case 1:
                                        case 6:
                                        case "Transform":
                                        case "transform":
                                        case "ADBE Transform Group":
                                            return transformInterface;
                                        case 4:
                                        case "ADBE Effect Parade":
                                        case "effects":
                                        case "Effects":
                                            return _thisLayerFunction.effect;
                                        case "ADBE Text Properties":
                                            return _thisLayerFunction.textInterface;
                                        default:
                                            return null
                                    }
                                }
                                _thisLayerFunction.getMatrix = getMatrix, _thisLayerFunction.invertPoint = invertPoint, _thisLayerFunction.applyPoint = applyPoint, _thisLayerFunction.toWorld = toWorld, _thisLayerFunction.toWorldVec = toWorldVec, _thisLayerFunction.fromWorld = fromWorld, _thisLayerFunction.fromWorldVec = fromWorldVec, _thisLayerFunction.toComp = toWorld, _thisLayerFunction.fromComp = fromComp, _thisLayerFunction.sampleImage = sampleImage, _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem), _thisLayerFunction._elem = elem;
                                var anchorPointDescriptor = getDescriptor(transformInterface = TransformExpressionInterface(elem.finalTransform.mProp), "anchorPoint");
                                return Object.defineProperties(_thisLayerFunction, {
                                    hasParent: {
                                        get: function get() {
                                            return elem.hierarchy.length
                                        }
                                    },
                                    parent: {
                                        get: function get() {
                                            return elem.hierarchy[0].layerInterface
                                        }
                                    },
                                    rotation: getDescriptor(transformInterface, "rotation"),
                                    scale: getDescriptor(transformInterface, "scale"),
                                    position: getDescriptor(transformInterface, "position"),
                                    opacity: getDescriptor(transformInterface, "opacity"),
                                    anchorPoint: anchorPointDescriptor,
                                    anchor_point: anchorPointDescriptor,
                                    transform: {
                                        get: function get() {
                                            return transformInterface
                                        }
                                    },
                                    active: {
                                        get: function get() {
                                            return elem.isInRange
                                        }
                                    }
                                }), _thisLayerFunction.startTime = elem.data.st, _thisLayerFunction.index = elem.data.ind, _thisLayerFunction.source = elem.data.refId, _thisLayerFunction.height = 0 === elem.data.ty ? elem.data.h : 100, _thisLayerFunction.width = 0 === elem.data.ty ? elem.data.w : 100, _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate, _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate, _thisLayerFunction._name = elem.data.nm, _thisLayerFunction.registerMaskInterface = function _registerMaskInterface(maskManager) {
                                    _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem)
                                }, _thisLayerFunction.registerEffectsInterface = function _registerEffectsInterface(effects) {
                                    _thisLayerFunction.effect = effects
                                }, _thisLayerFunction
                            }
                        }(),
                        propertyGroupFactory = function(interfaceFunction, parentPropertyGroup) {
                            return function(val) {
                                return (val = void 0 === val ? 1 : val) <= 0 ? interfaceFunction : parentPropertyGroup(val - 1)
                            }
                        },
                        PropertyInterface = function(propertyName, propertyGroup) {
                            var interfaceFunction = {
                                _name: propertyName
                            };
                            return function _propertyGroup(val) {
                                return (val = void 0 === val ? 1 : val) <= 0 ? interfaceFunction : propertyGroup(val - 1)
                            }
                        },
                        EffectsExpressionInterface = function() {
                            function createGroupInterface(data, elements, propertyGroup, elem) {
                                function groupInterface(name) {
                                    for (var effects = data.ef, i = 0, len = effects.length; i < len;) {
                                        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) return 5 === effects[i].ty ? effectElements[i] : effectElements[i]();
                                        i += 1
                                    }
                                    throw new Error
                                }
                                var i, _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup),
                                    effectElements = [],
                                    len = data.ef.length;
                                for (i = 0; i < len; i += 1) 5 === data.ef[i].ty ? effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem)) : effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
                                return "ADBE Color Control" === data.mn && Object.defineProperty(groupInterface, "color", {
                                    get: function get() {
                                        return effectElements[0]()
                                    }
                                }), Object.defineProperties(groupInterface, {
                                    numProperties: {
                                        get: function get() {
                                            return data.np
                                        }
                                    },
                                    _name: {
                                        value: data.nm
                                    },
                                    propertyGroup: {
                                        value: _propertyGroup
                                    }
                                }), groupInterface.enabled = 0 !== data.en, groupInterface.active = groupInterface.enabled, groupInterface
                            }

                            function createValueInterface(element, type, elem, propertyGroup) {
                                var expressionProperty = ExpressionPropertyInterface(element.p);
                                return element.p.setGroupProperty && element.p.setGroupProperty(PropertyInterface("", propertyGroup)),
                                    function interfaceFunction() {
                                        return 10 === type ? elem.comp.compInterface(element.p.v) : expressionProperty()
                                    }
                            }
                            return {
                                createEffectsInterface: function createEffectsInterface(elem, propertyGroup) {
                                    if (elem.effectsManager) {
                                        var i, effectElements = [],
                                            effectsData = elem.data.ef,
                                            len = elem.effectsManager.effectElements.length;
                                        for (i = 0; i < len; i += 1) effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
                                        var effects = elem.data.ef || [],
                                            groupInterface = function groupInterface(name) {
                                                for (i = 0, len = effects.length; i < len;) {
                                                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) return effectElements[i];
                                                    i += 1
                                                }
                                                return null
                                            };
                                        return Object.defineProperty(groupInterface, "numProperties", {
                                            get: function get() {
                                                return effects.length
                                            }
                                        }), groupInterface
                                    }
                                    return null
                                }
                            }
                        }(),
                        ShapePathInterface = function pathInterfaceFactory(shape, view, propertyGroup) {
                            var prop = view.sh;

                            function interfaceFunction(val) {
                                return "Shape" === val || "shape" === val || "Path" === val || "path" === val || "ADBE Vector Shape" === val || 2 === val ? interfaceFunction.path : null
                            }
                            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                            return prop.setGroupProperty(PropertyInterface("Path", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                path: {
                                    get: function get() {
                                        return prop.k && prop.getValue(), prop
                                    }
                                },
                                shape: {
                                    get: function get() {
                                        return prop.k && prop.getValue(), prop
                                    }
                                },
                                _name: {
                                    value: shape.nm
                                },
                                ix: {
                                    value: shape.ix
                                },
                                propertyIndex: {
                                    value: shape.ix
                                },
                                mn: {
                                    value: shape.mn
                                },
                                propertyGroup: {
                                    value: propertyGroup
                                }
                            }), interfaceFunction
                        },
                        ShapeExpressionInterface = function() {
                            function iterateElements(shapes, view, propertyGroup) {
                                var i, arr = [],
                                    len = shapes ? shapes.length : 0;
                                for (i = 0; i < len; i += 1) "gr" === shapes[i].ty ? arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup)) : "fl" === shapes[i].ty ? arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup)) : "st" === shapes[i].ty ? arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup)) : "tm" === shapes[i].ty ? arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup)) : "tr" === shapes[i].ty || ("el" === shapes[i].ty ? arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup)) : "sr" === shapes[i].ty ? arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup)) : "sh" === shapes[i].ty ? arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup)) : "rc" === shapes[i].ty ? arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup)) : "rd" === shapes[i].ty ? arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup)) : "rp" === shapes[i].ty ? arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup)) : "gf" === shapes[i].ty ? arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup)) : arr.push((shapes[i], view[i], function interfaceFunction() {
                                    return null
                                })));
                                return arr
                            }

                            function groupInterfaceFactory(shape, view, propertyGroup) {
                                var interfaceFunction = function _interfaceFunction(value) {
                                    switch (value) {
                                        case "ADBE Vectors Group":
                                        case "Contents":
                                        case 2:
                                            return interfaceFunction.content;
                                        default:
                                            return interfaceFunction.transform
                                    }
                                };
                                interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                                var content = function contentsInterfaceFactory(shape, view, propertyGroup) {
                                        var interfaces, interfaceFunction = function _interfaceFunction(value) {
                                            for (var i = 0, len = interfaces.length; i < len;) {
                                                if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) return interfaces[i];
                                                i += 1
                                            }
                                            return "number" == typeof value ? interfaces[value - 1] : null
                                        };
                                        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup), interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup), interfaceFunction.numProperties = interfaces.length;
                                        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                                        return interfaceFunction.transform = transformInterface, interfaceFunction.propertyIndex = shape.cix, interfaceFunction._name = shape.nm, interfaceFunction
                                    }(shape, view, interfaceFunction.propertyGroup),
                                    transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
                                return interfaceFunction.content = content, interfaceFunction.transform = transformInterface, Object.defineProperty(interfaceFunction, "_name", {
                                    get: function get() {
                                        return shape.nm
                                    }
                                }), interfaceFunction.numProperties = shape.np, interfaceFunction.propertyIndex = shape.ix, interfaceFunction.nm = shape.nm, interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function fillInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(val) {
                                    return "Color" === val || "color" === val ? interfaceFunction.color : "Opacity" === val || "opacity" === val ? interfaceFunction.opacity : null
                                }
                                return Object.defineProperties(interfaceFunction, {
                                    color: {
                                        get: ExpressionPropertyInterface(view.c)
                                    },
                                    opacity: {
                                        get: ExpressionPropertyInterface(view.o)
                                    },
                                    _name: {
                                        value: shape.nm
                                    },
                                    mn: {
                                        value: shape.mn
                                    }
                                }), view.c.setGroupProperty(PropertyInterface("Color", propertyGroup)), view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup)), interfaceFunction
                            }

                            function gradientFillInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(val) {
                                    return "Start Point" === val || "start point" === val ? interfaceFunction.startPoint : "End Point" === val || "end point" === val ? interfaceFunction.endPoint : "Opacity" === val || "opacity" === val ? interfaceFunction.opacity : null
                                }
                                return Object.defineProperties(interfaceFunction, {
                                    startPoint: {
                                        get: ExpressionPropertyInterface(view.s)
                                    },
                                    endPoint: {
                                        get: ExpressionPropertyInterface(view.e)
                                    },
                                    opacity: {
                                        get: ExpressionPropertyInterface(view.o)
                                    },
                                    type: {
                                        get: function get() {
                                            return "a"
                                        }
                                    },
                                    _name: {
                                        value: shape.nm
                                    },
                                    mn: {
                                        value: shape.mn
                                    }
                                }), view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup)), view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup)), view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup)), interfaceFunction
                            }

                            function strokeInterfaceFactory(shape, view, propertyGroup) {
                                var i, _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup),
                                    _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);

                                function addPropertyToDashOb(i) {
                                    Object.defineProperty(dashOb, shape.d[i].nm, {
                                        get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                                    })
                                }
                                var len = shape.d ? shape.d.length : 0,
                                    dashOb = {};
                                for (i = 0; i < len; i += 1) addPropertyToDashOb(i), view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);

                                function interfaceFunction(val) {
                                    return "Color" === val || "color" === val ? interfaceFunction.color : "Opacity" === val || "opacity" === val ? interfaceFunction.opacity : "Stroke Width" === val || "stroke width" === val ? interfaceFunction.strokeWidth : null
                                }
                                return Object.defineProperties(interfaceFunction, {
                                    color: {
                                        get: ExpressionPropertyInterface(view.c)
                                    },
                                    opacity: {
                                        get: ExpressionPropertyInterface(view.o)
                                    },
                                    strokeWidth: {
                                        get: ExpressionPropertyInterface(view.w)
                                    },
                                    dash: {
                                        get: function get() {
                                            return dashOb
                                        }
                                    },
                                    _name: {
                                        value: shape.nm
                                    },
                                    mn: {
                                        value: shape.mn
                                    }
                                }), view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup)), view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup)), view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup)), interfaceFunction
                            }

                            function trimInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(val) {
                                    return val === shape.e.ix || "End" === val || "end" === val ? interfaceFunction.end : val === shape.s.ix ? interfaceFunction.start : val === shape.o.ix ? interfaceFunction.offset : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                                return interfaceFunction.propertyIndex = shape.ix, view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup)), view.e.setGroupProperty(PropertyInterface("End", _propertyGroup)), view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup)), interfaceFunction.propertyIndex = shape.ix, interfaceFunction.propertyGroup = propertyGroup, Object.defineProperties(interfaceFunction, {
                                    start: {
                                        get: ExpressionPropertyInterface(view.s)
                                    },
                                    end: {
                                        get: ExpressionPropertyInterface(view.e)
                                    },
                                    offset: {
                                        get: ExpressionPropertyInterface(view.o)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function transformInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.a.ix === value || "Anchor Point" === value ? interfaceFunction.anchorPoint : shape.o.ix === value || "Opacity" === value ? interfaceFunction.opacity : shape.p.ix === value || "Position" === value ? interfaceFunction.position : shape.r.ix === value || "Rotation" === value || "ADBE Vector Rotation" === value ? interfaceFunction.rotation : shape.s.ix === value || "Scale" === value ? interfaceFunction.scale : shape.sk && shape.sk.ix === value || "Skew" === value ? interfaceFunction.skew : shape.sa && shape.sa.ix === value || "Skew Axis" === value ? interfaceFunction.skewAxis : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                                return view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup)), view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup)), view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup)), view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup)), view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup)), view.transform.mProps.sk && (view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup)), view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup))), view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                    opacity: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.o)
                                    },
                                    position: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.p)
                                    },
                                    anchorPoint: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.a)
                                    },
                                    scale: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.s)
                                    },
                                    rotation: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.r)
                                    },
                                    skew: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.sk)
                                    },
                                    skewAxis: {
                                        get: ExpressionPropertyInterface(view.transform.mProps.sa)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.ty = "tr", interfaceFunction.mn = shape.mn, interfaceFunction.propertyGroup = propertyGroup, interfaceFunction
                            }

                            function ellipseInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.p.ix === value ? interfaceFunction.position : shape.s.ix === value ? interfaceFunction.size : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
                                interfaceFunction.propertyIndex = shape.ix;
                                var prop = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                                return prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup)), prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                    size: {
                                        get: ExpressionPropertyInterface(prop.s)
                                    },
                                    position: {
                                        get: ExpressionPropertyInterface(prop.p)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function starInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.p.ix === value ? interfaceFunction.position : shape.r.ix === value ? interfaceFunction.rotation : shape.pt.ix === value ? interfaceFunction.points : shape.or.ix === value || "ADBE Vector Star Outer Radius" === value ? interfaceFunction.outerRadius : shape.os.ix === value ? interfaceFunction.outerRoundness : !shape.ir || shape.ir.ix !== value && "ADBE Vector Star Inner Radius" !== value ? shape.is && shape.is.ix === value ? interfaceFunction.innerRoundness : null : interfaceFunction.innerRadius
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup),
                                    prop = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                                return interfaceFunction.propertyIndex = shape.ix, prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup)), prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup)), prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup)), prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup)), prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup)), shape.ir && (prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup)), prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup))), Object.defineProperties(interfaceFunction, {
                                    position: {
                                        get: ExpressionPropertyInterface(prop.p)
                                    },
                                    rotation: {
                                        get: ExpressionPropertyInterface(prop.r)
                                    },
                                    points: {
                                        get: ExpressionPropertyInterface(prop.pt)
                                    },
                                    outerRadius: {
                                        get: ExpressionPropertyInterface(prop.or)
                                    },
                                    outerRoundness: {
                                        get: ExpressionPropertyInterface(prop.os)
                                    },
                                    innerRadius: {
                                        get: ExpressionPropertyInterface(prop.ir)
                                    },
                                    innerRoundness: {
                                        get: ExpressionPropertyInterface(prop.is)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function rectInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.p.ix === value ? interfaceFunction.position : shape.r.ix === value ? interfaceFunction.roundness : shape.s.ix === value || "Size" === value || "ADBE Vector Rect Size" === value ? interfaceFunction.size : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup),
                                    prop = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                                return interfaceFunction.propertyIndex = shape.ix, prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup)), prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup)), prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                    position: {
                                        get: ExpressionPropertyInterface(prop.p)
                                    },
                                    roundness: {
                                        get: ExpressionPropertyInterface(prop.r)
                                    },
                                    size: {
                                        get: ExpressionPropertyInterface(prop.s)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function roundedInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.r.ix === value || "Round Corners 1" === value ? interfaceFunction.radius : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup),
                                    prop = view;
                                return interfaceFunction.propertyIndex = shape.ix, prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                    radius: {
                                        get: ExpressionPropertyInterface(prop.rd)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }

                            function repeaterInterfaceFactory(shape, view, propertyGroup) {
                                function interfaceFunction(value) {
                                    return shape.c.ix === value || "Copies" === value ? interfaceFunction.copies : shape.o.ix === value || "Offset" === value ? interfaceFunction.offset : null
                                }
                                var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup),
                                    prop = view;
                                return interfaceFunction.propertyIndex = shape.ix, prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup)), prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup)), Object.defineProperties(interfaceFunction, {
                                    copies: {
                                        get: ExpressionPropertyInterface(prop.c)
                                    },
                                    offset: {
                                        get: ExpressionPropertyInterface(prop.o)
                                    },
                                    _name: {
                                        value: shape.nm
                                    }
                                }), interfaceFunction.mn = shape.mn, interfaceFunction
                            }
                            return function(shapes, view, propertyGroup) {
                                var interfaces;

                                function _interfaceFunction(value) {
                                    if ("number" == typeof value) return 0 === (value = void 0 === value ? 1 : value) ? propertyGroup : interfaces[value - 1];
                                    for (var i = 0, len = interfaces.length; i < len;) {
                                        if (interfaces[i]._name === value) return interfaces[i];
                                        i += 1
                                    }
                                    return null
                                }
                                return _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, (function parentGroupWrapper() {
                                    return propertyGroup
                                })), interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup), _interfaceFunction.numProperties = interfaces.length, _interfaceFunction._name = "Contents", _interfaceFunction
                            }
                        }(),
                        TextExpressionInterface = function(elem) {
                            var _sourceText;

                            function _thisLayerFunction(name) {
                                return "ADBE Text Document" === name ? _thisLayerFunction.sourceText : null
                            }
                            return Object.defineProperty(_thisLayerFunction, "sourceText", {
                                get: function get() {
                                    elem.textProperty.getValue();
                                    var stringValue = elem.textProperty.currentData.t;
                                    return _sourceText && stringValue === _sourceText.value || ((_sourceText = new String(stringValue)).value = stringValue || new String(stringValue), Object.defineProperty(_sourceText, "style", {
                                        get: function get() {
                                            return {
                                                fillColor: elem.textProperty.currentData.fc
                                            }
                                        }
                                    })), _sourceText
                                }
                            }), _thisLayerFunction
                        };

                    function _typeof(obj) {
                        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
                            return typeof obj
                        } : function _typeof(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        }, _typeof(obj)
                    }
                    var FootageInterface = (dataInterfaceFactory = function dataInterfaceFactory(elem) {
                            function interfaceFunction(value) {
                                return "Outline" === value ? interfaceFunction.outlineInterface() : null
                            }
                            return interfaceFunction._name = "Outline", interfaceFunction.outlineInterface = function outlineInterfaceFactory(elem) {
                                var currentPropertyName = "",
                                    currentProperty = elem.getFootageData();

                                function searchProperty(value) {
                                    if (currentProperty[value]) return currentPropertyName = value, "object" === _typeof(currentProperty = currentProperty[value]) ? searchProperty : currentProperty;
                                    var propertyNameIndex = value.indexOf(currentPropertyName);
                                    if (-1 !== propertyNameIndex) {
                                        var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
                                        return "object" === _typeof(currentProperty = currentProperty[index]) ? searchProperty : currentProperty
                                    }
                                    return ""
                                }
                                return function init() {
                                    return currentPropertyName = "", currentProperty = elem.getFootageData(), searchProperty
                                }
                            }(elem), interfaceFunction
                        }, function(elem) {
                            function _interfaceFunction(value) {
                                return "Data" === value ? _interfaceFunction.dataInterface : null
                            }
                            return _interfaceFunction._name = "Data", _interfaceFunction.dataInterface = dataInterfaceFactory(elem), _interfaceFunction
                        }),
                        dataInterfaceFactory, interfaces = {
                            layer: LayerExpressionInterface,
                            effects: EffectsExpressionInterface,
                            comp: CompExpressionInterface,
                            shape: ShapeExpressionInterface,
                            text: TextExpressionInterface,
                            footage: FootageInterface
                        };

                    function getInterface(type) {
                        return interfaces[type] || null
                    }
                    var expressionHelpers = {
                        searchExpressions: function searchExpressions(elem, data, prop) {
                            data.x && (prop.k = !0, prop.x = !0, prop.initiateExpression = ExpressionManager.initiateExpression, prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop)))
                        },
                        getSpeedAtTime: function getSpeedAtTime(frameNum) {
                            var v1 = this.getValueAtTime(frameNum),
                                v2 = this.getValueAtTime(frameNum + -.01),
                                speed = 0;
                            if (v1.length) {
                                var i;
                                for (i = 0; i < v1.length; i += 1) speed += Math.pow(v2[i] - v1[i], 2);
                                speed = 100 * Math.sqrt(speed)
                            } else speed = 0;
                            return speed
                        },
                        getVelocityAtTime: function getVelocityAtTime(frameNum) {
                            if (void 0 !== this.vel) return this.vel;
                            var velocity, i, v1 = this.getValueAtTime(frameNum),
                                v2 = this.getValueAtTime(frameNum + -.001);
                            if (v1.length)
                                for (velocity = createTypedArray("float32", v1.length), i = 0; i < v1.length; i += 1) velocity[i] = (v2[i] - v1[i]) / -.001;
                            else velocity = (v2 - v1) / -.001;
                            return velocity
                        },
                        getValueAtTime: function getValueAtTime(frameNum) {
                            return frameNum *= this.elem.globalData.frameRate, (frameNum -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime), this._cachingAtTime.lastFrame = frameNum), this._cachingAtTime.value
                        },
                        getStaticValueAtTime: function getStaticValueAtTime() {
                            return this.pv
                        },
                        setGroupProperty: function setGroupProperty(propertyGroup) {
                            this.propertyGroup = propertyGroup
                        }
                    };

                    function addPropertyDecorator() {
                        function loopOut(type, duration, durationFlag) {
                            if (!this.k || !this.keyframes) return this.pv;
                            type = type ? type.toLowerCase() : "";
                            var cycleDuration, firstKeyFrame, i, len, ret, currentFrame = this.comp.renderedFrame,
                                keyframes = this.keyframes,
                                lastKeyFrame = keyframes[keyframes.length - 1].t;
                            if (currentFrame <= lastKeyFrame) return this.pv;
                            if (durationFlag ? firstKeyFrame = lastKeyFrame - (cycleDuration = duration ? Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration) : Math.max(0, lastKeyFrame - this.elem.data.ip)) : ((!duration || duration > keyframes.length - 1) && (duration = keyframes.length - 1), cycleDuration = lastKeyFrame - (firstKeyFrame = keyframes[keyframes.length - 1 - duration].t)), "pingpong" === type) {
                                if (Math.floor((currentFrame - firstKeyFrame) / cycleDuration) % 2 != 0) return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0)
                            } else {
                                if ("offset" === type) {
                                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0),
                                        endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0),
                                        current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0),
                                        repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                                    if (this.pv.length) {
                                        for (len = (ret = new Array(initV.length)).length, i = 0; i < len; i += 1) ret[i] = (endV[i] - initV[i]) * repeats + current[i];
                                        return ret
                                    }
                                    return (endV - initV) * repeats + current
                                }
                                if ("continue" === type) {
                                    var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0),
                                        nextLastValue = this.getValueAtTime((lastKeyFrame - .001) / this.comp.globalData.frameRate, 0);
                                    if (this.pv.length) {
                                        for (len = (ret = new Array(lastValue.length)).length, i = 0; i < len; i += 1) ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
                                        return ret
                                    }
                                    return lastValue + (currentFrame - lastKeyFrame) / .001 * (lastValue - nextLastValue)
                                }
                            }
                            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0)
                        }

                        function loopIn(type, duration, durationFlag) {
                            if (!this.k) return this.pv;
                            type = type ? type.toLowerCase() : "";
                            var cycleDuration, lastKeyFrame, i, len, ret, currentFrame = this.comp.renderedFrame,
                                keyframes = this.keyframes,
                                firstKeyFrame = keyframes[0].t;
                            if (currentFrame >= firstKeyFrame) return this.pv;
                            if (durationFlag ? lastKeyFrame = firstKeyFrame + (cycleDuration = duration ? Math.abs(this.elem.comp.globalData.frameRate * duration) : Math.max(0, this.elem.data.op - firstKeyFrame)) : ((!duration || duration > keyframes.length - 1) && (duration = keyframes.length - 1), cycleDuration = (lastKeyFrame = keyframes[duration].t) - firstKeyFrame), "pingpong" === type) {
                                if (Math.floor((firstKeyFrame - currentFrame) / cycleDuration) % 2 == 0) return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0)
                            } else {
                                if ("offset" === type) {
                                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0),
                                        endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0),
                                        current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0),
                                        repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
                                    if (this.pv.length) {
                                        for (len = (ret = new Array(initV.length)).length, i = 0; i < len; i += 1) ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
                                        return ret
                                    }
                                    return current - (endV - initV) * repeats
                                }
                                if ("continue" === type) {
                                    var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0),
                                        nextFirstValue = this.getValueAtTime((firstKeyFrame + .001) / this.comp.globalData.frameRate, 0);
                                    if (this.pv.length) {
                                        for (len = (ret = new Array(firstValue.length)).length, i = 0; i < len; i += 1) ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / .001;
                                        return ret
                                    }
                                    return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / .001
                                }
                            }
                            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0)
                        }

                        function smooth(width, samples) {
                            if (!this.k) return this.pv;
                            if (width = .5 * (width || .4), (samples = Math.floor(samples || 5)) <= 1) return this.pv;
                            var value, sampleValue, currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate,
                                initFrame = currentTime - width,
                                sampleFrequency = samples > 1 ? (currentTime + width - initFrame) / (samples - 1) : 1,
                                i = 0,
                                j = 0;
                            for (value = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; i < samples;) {
                                if (sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency), this.pv.length)
                                    for (j = 0; j < this.pv.length; j += 1) value[j] += sampleValue[j];
                                else value += sampleValue;
                                i += 1
                            }
                            if (this.pv.length)
                                for (j = 0; j < this.pv.length; j += 1) value[j] /= samples;
                            else value /= samples;
                            return value
                        }

                        function getTransformValueAtTime(time) {
                            this._transformCachingAtTime || (this._transformCachingAtTime = {
                                v: new Matrix
                            });
                            var matrix = this._transformCachingAtTime.v;
                            if (matrix.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
                                var anchor = this.a.getValueAtTime(time);
                                matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult)
                            }
                            if (this.appliedTransformations < 2) {
                                var scale = this.s.getValueAtTime(time);
                                matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult)
                            }
                            if (this.sk && this.appliedTransformations < 3) {
                                var skew = this.sk.getValueAtTime(time),
                                    skewAxis = this.sa.getValueAtTime(time);
                                matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult)
                            }
                            if (this.r && this.appliedTransformations < 4) {
                                var rotation = this.r.getValueAtTime(time);
                                matrix.rotate(-rotation * this.r.mult)
                            } else if (!this.r && this.appliedTransformations < 4) {
                                var rotationZ = this.rz.getValueAtTime(time),
                                    rotationY = this.ry.getValueAtTime(time),
                                    rotationX = this.rx.getValueAtTime(time),
                                    orientation = this.or.getValueAtTime(time);
                                matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult)
                            }
                            if (this.data.p && this.data.p.s) {
                                var positionX = this.px.getValueAtTime(time),
                                    positionY = this.py.getValueAtTime(time);
                                if (this.data.p.z) {
                                    var positionZ = this.pz.getValueAtTime(time);
                                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult)
                                } else matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0)
                            } else {
                                var position = this.p.getValueAtTime(time);
                                matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult)
                            }
                            return matrix
                        }

                        function getTransformStaticValueAtTime() {
                            return this.v.clone(new Matrix)
                        }
                        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
                        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {
                            var prop = getTransformProperty(elem, data, container);
                            return prop.dynamicProperties.length ? prop.getValueAtTime = getTransformValueAtTime.bind(prop) : prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop), prop.setGroupProperty = expressionHelpers.setGroupProperty, prop
                        };
                        var propertyGetProp = PropertyFactory.getProp;
                        PropertyFactory.getProp = function(elem, data, type, mult, container) {
                            var prop = propertyGetProp(elem, data, type, mult, container);
                            prop.kf ? prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop) : prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop), prop.setGroupProperty = expressionHelpers.setGroupProperty, prop.loopOut = loopOut, prop.loopIn = loopIn, prop.smooth = smooth, prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop), prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop), prop.numKeys = 1 === data.a ? data.k.length : 0, prop.propertyIndex = data.ix;
                            var value = 0;
                            return 0 !== type && (value = createTypedArray("float32", 1 === data.a ? data.k[0].s.length : data.k.length)), prop._cachingAtTime = {
                                lastFrame: initialDefaultFrame,
                                lastIndex: 0,
                                value: value
                            }, expressionHelpers.searchExpressions(elem, data, prop), prop.k && container.addDynamicProperty(prop), prop
                        };
                        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction(),
                            KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

                        function ShapeExpressions() {}
                        ShapeExpressions.prototype = {
                            vertices: function vertices(prop, time) {
                                this.k && this.getValue();
                                var i, shapePath = this.v;
                                void 0 !== time && (shapePath = this.getValueAtTime(time, 0));
                                var len = shapePath._length,
                                    vertices = shapePath[prop],
                                    points = shapePath.v,
                                    arr = createSizedArray(len);
                                for (i = 0; i < len; i += 1) arr[i] = "i" === prop || "o" === prop ? [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]] : [vertices[i][0], vertices[i][1]];
                                return arr
                            },
                            points: function points(time) {
                                return this.vertices("v", time)
                            },
                            inTangents: function inTangents(time) {
                                return this.vertices("i", time)
                            },
                            outTangents: function outTangents(time) {
                                return this.vertices("o", time)
                            },
                            isClosed: function isClosed() {
                                return this.v.c
                            },
                            pointOnPath: function pointOnPath(perc, time) {
                                var shapePath = this.v;
                                void 0 !== time && (shapePath = this.getValueAtTime(time, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(shapePath));
                                for (var pt, segmentsLength = this._segmentsLength, lengths = segmentsLength.lengths, lengthPos = segmentsLength.totalLength * perc, i = 0, len = lengths.length, accumulatedLength = 0; i < len;) {
                                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                                        var initIndex = i,
                                            endIndex = shapePath.c && i === len - 1 ? 0 : i + 1,
                                            segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                                        break
                                    }
                                    accumulatedLength += lengths[i].addedLength, i += 1
                                }
                                return pt || (pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]]), pt
                            },
                            vectorOnPath: function vectorOnPath(perc, time, vectorType) {
                                1 == perc ? perc = this.v.c : 0 == perc && (perc = .999);
                                var pt1 = this.pointOnPath(perc, time),
                                    pt2 = this.pointOnPath(perc + .001, time),
                                    xLength = pt2[0] - pt1[0],
                                    yLength = pt2[1] - pt1[1],
                                    magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
                                return 0 === magnitude ? [0, 0] : "tangent" === vectorType ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude]
                            },
                            tangentOnPath: function tangentOnPath(perc, time) {
                                return this.vectorOnPath(perc, time, "tangent")
                            },
                            normalOnPath: function normalOnPath(perc, time) {
                                return this.vectorOnPath(perc, time, "normal")
                            },
                            setGroupProperty: expressionHelpers.setGroupProperty,
                            getValueAtTime: expressionHelpers.getStaticValueAtTime
                        }, extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction), extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction), KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = function getShapeValueAtTime(frameNum) {
                            return this._cachingAtTime || (this._cachingAtTime = {
                                shapeValue: shapePool.clone(this.pv),
                                lastIndex: 0,
                                lastTime: initialDefaultFrame
                            }), frameNum *= this.elem.globalData.frameRate, (frameNum -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = frameNum, this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                        }, KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
                        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
                        ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {
                            var prop = propertyGetShapeProp(elem, data, type, arr, trims);
                            return prop.propertyIndex = data.ix, prop.lock = !1, 3 === type ? expressionHelpers.searchExpressions(elem, data.pt, prop) : 4 === type && expressionHelpers.searchExpressions(elem, data.ks, prop), prop.k && elem.addDynamicProperty(prop), prop
                        }
                    }

                    function initialize$1() {
                        addPropertyDecorator()
                    }

                    function addDecorator() {
                        TextProperty.prototype.getExpressionValue = function(currentValue, text) {
                            var newValue = this.calculateExpression(text);
                            if (currentValue.t !== newValue) {
                                var newData = {};
                                return this.copyData(newData, currentValue), newData.t = newValue.toString(), newData.__complete = !1, newData
                            }
                            return currentValue
                        }, TextProperty.prototype.searchProperty = function() {
                            var isKeyframed = this.searchKeyframes(),
                                hasExpressions = this.searchExpressions();
                            return this.kf = isKeyframed || hasExpressions, this.kf
                        }, TextProperty.prototype.searchExpressions = function searchExpressions() {
                            return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
                        }
                    }

                    function initialize() {
                        addDecorator()
                    }

                    function SVGComposableEffect() {}
                    SVGComposableEffect.prototype = {
                        createMergeNode: function createMergeNode(resultId, ins) {
                            var feMergeNode, i, feMerge = createNS("feMerge");
                            for (feMerge.setAttribute("result", resultId), i = 0; i < ins.length; i += 1)(feMergeNode = createNS("feMergeNode")).setAttribute("in", ins[i]), feMerge.appendChild(feMergeNode), feMerge.appendChild(feMergeNode);
                            return feMerge
                        }
                    };
                    var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";

                    function SVGTintFilter(filter, filterManager, elem, id, source) {
                        this.filterManager = filterManager;
                        var feColorMatrix = createNS("feColorMatrix");
                        feColorMatrix.setAttribute("type", "matrix"), feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB"), feColorMatrix.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = feColorMatrix, feColorMatrix.setAttribute("result", id + "_tint_1"), filter.appendChild(feColorMatrix), (feColorMatrix = createNS("feColorMatrix")).setAttribute("type", "matrix"), feColorMatrix.setAttribute("color-interpolation-filters", "sRGB"), feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), feColorMatrix.setAttribute("result", id + "_tint_2"), filter.appendChild(feColorMatrix), this.matrixFilter = feColorMatrix;
                        var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
                        filter.appendChild(feMerge)
                    }

                    function SVGFillFilter(filter, filterManager, elem, id) {
                        this.filterManager = filterManager;
                        var feColorMatrix = createNS("feColorMatrix");
                        feColorMatrix.setAttribute("type", "matrix"), feColorMatrix.setAttribute("color-interpolation-filters", "sRGB"), feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), feColorMatrix.setAttribute("result", id), filter.appendChild(feColorMatrix), this.matrixFilter = feColorMatrix
                    }

                    function SVGStrokeEffect(fil, filterManager, elem) {
                        this.initialized = !1, this.filterManager = filterManager, this.elem = elem, this.paths = []
                    }

                    function SVGTritoneFilter(filter, filterManager, elem, id) {
                        this.filterManager = filterManager;
                        var feColorMatrix = createNS("feColorMatrix");
                        feColorMatrix.setAttribute("type", "matrix"), feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB"), feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), filter.appendChild(feColorMatrix);
                        var feComponentTransfer = createNS("feComponentTransfer");
                        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB"), feComponentTransfer.setAttribute("result", id), this.matrixFilter = feComponentTransfer;
                        var feFuncR = createNS("feFuncR");
                        feFuncR.setAttribute("type", "table"), feComponentTransfer.appendChild(feFuncR), this.feFuncR = feFuncR;
                        var feFuncG = createNS("feFuncG");
                        feFuncG.setAttribute("type", "table"), feComponentTransfer.appendChild(feFuncG), this.feFuncG = feFuncG;
                        var feFuncB = createNS("feFuncB");
                        feFuncB.setAttribute("type", "table"), feComponentTransfer.appendChild(feFuncB), this.feFuncB = feFuncB, filter.appendChild(feComponentTransfer)
                    }

                    function SVGProLevelsFilter(filter, filterManager, elem, id) {
                        this.filterManager = filterManager;
                        var effectElements = this.filterManager.effectElements,
                            feComponentTransfer = createNS("feComponentTransfer");
                        (effectElements[10].p.k || 0 !== effectElements[10].p.v || effectElements[11].p.k || 1 !== effectElements[11].p.v || effectElements[12].p.k || 1 !== effectElements[12].p.v || effectElements[13].p.k || 0 !== effectElements[13].p.v || effectElements[14].p.k || 1 !== effectElements[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer)), (effectElements[17].p.k || 0 !== effectElements[17].p.v || effectElements[18].p.k || 1 !== effectElements[18].p.v || effectElements[19].p.k || 1 !== effectElements[19].p.v || effectElements[20].p.k || 0 !== effectElements[20].p.v || effectElements[21].p.k || 1 !== effectElements[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer)), (effectElements[24].p.k || 0 !== effectElements[24].p.v || effectElements[25].p.k || 1 !== effectElements[25].p.v || effectElements[26].p.k || 1 !== effectElements[26].p.v || effectElements[27].p.k || 0 !== effectElements[27].p.v || effectElements[28].p.k || 1 !== effectElements[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer)), (effectElements[31].p.k || 0 !== effectElements[31].p.v || effectElements[32].p.k || 1 !== effectElements[32].p.v || effectElements[33].p.k || 1 !== effectElements[33].p.v || effectElements[34].p.k || 0 !== effectElements[34].p.v || effectElements[35].p.k || 1 !== effectElements[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB"), filter.appendChild(feComponentTransfer)), (effectElements[3].p.k || 0 !== effectElements[3].p.v || effectElements[4].p.k || 1 !== effectElements[4].p.v || effectElements[5].p.k || 1 !== effectElements[5].p.v || effectElements[6].p.k || 0 !== effectElements[6].p.v || effectElements[7].p.k || 1 !== effectElements[7].p.v) && ((feComponentTransfer = createNS("feComponentTransfer")).setAttribute("color-interpolation-filters", "sRGB"), feComponentTransfer.setAttribute("result", id), filter.appendChild(feComponentTransfer), this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer), this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer), this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer))
                    }

                    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
                        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize,
                            filterSize = filterManager.data.fs || globalFilterSize;
                        filter.setAttribute("x", filterSize.x || globalFilterSize.x), filter.setAttribute("y", filterSize.y || globalFilterSize.y), filter.setAttribute("width", filterSize.width || globalFilterSize.width), filter.setAttribute("height", filterSize.height || globalFilterSize.height), this.filterManager = filterManager;
                        var feGaussianBlur = createNS("feGaussianBlur");
                        feGaussianBlur.setAttribute("in", "SourceAlpha"), feGaussianBlur.setAttribute("result", id + "_drop_shadow_1"), feGaussianBlur.setAttribute("stdDeviation", "0"), this.feGaussianBlur = feGaussianBlur, filter.appendChild(feGaussianBlur);
                        var feOffset = createNS("feOffset");
                        feOffset.setAttribute("dx", "25"), feOffset.setAttribute("dy", "0"), feOffset.setAttribute("in", id + "_drop_shadow_1"), feOffset.setAttribute("result", id + "_drop_shadow_2"), this.feOffset = feOffset, filter.appendChild(feOffset);
                        var feFlood = createNS("feFlood");
                        feFlood.setAttribute("flood-color", "#00ff00"), feFlood.setAttribute("flood-opacity", "1"), feFlood.setAttribute("result", id + "_drop_shadow_3"), this.feFlood = feFlood, filter.appendChild(feFlood);
                        var feComposite = createNS("feComposite");
                        feComposite.setAttribute("in", id + "_drop_shadow_3"), feComposite.setAttribute("in2", id + "_drop_shadow_2"), feComposite.setAttribute("operator", "in"), feComposite.setAttribute("result", id + "_drop_shadow_4"), filter.appendChild(feComposite);
                        var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
                        filter.appendChild(feMerge)
                    }
                    extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            var colorBlack = this.filterManager.effectElements[0].p.v,
                                colorWhite = this.filterManager.effectElements[1].p.v,
                                opacity = this.filterManager.effectElements[2].p.v / 100;
                            this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0"), this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0")
                        }
                    }, SVGFillFilter.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            var color = this.filterManager.effectElements[2].p.v,
                                opacity = this.filterManager.effectElements[6].p.v;
                            this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0")
                        }
                    }, SVGStrokeEffect.prototype.initialize = function() {
                        var path, groupPath, i, len, elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                        for (1 === this.filterManager.effectElements[1].p.v ? (len = this.elem.maskManager.masksProperties.length, i = 0) : len = 1 + (i = this.filterManager.effectElements[0].p.v - 1), (groupPath = createNS("g")).setAttribute("fill", "none"), groupPath.setAttribute("stroke-linecap", "round"), groupPath.setAttribute("stroke-dashoffset", 1); i < len; i += 1) path = createNS("path"), groupPath.appendChild(path), this.paths.push({
                            p: path,
                            m: i
                        });
                        if (3 === this.filterManager.effectElements[10].p.v) {
                            var mask = createNS("mask"),
                                id = createElementID();
                            mask.setAttribute("id", id), mask.setAttribute("mask-type", "alpha"), mask.appendChild(groupPath), this.elem.globalData.defs.appendChild(mask);
                            var g = createNS("g");
                            for (g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")"); elemChildren[0];) g.appendChild(elemChildren[0]);
                            this.elem.layerElement.appendChild(g), this.masker = mask, groupPath.setAttribute("stroke", "#fff")
                        } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                            if (2 === this.filterManager.effectElements[10].p.v)
                                for (elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes; elemChildren.length;) this.elem.layerElement.removeChild(elemChildren[0]);
                            this.elem.layerElement.appendChild(groupPath), this.elem.layerElement.removeAttribute("mask"), groupPath.setAttribute("stroke", "#fff")
                        }
                        this.initialized = !0, this.pathMasker = groupPath
                    }, SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
                        var i;
                        this.initialized || this.initialize();
                        var mask, path, len = this.paths.length;
                        for (i = 0; i < len; i += 1)
                            if (-1 !== this.paths[i].m && (mask = this.elem.maskManager.viewData[this.paths[i].m], path = this.paths[i].p, (forceRender || this.filterManager._mdf || mask.prop._mdf) && path.setAttribute("d", mask.lastPath), forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf)) {
                                var dasharrayValue;
                                if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                                    var s = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                        e = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                        l = path.getTotalLength();
                                    dasharrayValue = "0 0 0 " + l * s + " ";
                                    var j, lineLength = l * (e - s),
                                        segment = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01,
                                        units = Math.floor(lineLength / segment);
                                    for (j = 0; j < units; j += 1) dasharrayValue += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                                    dasharrayValue += "0 " + 10 * l + " 0 0"
                                } else dasharrayValue = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                                path.setAttribute("stroke-dasharray", dasharrayValue)
                            } if ((forceRender || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (forceRender || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (forceRender || this.filterManager.effectElements[3].p._mdf)) {
                            var color = this.filterManager.effectElements[3].p.v;
                            this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * color[0]) + "," + bmFloor(255 * color[1]) + "," + bmFloor(255 * color[2]) + ")")
                        }
                    }, SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            var color1 = this.filterManager.effectElements[0].p.v,
                                color2 = this.filterManager.effectElements[1].p.v,
                                color3 = this.filterManager.effectElements[2].p.v,
                                tableR = color3[0] + " " + color2[0] + " " + color1[0],
                                tableG = color3[1] + " " + color2[1] + " " + color1[1],
                                tableB = color3[2] + " " + color2[2] + " " + color1[2];
                            this.feFuncR.setAttribute("tableValues", tableR), this.feFuncG.setAttribute("tableValues", tableG), this.feFuncB.setAttribute("tableValues", tableB)
                        }
                    }, SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
                        var feFunc = createNS(type);
                        return feFunc.setAttribute("type", "table"), feComponentTransfer.appendChild(feFunc), feFunc
                    }, SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
                        for (var perc, colorValue, cnt = 0, min = Math.min(inputBlack, inputWhite), max = Math.max(inputBlack, inputWhite), table = Array.call(null, {
                                length: 256
                            }), pos = 0, outputDelta = outputWhite - outputBlack, inputDelta = inputWhite - inputBlack; cnt <= 256;) colorValue = (perc = cnt / 256) <= min ? inputDelta < 0 ? outputWhite : outputBlack : perc >= max ? inputDelta < 0 ? outputBlack : outputWhite : outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma), table[pos] = colorValue, pos += 1, cnt += 256 / 255;
                        return table.join(" ")
                    }, SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            var val, effectElements = this.filterManager.effectElements;
                            this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf) && (val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v), this.feFuncRComposed.setAttribute("tableValues", val), this.feFuncGComposed.setAttribute("tableValues", val), this.feFuncBComposed.setAttribute("tableValues", val)), this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf) && (val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v), this.feFuncR.setAttribute("tableValues", val)), this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf) && (val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v), this.feFuncG.setAttribute("tableValues", val)), this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf) && (val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v), this.feFuncB.setAttribute("tableValues", val)), this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf) && (val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v), this.feFuncA.setAttribute("tableValues", val))
                        }
                    }, extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            if ((forceRender || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), forceRender || this.filterManager.effectElements[0].p._mdf) {
                                var col = this.filterManager.effectElements[0].p.v;
                                this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * col[0]), Math.round(255 * col[1]), Math.round(255 * col[2])))
                            }
                            if ((forceRender || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                                var distance = this.filterManager.effectElements[3].p.v,
                                    angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                                    x = distance * Math.cos(angle),
                                    y = distance * Math.sin(angle);
                                this.feOffset.setAttribute("dx", x), this.feOffset.setAttribute("dy", y)
                            }
                        }
                    };
                    var _svgMatteSymbols = [];

                    function SVGMatte3Effect(filterElem, filterManager, elem) {
                        this.initialized = !1, this.filterManager = filterManager, this.filterElem = filterElem, this.elem = elem, elem.matteElement = createNS("g"), elem.matteElement.appendChild(elem.layerElement), elem.matteElement.appendChild(elem.transformedElement), elem.baseElement = elem.matteElement
                    }

                    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
                        filter.setAttribute("x", "-100%"), filter.setAttribute("y", "-100%"), filter.setAttribute("width", "300%"), filter.setAttribute("height", "300%"), this.filterManager = filterManager;
                        var feGaussianBlur = createNS("feGaussianBlur");
                        feGaussianBlur.setAttribute("result", id), filter.appendChild(feGaussianBlur), this.feGaussianBlur = feGaussianBlur
                    }

                    function TransformEffect() {}

                    function SVGTransformEffect(_, filterManager) {
                        this.init(filterManager)
                    }

                    function CVTransformEffect(effectsManager) {
                        this.init(effectsManager)
                    }
                    return SVGMatte3Effect.prototype.findSymbol = function(mask) {
                        for (var i = 0, len = _svgMatteSymbols.length; i < len;) {
                            if (_svgMatteSymbols[i] === mask) return _svgMatteSymbols[i];
                            i += 1
                        }
                        return null
                    }, SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
                        var parentNode = mask.layerElement.parentNode;
                        if (parentNode) {
                            for (var nextChild, children = parentNode.children, i = 0, len = children.length; i < len && children[i] !== mask.layerElement;) i += 1;
                            i <= len - 2 && (nextChild = children[i + 1]);
                            var useElem = createNS("use");
                            useElem.setAttribute("href", "#" + symbolId), nextChild ? parentNode.insertBefore(useElem, nextChild) : parentNode.appendChild(useElem)
                        }
                    }, SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
                        if (!this.findSymbol(mask)) {
                            var symbolId = createElementID(),
                                masker = createNS("mask");
                            masker.setAttribute("id", mask.layerId), masker.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(mask);
                            var defs = elem.globalData.defs;
                            defs.appendChild(masker);
                            var symbol = createNS("symbol");
                            symbol.setAttribute("id", symbolId), this.replaceInParent(mask, symbolId), symbol.appendChild(mask.layerElement), defs.appendChild(symbol);
                            var useElem = createNS("use");
                            useElem.setAttribute("href", "#" + symbolId), masker.appendChild(useElem), mask.data.hd = !1, mask.show()
                        }
                        elem.setMatte(mask.layerId)
                    }, SVGMatte3Effect.prototype.initialize = function() {
                        for (var ind = this.filterManager.effectElements[0].p.v, elements = this.elem.comp.elements, i = 0, len = elements.length; i < len;) elements[i] && elements[i].data.ind === ind && this.setElementAsMask(this.elem, elements[i]), i += 1;
                        this.initialized = !0
                    }, SVGMatte3Effect.prototype.renderFrame = function() {
                        this.initialized || this.initialize()
                    }, SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
                        if (forceRender || this.filterManager._mdf) {
                            var sigma = .3 * this.filterManager.effectElements[0].p.v,
                                dimensions = this.filterManager.effectElements[1].p.v,
                                sigmaX = 3 == dimensions ? 0 : sigma,
                                sigmaY = 2 == dimensions ? 0 : sigma;
                            this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
                            var edgeMode = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                            this.feGaussianBlur.setAttribute("edgeMode", edgeMode)
                        }
                    }, TransformEffect.prototype.init = function(effectsManager) {
                        this.effectsManager = effectsManager, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1
                    }, TransformEffect.prototype.renderFrame = function(forceFrame) {
                        if (this._opMdf = !1, this._mdf = !1, forceFrame || this.effectsManager._mdf) {
                            var effectElements = this.effectsManager.effectElements,
                                anchor = effectElements[0].p.v,
                                position = effectElements[1].p.v,
                                isUniformScale = 1 === effectElements[2].p.v,
                                scaleHeight = effectElements[3].p.v,
                                scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v,
                                skew = effectElements[5].p.v,
                                skewAxis = effectElements[6].p.v,
                                rotation = effectElements[7].p.v;
                            this.matrix.reset(), this.matrix.translate(-anchor[0], -anchor[1], anchor[2]), this.matrix.scale(.01 * scaleWidth, .01 * scaleHeight, 1), this.matrix.rotate(-rotation * degToRads), this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads), this.matrix.translate(position[0], position[1], 0), this._mdf = !0, this.opacity !== effectElements[8].p.v && (this.opacity = effectElements[8].p.v, this._opMdf = !0)
                        }
                    }, extendPrototype([TransformEffect], SVGTransformEffect), extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
                }, module.exports = factory())
            },
            "./src/js/plugins/gsap/CSSRulePlugin.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    CSSRulePlugin: () => CSSRulePlugin,
                    default: () => CSSRulePlugin
                });
                var gsap, _coreInitted, _doc, CSSPlugin, _windowExists = function _windowExists() {
                        return "undefined" != typeof window
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _checkRegister = function _checkRegister() {
                        return _coreInitted || (_initCore(), CSSPlugin || console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)")), _coreInitted
                    },
                    _initCore = function _initCore(core) {
                        gsap = core || _getGSAP(), _windowExists() && (window, _doc = document), gsap && (CSSPlugin = gsap.plugins.css) && (_coreInitted = 1)
                    },
                    CSSRulePlugin = {
                        version: "3.11.3",
                        name: "cssRule",
                        init: function init(target, value, tween, index, targets) {
                            if (!_checkRegister() || void 0 === target.cssText) return !1;
                            var div = target._gsProxy = target._gsProxy || _doc.createElement("div");
                            this.ss = target, this.style = div.style, div.style.cssText = target.cssText, CSSPlugin.prototype.init.call(this, div, value, tween, index, targets)
                        },
                        render: function render(ratio, data) {
                            for (var i, pt = data._pt, style = data.style, ss = data.ss; pt;) pt.r(ratio, pt.d), pt = pt._next;
                            for (i = style.length; --i > -1;) ss[style[i]] = style[style[i]]
                        },
                        getRule: function getRule(selector) {
                            _checkRegister();
                            var j, curSS, cs, a, ruleProp = _doc.all ? "rules" : "cssRules",
                                styleSheets = _doc.styleSheets,
                                i = styleSheets.length,
                                pseudo = ":" === selector.charAt(0);
                            for (selector = (pseudo ? "" : ",") + selector.split("::").join(":").toLowerCase() + ",", pseudo && (a = []); i--;) {
                                try {
                                    if (!(curSS = styleSheets[i][ruleProp])) continue;
                                    j = curSS.length
                                } catch (e) {
                                    console.warn(e);
                                    continue
                                }
                                for (; --j > -1;)
                                    if ((cs = curSS[j]).selectorText && -1 !== ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector)) {
                                        if (!pseudo) return cs.style;
                                        a.push(cs.style)
                                    }
                            }
                            return a
                        },
                        register: _initCore
                    };
                _getGSAP() && gsap.registerPlugin(CSSRulePlugin)
            },
            "./src/js/plugins/gsap/Observer.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";

                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    Observer: () => Observer,
                    _getProxyProp: () => _getProxyProp,
                    _getScrollFunc: () => _getScrollFunc,
                    _getTarget: () => _getTarget,
                    _getVelocityProp: () => _getVelocityProp,
                    _horizontal: () => _horizontal,
                    _isViewport: () => _isViewport,
                    _proxies: () => _proxies,
                    _scrollers: () => _scrollers,
                    _vertical: () => _vertical,
                    default: () => Observer
                });
                var gsap, _coreInitted, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _getGSAP = function _getGSAP() {
                        return gsap || "undefined" != typeof window && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _startup = 1,
                    _observers = [],
                    _scrollers = [],
                    _proxies = [],
                    _getTime = Date.now,
                    _bridge = function _bridge(name, value) {
                        return value
                    },
                    _getProxyProp = function _getProxyProp(element, property) {
                        return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property]
                    },
                    _isViewport = function _isViewport(el) {
                        return !!~_root.indexOf(el)
                    },
                    _addListener = function _addListener(element, type, func, nonPassive, capture) {
                        return element.addEventListener(type, func, {
                            passive: !nonPassive,
                            capture: !!capture
                        })
                    },
                    _removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture)
                    },
                    _onScroll = function _onScroll() {
                        return _normalizer && _normalizer.isPressed || _scrollers.cache++
                    },
                    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
                        var cachingFunc = function cachingFunc(value) {
                            if (value || 0 === value) {
                                _startup && (_win.history.scrollRestoration = "manual");
                                var isNormalizing = _normalizer && _normalizer.isPressed;
                                value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0), f(value), cachingFunc.cacheID = _scrollers.cache, isNormalizing && _bridge("ss", value)
                            } else(doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) && (cachingFunc.cacheID = _scrollers.cache, cachingFunc.v = f());
                            return cachingFunc.v + cachingFunc.offset
                        };
                        return cachingFunc.offset = 0, f && cachingFunc
                    },
                    _horizontal = {
                        s: "scrollLeft",
                        p: "left",
                        p2: "Left",
                        os: "right",
                        os2: "Right",
                        d: "width",
                        d2: "Width",
                        a: "x",
                        sc: _scrollCacheFunc((function(value) {
                            return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc.scrollLeft || _docEl.scrollLeft || _body.scrollLeft || 0
                        }))
                    },
                    _vertical = {
                        s: "scrollTop",
                        p: "top",
                        p2: "Top",
                        os: "bottom",
                        os2: "Bottom",
                        d: "height",
                        d2: "Height",
                        a: "y",
                        op: _horizontal,
                        sc: _scrollCacheFunc((function(value) {
                            return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc.scrollTop || _docEl.scrollTop || _body.scrollTop || 0
                        }))
                    },
                    _getTarget = function _getTarget(t) {
                        return gsap.utils.toArray(t)[0] || ("string" == typeof t && !1 !== gsap.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
                    },
                    _getScrollFunc = function _getScrollFunc(element, _ref) {
                        var s = _ref.s,
                            sc = _ref.sc;
                        _isViewport(element) && (element = _doc.scrollingElement || _docEl);
                        var i = _scrollers.indexOf(element),
                            offset = sc === _vertical.sc ? 1 : 2;
                        !~i && (i = _scrollers.push(element) - 1), _scrollers[i + offset] || element.addEventListener("scroll", _onScroll);
                        var prev = _scrollers[i + offset],
                            func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), !0) || (_isViewport(element) ? sc : _scrollCacheFunc((function(value) {
                                return arguments.length ? element[s] = value : element[s]
                            }))));
                        return func.target = element, prev || (func.smooth = "smooth" === gsap.getProperty(element, "scrollBehavior")), func
                    },
                    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
                        var v1 = value,
                            v2 = value,
                            t1 = _getTime(),
                            t2 = t1,
                            min = minTimeRefresh || 50,
                            dropToZeroTime = Math.max(500, 3 * min),
                            update = function update(value, force) {
                                var t = _getTime();
                                force || t - t1 > min ? (v2 = v1, v1 = value, t2 = t1, t1 = t) : useDelta ? v1 += value : v1 = v2 + (value - v2) / (t - t2) * (t1 - t2)
                            };
                        return {
                            update: update,
                            reset: function reset() {
                                v2 = v1 = useDelta ? 0 : v1, t2 = t1 = 0
                            },
                            getVelocity: function getVelocity(latestValue) {
                                var tOld = t2,
                                    vOld = v2,
                                    t = _getTime();
                                return (latestValue || 0 === latestValue) && latestValue !== v1 && update(latestValue), t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3
                            }
                        }
                    },
                    _getEvent = function _getEvent(e, preventDefault) {
                        return preventDefault && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
                    },
                    _getAbsoluteMax = function _getAbsoluteMax(a) {
                        var max = Math.max.apply(Math, a),
                            min = Math.min.apply(Math, a);
                        return Math.abs(max) >= Math.abs(min) ? max : min
                    },
                    _setScrollTrigger = function _setScrollTrigger() {
                        (ScrollTrigger = gsap.core.globals().ScrollTrigger) && ScrollTrigger.core && function _integrate() {
                            var core = ScrollTrigger.core,
                                data = core.bridge || {},
                                scrollers = core._scrollers,
                                proxies = core._proxies;
                            scrollers.push.apply(scrollers, _scrollers), proxies.push.apply(proxies, _proxies), _scrollers = scrollers, _proxies = proxies, _bridge = function _bridge(name, value) {
                                return data[name](value)
                            }
                        }()
                    },
                    _initCore = function _initCore(core) {
                        return (gsap = core || _getGSAP()) && "undefined" != typeof document && document.body && (_win = window, _doc = document, _docEl = _doc.documentElement, _body = _doc.body, _root = [_win, _doc, _docEl, _body], gsap.utils.clamp, _pointerType = "onpointerenter" in _body ? "pointer" : "mouse", _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in _docEl ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function() {
                            return _startup = 0
                        }), 500), _setScrollTrigger(), _coreInitted = 1), _coreInitted
                    };
                _horizontal.op = _vertical, _scrollers.cache = 0;
                var Observer = function() {
                    function Observer(vars) {
                        this.init(vars)
                    }
                    return Observer.prototype.init = function init(vars) {
                            _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)"), ScrollTrigger || _setScrollTrigger();
                            var tolerance = vars.tolerance,
                                dragMinimum = vars.dragMinimum,
                                type = vars.type,
                                target = vars.target,
                                lineHeight = vars.lineHeight,
                                debounce = vars.debounce,
                                preventDefault = vars.preventDefault,
                                onStop = vars.onStop,
                                onStopDelay = vars.onStopDelay,
                                ignore = vars.ignore,
                                wheelSpeed = vars.wheelSpeed,
                                event = vars.event,
                                onDragStart = vars.onDragStart,
                                onDragEnd = vars.onDragEnd,
                                onDrag = vars.onDrag,
                                onPress = vars.onPress,
                                onRelease = vars.onRelease,
                                onRight = vars.onRight,
                                onLeft = vars.onLeft,
                                onUp = vars.onUp,
                                onDown = vars.onDown,
                                onChangeX = vars.onChangeX,
                                onChangeY = vars.onChangeY,
                                onChange = vars.onChange,
                                onToggleX = vars.onToggleX,
                                onToggleY = vars.onToggleY,
                                onHover = vars.onHover,
                                onHoverEnd = vars.onHoverEnd,
                                onMove = vars.onMove,
                                ignoreCheck = vars.ignoreCheck,
                                isNormalizer = vars.isNormalizer,
                                onGestureStart = vars.onGestureStart,
                                onGestureEnd = vars.onGestureEnd,
                                onWheel = vars.onWheel,
                                onEnable = vars.onEnable,
                                onDisable = vars.onDisable,
                                onClick = vars.onClick,
                                scrollSpeed = vars.scrollSpeed,
                                capture = vars.capture,
                                allowClicks = vars.allowClicks,
                                lockAxis = vars.lockAxis,
                                onLockAxis = vars.onLockAxis;
                            this.target = target = _getTarget(target) || _docEl, this.vars = vars, ignore && (ignore = gsap.utils.toArray(ignore)), tolerance = tolerance || 1e-9, dragMinimum = dragMinimum || 0, wheelSpeed = wheelSpeed || 1, scrollSpeed = scrollSpeed || 1, type = type || "wheel,touch,pointer", debounce = !1 !== debounce, lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);
                            var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this,
                                prevDeltaX = 0,
                                prevDeltaY = 0,
                                scrollFuncX = _getScrollFunc(target, _horizontal),
                                scrollFuncY = _getScrollFunc(target, _vertical),
                                scrollX = scrollFuncX(),
                                scrollY = scrollFuncY(),
                                limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && "pointerdown" === _eventTypes[0],
                                isViewport = _isViewport(target),
                                ownerDoc = target.ownerDocument || _doc,
                                deltaX = [0, 0, 0],
                                deltaY = [0, 0, 0],
                                onClickTime = 0,
                                clickCapture = function clickCapture() {
                                    return onClickTime = _getTime()
                                },
                                _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
                                    return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && "touch" !== e.pointerType || ignoreCheck && ignoreCheck(e, isPointerOrTouch)
                                },
                                update = function update() {
                                    var dx = self.deltaX = _getAbsoluteMax(deltaX),
                                        dy = self.deltaY = _getAbsoluteMax(deltaY),
                                        changedX = Math.abs(dx) >= tolerance,
                                        changedY = Math.abs(dy) >= tolerance;
                                    onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY), changedX && (onRight && self.deltaX > 0 && onRight(self), onLeft && self.deltaX < 0 && onLeft(self), onChangeX && onChangeX(self), onToggleX && self.deltaX < 0 != prevDeltaX < 0 && onToggleX(self), prevDeltaX = self.deltaX, deltaX[0] = deltaX[1] = deltaX[2] = 0), changedY && (onDown && self.deltaY > 0 && onDown(self), onUp && self.deltaY < 0 && onUp(self), onChangeY && onChangeY(self), onToggleY && self.deltaY < 0 != prevDeltaY < 0 && onToggleY(self), prevDeltaY = self.deltaY, deltaY[0] = deltaY[1] = deltaY[2] = 0), (moved || dragged) && (onMove && onMove(self), dragged && (onDrag(self), dragged = !1), moved = !1), locked && !(locked = !1) && onLockAxis && onLockAxis(self), wheeled && (onWheel(self), wheeled = !1), id = 0
                                },
                                onDelta = function onDelta(x, y, index) {
                                    deltaX[index] += x, deltaY[index] += y, self._vx.update(x), self._vy.update(y), debounce ? id || (id = requestAnimationFrame(update)) : update()
                                },
                                onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
                                    lockAxis && !axis && (self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y", locked = !0), "y" !== axis && (deltaX[2] += x, self._vx.update(x, !0)), "x" !== axis && (deltaY[2] += y, self._vy.update(y, !0)), debounce ? id || (id = requestAnimationFrame(update)) : update()
                                },
                                _onDrag = function _onDrag(e) {
                                    if (!_ignoreCheck(e, 1)) {
                                        var x = (e = _getEvent(e, preventDefault)).clientX,
                                            y = e.clientY,
                                            dx = x - self.x,
                                            dy = y - self.y,
                                            isDragging = self.isDragging;
                                        self.x = x, self.y = y, (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) && (onDrag && (dragged = !0), isDragging || (self.isDragging = !0), onTouchOrPointerDelta(dx, dy), isDragging || onDragStart && onDragStart(self))
                                    }
                                },
                                _onPress = self.onPress = function(e) {
                                    _ignoreCheck(e, 1) || (self.axis = axis = null, onStopDelayedCall.pause(), self.isPressed = !0, e = _getEvent(e), prevDeltaX = prevDeltaY = 0, self.startX = self.x = e.clientX, self.startY = self.y = e.clientY, self._vx.reset(), self._vy.reset(), _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, !0), self.deltaX = self.deltaY = 0, onPress && onPress(self))
                                },
                                _onRelease = function _onRelease(e) {
                                    if (!_ignoreCheck(e, 1)) {
                                        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, !0);
                                        var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
                                            eventData = _getEvent(e);
                                        wasDragging || (self._vx.reset(), self._vy.reset(), preventDefault && allowClicks && gsap.delayedCall(.08, (function() {
                                            if (_getTime() - onClickTime > 300 && !e.defaultPrevented)
                                                if (e.target.click) e.target.click();
                                                else if (ownerDoc.createEvent) {
                                                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                                                syntheticEvent.initMouseEvent("click", !0, !0, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(syntheticEvent)
                                            }
                                        }))), self.isDragging = self.isGesturing = self.isPressed = !1, onStop && !isNormalizer && onStopDelayedCall.restart(!0), onDragEnd && wasDragging && onDragEnd(self), onRelease && onRelease(self, wasDragging)
                                    }
                                },
                                _onGestureStart = function _onGestureStart(e) {
                                    return e.touches && e.touches.length > 1 && (self.isGesturing = !0) && onGestureStart(e, self.isDragging)
                                },
                                _onGestureEnd = function _onGestureEnd() {
                                    return (self.isGesturing = !1) || onGestureEnd(self)
                                },
                                onScroll = function onScroll(e) {
                                    if (!_ignoreCheck(e)) {
                                        var x = scrollFuncX(),
                                            y = scrollFuncY();
                                        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1), scrollX = x, scrollY = y, onStop && onStopDelayedCall.restart(!0)
                                    }
                                },
                                _onWheel = function _onWheel(e) {
                                    if (!_ignoreCheck(e)) {
                                        e = _getEvent(e, preventDefault), onWheel && (wheeled = !0);
                                        var multiplier = (1 === e.deltaMode ? lineHeight : 2 === e.deltaMode ? _win.innerHeight : 1) * wheelSpeed;
                                        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0), onStop && !isNormalizer && onStopDelayedCall.restart(!0)
                                    }
                                },
                                _onMove = function _onMove(e) {
                                    if (!_ignoreCheck(e)) {
                                        var x = e.clientX,
                                            y = e.clientY,
                                            dx = x - self.x,
                                            dy = y - self.y;
                                        self.x = x, self.y = y, moved = !0, (dx || dy) && onTouchOrPointerDelta(dx, dy)
                                    }
                                },
                                _onHover = function _onHover(e) {
                                    self.event = e, onHover(self)
                                },
                                _onHoverEnd = function _onHoverEnd(e) {
                                    self.event = e, onHoverEnd(self)
                                },
                                _onClick = function _onClick(e) {
                                    return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self)
                                };
                            onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || .25, (function onStopFunc() {
                                self._vx.reset(), self._vy.reset(), onStopDelayedCall.pause(), onStop && onStop(self)
                            })).pause(), self.deltaX = self.deltaY = 0, self._vx = _getVelocityProp(0, 50, !0), self._vy = _getVelocityProp(0, 50, !0), self.scrollX = scrollFuncX, self.scrollY = scrollFuncY, self.isDragging = self.isGesturing = self.isPressed = !1, self.enable = function(e) {
                                return self.isEnabled || (_addListener(isViewport ? ownerDoc : target, "scroll", _onScroll), type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture), type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture), (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) && (_addListener(target, _eventTypes[0], _onPress, preventDefault, capture), _addListener(ownerDoc, _eventTypes[2], _onRelease), _addListener(ownerDoc, _eventTypes[3], _onRelease), allowClicks && _addListener(target, "click", clickCapture, !1, !0), onClick && _addListener(target, "click", _onClick), onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart), onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd), onHover && _addListener(target, _pointerType + "enter", _onHover), onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd), onMove && _addListener(target, _pointerType + "move", _onMove)), self.isEnabled = !0, e && e.type && _onPress(e), onEnable && onEnable(self)), self
                            }, self.disable = function() {
                                self.isEnabled && (_observers.filter((function(o) {
                                    return o !== self && _isViewport(o.target)
                                })).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll), self.isPressed && (self._vx.reset(), self._vy.reset(), _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, !0)), _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture), _removeListener(target, "wheel", _onWheel, capture), _removeListener(target, _eventTypes[0], _onPress, capture), _removeListener(ownerDoc, _eventTypes[2], _onRelease), _removeListener(ownerDoc, _eventTypes[3], _onRelease), _removeListener(target, "click", clickCapture, !0), _removeListener(target, "click", _onClick), _removeListener(ownerDoc, "gesturestart", _onGestureStart), _removeListener(ownerDoc, "gestureend", _onGestureEnd), _removeListener(target, _pointerType + "enter", _onHover), _removeListener(target, _pointerType + "leave", _onHoverEnd), _removeListener(target, _pointerType + "move", _onMove), self.isEnabled = self.isPressed = self.isDragging = !1, onDisable && onDisable(self))
                            }, self.kill = function() {
                                self.disable();
                                var i = _observers.indexOf(self);
                                i >= 0 && _observers.splice(i, 1), _normalizer === self && (_normalizer = 0)
                            }, _observers.push(self), isNormalizer && _isViewport(target) && (_normalizer = self), self.enable(event)
                        },
                        function _createClass(Constructor, protoProps, staticProps) {
                            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor
                        }(Observer, [{
                            key: "velocityX",
                            get: function get() {
                                return this._vx.getVelocity()
                            }
                        }, {
                            key: "velocityY",
                            get: function get() {
                                return this._vy.getVelocity()
                            }
                        }]), Observer
                }();
                Observer.version = "3.11.3", Observer.create = function(vars) {
                    return new Observer(vars)
                }, Observer.register = _initCore, Observer.getAll = function() {
                    return _observers.slice()
                }, Observer.getById = function(id) {
                    return _observers.filter((function(o) {
                        return o.vars.id === id
                    }))[0]
                }, _getGSAP() && gsap.registerPlugin(Observer)
            },
            "./src/js/plugins/gsap/ScrollTrigger.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    ScrollTrigger: () => ScrollTrigger,
                    default: () => ScrollTrigger
                });
                var gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _limitCallbacks, _rafID, _refreshingAll, _queueRefreshID, _primary, _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/js/plugins/gsap/Observer.js"),
                    _startup = 1,
                    _getTime = Date.now,
                    _time1 = _getTime(),
                    _lastScrollTime = 0,
                    _enabled = 0,
                    _pointerDownHandler = function _pointerDownHandler() {
                        return _pointerIsDown = 1
                    },
                    _pointerUpHandler = function _pointerUpHandler() {
                        return _pointerIsDown = 0
                    },
                    _passThrough = function _passThrough(v) {
                        return v
                    },
                    _round = function _round(value) {
                        return Math.round(1e5 * value) / 1e5 || 0
                    },
                    _windowExists = function _windowExists() {
                        return "undefined" != typeof window
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _isViewport = function _isViewport(e) {
                        return !!~_root.indexOf(e)
                    },
                    _getBoundsFunc = function _getBoundsFunc(element) {
                        return (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, "getBoundingClientRect") || (_isViewport(element) ? function() {
                            return _winOffsets.width = _win.innerWidth, _winOffsets.height = _win.innerHeight, _winOffsets
                        } : function() {
                            return _getBounds(element)
                        })
                    },
                    _maxScroll = function _maxScroll(element, _ref2) {
                        var s = _ref2.s,
                            d2 = _ref2.d2,
                            d = _ref2.d,
                            a = _ref2.a;
                        return (s = "scroll" + d2) && (a = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2]
                    },
                    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
                        for (var i = 0; i < _autoRefresh.length; i += 3)(!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2])
                    },
                    _isString = function _isString(value) {
                        return "string" == typeof value
                    },
                    _isFunction = function _isFunction(value) {
                        return "function" == typeof value
                    },
                    _isNumber = function _isNumber(value) {
                        return "number" == typeof value
                    },
                    _isObject = function _isObject(value) {
                        return "object" == typeof value
                    },
                    _endAnimation = function _endAnimation(animation, reversed, pause) {
                        return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause()
                    },
                    _callback = function _callback(self, func) {
                        if (self.enabled) {
                            var result = func(self);
                            result && result.totalTime && (self.callbackAnimation = result)
                        }
                    },
                    _abs = Math.abs,
                    _padding = "padding",
                    _px = "px",
                    _getComputedStyle = function _getComputedStyle(element) {
                        return _win.getComputedStyle(element)
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) p in obj || (obj[p] = defaults[p]);
                        return obj
                    },
                    _getBounds = function _getBounds(element, withoutTransforms) {
                        var tween = withoutTransforms && "matrix(1, 0, 0, 1, 0, 0)" !== _getComputedStyle(element)[_transformProp] && gsap.to(element, {
                                x: 0,
                                y: 0,
                                xPercent: 0,
                                yPercent: 0,
                                rotation: 0,
                                rotationX: 0,
                                rotationY: 0,
                                scale: 1,
                                skewX: 0,
                                skewY: 0
                            }).progress(1),
                            bounds = element.getBoundingClientRect();
                        return tween && tween.progress(0).kill(), bounds
                    },
                    _getSize = function _getSize(element, _ref3) {
                        var d2 = _ref3.d2;
                        return element["offset" + d2] || element["client" + d2] || 0
                    },
                    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
                        var p, a = [],
                            labels = timeline.labels,
                            duration = timeline.duration();
                        for (p in labels) a.push(labels[p] / duration);
                        return a
                    },
                    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
                        var snap = gsap.utils.snap(snapIncrementOrArray),
                            a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort((function(a, b) {
                                return a - b
                            }));
                        return a ? function(value, direction, threshold) {
                            var i;
                            if (void 0 === threshold && (threshold = .001), !direction) return snap(value);
                            if (direction > 0) {
                                for (value -= threshold, i = 0; i < a.length; i++)
                                    if (a[i] >= value) return a[i];
                                return a[i - 1]
                            }
                            for (i = a.length, value += threshold; i--;)
                                if (a[i] <= value) return a[i];
                            return a[0]
                        } : function(value, direction, threshold) {
                            void 0 === threshold && (threshold = .001);
                            var snapped = snap(value);
                            return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 == direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray)
                        }
                    },
                    _multiListener = function _multiListener(func, element, types, callback) {
                        return types.split(",").forEach((function(type) {
                            return func(element, type, callback)
                        }))
                    },
                    _addListener = function _addListener(element, type, func, nonPassive, capture) {
                        return element.addEventListener(type, func, {
                            passive: !nonPassive,
                            capture: !!capture
                        })
                    },
                    _removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture)
                    },
                    _wheelListener = function _wheelListener(func, el, scrollFunc) {
                        return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc)
                    },
                    _markerDefaults = {
                        startColor: "green",
                        endColor: "red",
                        indent: 0,
                        fontSize: "16px",
                        fontWeight: "normal"
                    },
                    _defaults = {
                        toggleActions: "play",
                        anticipatePin: 0
                    },
                    _keywords = {
                        top: 0,
                        left: 0,
                        center: .5,
                        bottom: 1,
                        right: 1
                    },
                    _offsetToPx = function _offsetToPx(value, size) {
                        if (_isString(value)) {
                            var eqIndex = value.indexOf("="),
                                relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
                            ~eqIndex && (value.indexOf("%") > eqIndex && (relative *= size / 100), value = value.substr(0, eqIndex - 1)), value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0)
                        }
                        return value
                    },
                    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
                        var startColor = _ref4.startColor,
                            endColor = _ref4.endColor,
                            fontSize = _ref4.fontSize,
                            indent = _ref4.indent,
                            fontWeight = _ref4.fontWeight,
                            e = _doc.createElement("div"),
                            useFixedPosition = _isViewport(container) || "fixed" === (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, "pinType"),
                            isScroller = -1 !== type.indexOf("scroller"),
                            parent = useFixedPosition ? _body : container,
                            isStart = -1 !== type.indexOf("start"),
                            color = isStart ? startColor : endColor,
                            css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                        return css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;"), (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? "right" : "bottom") + ":" + (offset + parseFloat(indent)) + "px;"), matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;"), e._isStart = isStart, e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : "")), e.style.cssText = css, e.innerText = name || 0 === name ? type + "-" + name : type, parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e), e._offset = e["offset" + direction.op.d2], _positionMarker(e, 0, direction, isStart), e
                    },
                    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
                        var vars = {
                                display: "block"
                            },
                            side = direction[flipped ? "os2" : "p2"],
                            oppositeSide = direction[flipped ? "p2" : "os2"];
                        marker._isFlipped = flipped, vars[direction.a + "Percent"] = flipped ? -100 : 0, vars[direction.a] = flipped ? "1px" : 0, vars["border" + side + "Width"] = 1, vars["border" + oppositeSide + "Width"] = 0, vars[direction.p] = start + "px", gsap.set(marker, vars)
                    },
                    _triggers = [],
                    _ids = {},
                    _sync = function _sync() {
                        return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)))
                    },
                    _onScroll = function _onScroll() {
                        (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) && (_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++, _normalizer ? _rafID || (_rafID = requestAnimationFrame(_updateAll)) : _updateAll(), _lastScrollTime || _dispatch("scrollStart"), _lastScrollTime = _getTime())
                    },
                    _setBaseDimensions = function _setBaseDimensions() {
                        _baseScreenWidth = _win.innerWidth, _baseScreenHeight = _win.innerHeight
                    },
                    _onResize = function _onResize() {
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++, !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > .25 * _win.innerHeight) && _resizeDelay.restart(!0)
                    },
                    _listeners = {},
                    _emptyArray = [],
                    _softRefresh = function _softRefresh() {
                        return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(!0)
                    },
                    _dispatch = function _dispatch(type) {
                        return _listeners[type] && _listeners[type].map((function(f) {
                            return f()
                        })) || _emptyArray
                    },
                    _savedStyles = [],
                    _revertRecorded = function _revertRecorded(media) {
                        for (var i = 0; i < _savedStyles.length; i += 5)(!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) && (_savedStyles[i].style.cssText = _savedStyles[i + 1], _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || ""), _savedStyles[i + 3].uncache = 1)
                    },
                    _revertAll = function _revertAll(kill, media) {
                        var trigger;
                        for (_i = 0; _i < _triggers.length; _i++) !(trigger = _triggers[_i]) || media && trigger._ctx !== media || (kill ? trigger.kill(1) : trigger.revert(!0, !0));
                        media && _revertRecorded(media), media || _dispatch("revert")
                    },
                    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++, (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach((function(obj) {
                            return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0)
                        })), _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration)
                    },
                    _refreshID = 0,
                    _refreshAll = function _refreshAll(force, skipRevert) {
                        if (!_lastScrollTime || force) {
                            _refreshingAll = ScrollTrigger.isRefreshing = !0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach((function(obj) {
                                return _isFunction(obj) && obj.cacheID++ && (obj.rec = obj())
                            }));
                            var refreshInits = _dispatch("refreshInit");
                            _sort && ScrollTrigger.sort(), skipRevert || _revertAll(), _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach((function(obj) {
                                _isFunction(obj) && (obj.smooth && (obj.target.style.scrollBehavior = "auto"), obj(0))
                            })), _triggers.slice(0).forEach((function(t) {
                                return t.refresh()
                            })), _triggers.forEach((function(t, i) {
                                if (t._subPinOffset && t.pin) {
                                    var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                        original = t.pin[prop];
                                    t.revert(!0, 1), t.adjustPinSpacing(t.pin[prop] - original), t.revert(!1, 1)
                                }
                            })), _triggers.forEach((function(t) {
                                return "max" === t.vars.end && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)))
                            })), refreshInits.forEach((function(result) {
                                return result && result.render && result.render(-1)
                            })), _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach((function(obj) {
                                _isFunction(obj) && (obj.smooth && requestAnimationFrame((function() {
                                    return obj.target.style.scrollBehavior = "smooth"
                                })), obj.rec && obj(obj.rec))
                            })), _clearScrollMemory(_scrollRestoration, 1), _resizeDelay.pause(), _refreshID++, _updateAll(2), _triggers.forEach((function(t) {
                                return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t)
                            })), _refreshingAll = ScrollTrigger.isRefreshing = !1, _dispatch("refresh")
                        } else _addListener(ScrollTrigger, "scrollEnd", _softRefresh)
                    },
                    _lastScroll = 0,
                    _direction = 1,
                    _updateAll = function _updateAll(force) {
                        if (!_refreshingAll || 2 === force) {
                            ScrollTrigger.isUpdating = !0, _primary && _primary.update(0);
                            var l = _triggers.length,
                                time = _getTime(),
                                recordVelocity = time - _time1 >= 50,
                                scroll = l && _triggers[0].scroll();
                            if (_direction = _lastScroll > scroll ? -1 : 1, _lastScroll = scroll, recordVelocity && (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200 && (_lastScrollTime = 0, _dispatch("scrollEnd")), _time2 = _time1, _time1 = time), _direction < 0) {
                                for (_i = l; _i-- > 0;) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                                _direction = 1
                            } else
                                for (_i = 0; _i < l; _i++) _triggers[_i] && _triggers[_i].update(0, recordVelocity);
                            ScrollTrigger.isUpdating = !1
                        }
                        _rafID = 0
                    },
                    _propNamesToCopy = ["left", "top", "bottom", "right", "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                    _stateProps = _propNamesToCopy.concat(["width", "height", "boxSizing", "maxWidth", "maxHeight", "position", "margin", _padding, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]),
                    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
                        if (!pin._gsap.swappedIn) {
                            for (var p, i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style; i--;) spacerStyle[p = _propNamesToCopy[i]] = cs[p];
                            spacerStyle.position = "absolute" === cs.position ? "absolute" : "relative", "inline" === cs.display && (spacerStyle.display = "inline-block"), pinStyle.bottom = pinStyle.right = "auto", spacerStyle.flexBasis = cs.flexBasis || "auto", spacerStyle.overflow = "visible", spacerStyle.boxSizing = "border-box", spacerStyle.width = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px, spacerStyle.height = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px, spacerStyle[_padding] = pinStyle.margin = pinStyle.top = pinStyle.left = "0", _setState(spacerState), pinStyle.width = pinStyle.maxWidth = cs.width, pinStyle.height = pinStyle.maxHeight = cs.height, pinStyle[_padding] = cs[_padding], pin.parentNode !== spacer && (pin.parentNode.insertBefore(spacer, pin), spacer.appendChild(pin)), pin._gsap.swappedIn = !0
                        }
                    },
                    _capsExp = /([A-Z])/g,
                    _setState = function _setState(state) {
                        if (state) {
                            var p, value, style = state.t.style,
                                l = state.length,
                                i = 0;
                            for ((state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; i < l; i += 2) value = state[i + 1], p = state[i], value ? style[p] = value : style[p] && style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())
                        }
                    },
                    _getState = function _getState(element) {
                        for (var l = _stateProps.length, style = element.style, state = [], i = 0; i < l; i++) state.push(_stateProps[i], style[_stateProps[i]]);
                        return state.t = element, state
                    },
                    _winOffsets = {
                        left: 0,
                        top: 0
                    },
                    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
                        _isFunction(value) && (value = value(self)), _isString(value) && "max" === value.substr(0, 3) && (value = scrollerMax + ("=" === value.charAt(4) ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0));
                        var p1, p2, element, time = containerAnimation ? containerAnimation.time() : 0;
                        if (containerAnimation && containerAnimation.seek(0), _isNumber(value)) markerScroller && _positionMarker(markerScroller, scrollerSize, direction, !0);
                        else {
                            _isFunction(trigger) && (trigger = trigger(self));
                            var bounds, localOffset, globalOffset, display, offsets = (value || "0").split(" ");
                            element = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger) || _body, (bounds = _getBounds(element) || {}) && (bounds.left || bounds.top) || "none" !== _getComputedStyle(element).display || (display = element.style.display, element.style.display = "block", bounds = _getBounds(element), display ? element.style.display = display : element.style.removeProperty("display")), localOffset = _offsetToPx(offsets[0], bounds[direction.d]), globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize), value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset, markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20), scrollerSize -= scrollerSize - globalOffset
                        }
                        if (marker) {
                            var position = value + scrollerSize,
                                isStart = marker._isStart;
                            p1 = "scroll" + direction.d2, _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1), useFixedPosition && (scrollerBounds = _getBounds(markerScroller), useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px))
                        }
                        return containerAnimation && element && (p1 = _getBounds(element), containerAnimation.seek(scrollerMax), p2 = _getBounds(element), containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p], value = value / containerAnimation._caScrollDist * scrollerMax), containerAnimation && containerAnimation.seek(time), containerAnimation ? value : Math.round(value)
                    },
                    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
                    _reparent = function _reparent(element, parent, top, left) {
                        if (element.parentNode !== parent) {
                            var p, cs, style = element.style;
                            if (parent === _body) {
                                for (p in element._stOrig = style.cssText, cs = _getComputedStyle(element)) + p || _prefixExp.test(p) || !cs[p] || "string" != typeof style[p] || "0" === p || (style[p] = cs[p]);
                                style.top = top, style.left = left
                            } else style.cssText = element._stOrig;
                            gsap.core.getCache(element).uncache = 1, parent.appendChild(element)
                        }
                    },
                    _getTweenCreator = function _getTweenCreator(scroller, direction) {
                        var lastScroll1, lastScroll2, getScroll = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),
                            prop = "_scroll" + direction.p2,
                            getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
                                var tween = getTween.tween,
                                    onComplete = vars.onComplete,
                                    modifiers = {};
                                return initialValue = initialValue || getScroll(), change2 = change1 && change2 || 0, change1 = change1 || scrollTo - initialValue, tween && tween.kill(), lastScroll1 = Math.round(initialValue), vars[prop] = scrollTo, vars.modifiers = modifiers, modifiers[prop] = function(value) {
                                    return (value = Math.round(getScroll())) !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 3 && Math.abs(value - lastScroll2) > 3 ? (tween.kill(), getTween.tween = 0) : value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio, lastScroll2 = lastScroll1, lastScroll1 = Math.round(value)
                                }, vars.onComplete = function() {
                                    getTween.tween = 0, onComplete && onComplete.call(tween)
                                }, tween = getTween.tween = gsap.to(scroller, vars)
                            };
                        return scroller[prop] = getScroll, getScroll.wheelHandler = function() {
                            return getTween.tween && getTween.tween.kill() && (getTween.tween = 0)
                        }, _addListener(scroller, "wheel", getScroll.wheelHandler), getTween
                    },
                    ScrollTrigger = function() {
                        function ScrollTrigger(vars, animation) {
                            _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(vars, animation)
                        }
                        return ScrollTrigger.prototype.init = function init(vars, animation) {
                            if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), _enabled) {
                                var tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevProgress, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn, _vars = vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
                                        trigger: vars
                                    } : vars, _defaults),
                                    onUpdate = _vars.onUpdate,
                                    toggleClass = _vars.toggleClass,
                                    id = _vars.id,
                                    onToggle = _vars.onToggle,
                                    onRefresh = _vars.onRefresh,
                                    scrub = _vars.scrub,
                                    trigger = _vars.trigger,
                                    pin = _vars.pin,
                                    pinSpacing = _vars.pinSpacing,
                                    invalidateOnRefresh = _vars.invalidateOnRefresh,
                                    anticipatePin = _vars.anticipatePin,
                                    onScrubComplete = _vars.onScrubComplete,
                                    onSnapComplete = _vars.onSnapComplete,
                                    once = _vars.once,
                                    snap = _vars.snap,
                                    pinReparent = _vars.pinReparent,
                                    pinSpacer = _vars.pinSpacer,
                                    containerAnimation = _vars.containerAnimation,
                                    fastScrollEnd = _vars.fastScrollEnd,
                                    preventOverlaps = _vars.preventOverlaps,
                                    direction = vars.horizontal || vars.containerAnimation && !1 !== vars.horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical,
                                    isToggle = !scrub && 0 !== scrub,
                                    scroller = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win),
                                    scrollerCache = gsap.core.getCache(scroller),
                                    isViewport = _isViewport(scroller),
                                    useFixedPosition = "fixed" === ("pinType" in vars ? vars.pinType : (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "pinType") || isViewport && "fixed"),
                                    callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
                                    toggleActions = isToggle && vars.toggleActions.split(" "),
                                    markers = "markers" in vars ? vars.markers : _defaults.markers,
                                    borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + "Width"]) || 0,
                                    self = this,
                                    onRefreshInit = vars.onRefreshInit && function() {
                                        return vars.onRefreshInit(self)
                                    },
                                    getScrollerSize = function _getSizeFunc(scroller, isViewport, _ref) {
                                        var d = _ref.d,
                                            d2 = _ref.d2,
                                            a = _ref.a;
                                        return (a = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "getBoundingClientRect")) ? function() {
                                            return a()[d]
                                        } : function() {
                                            return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0
                                        }
                                    }(scroller, isViewport, direction),
                                    getScrollerOffsets = function _getOffsetsFunc(element, isViewport) {
                                        return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
                                            return _winOffsets
                                        }
                                    }(scroller, isViewport),
                                    lastSnap = 0,
                                    lastRefresh = 0,
                                    scrollFunc = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction);
                                if (_context(self), self._dir = direction, anticipatePin *= 45, self.scroller = scroller, self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc, scroll1 = scrollFunc(), self.vars = vars, animation = animation || vars.animation, "refreshPriority" in vars && (_sort = 1, -9999 === vars.refreshPriority && (_primary = self)), scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
                                        top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),
                                        left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)
                                    }, self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p], self.scrubDuration = function(value) {
                                        (scrubSmooth = _isNumber(value) && value) ? scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
                                            ease: "expo",
                                            totalProgress: "+=0.001",
                                            duration: scrubSmooth,
                                            paused: !0,
                                            onComplete: function onComplete() {
                                                return onScrubComplete && onScrubComplete(self)
                                            }
                                        }): (scrubTween && scrubTween.progress(1).kill(), scrubTween = 0)
                                    }, animation && (animation.vars.lazy = !1, animation._initted || !1 !== animation.vars.immediateRender && !1 !== vars.immediateRender && animation.duration() && animation.render(0, !0, !0), self.animation = animation.pause(), animation.scrollTrigger = self, self.scrubDuration(scrub), snap1 = 0, id || (id = animation.vars.id)), _triggers.push(self), snap && (_isObject(snap) && !snap.push || (snap = {
                                        snapTo: snap
                                    }), "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
                                        scrollBehavior: "auto"
                                    }), _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach((function(o) {
                                        return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = !1)
                                    })), snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : "labels" === snap.snapTo ? function _getClosestLabel(animation) {
                                        return function(value) {
                                            return gsap.utils.snap(_getLabelRatioArray(animation), value)
                                        }
                                    }(animation) : "labelsDirectional" === snap.snapTo ? function _getLabelAtDirection(timeline) {
                                        return function(value, st) {
                                            return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction)
                                        }
                                    }(animation) : !1 !== snap.directional ? function(value, st) {
                                        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction)
                                    } : gsap.utils.snap(snap.snapTo), snapDurClamp = snap.duration || {
                                        min: .1,
                                        max: 2
                                    }, snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp), snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || .1, (function() {
                                        var scroll = scrollFunc(),
                                            refreshedRecently = _getTime() - lastRefresh < 500,
                                            tween = tweenTo.tween;
                                        if (!(refreshedRecently || Math.abs(self.getVelocity()) < 10) || tween || _pointerIsDown || lastSnap === scroll) self.isActive && lastSnap !== scroll && snapDelayedCall.restart(!0);
                                        else {
                                            var progress = (scroll - start) / change,
                                                totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                                                velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1e3 || 0,
                                                change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / .185),
                                                naturalEnd = progress + (!1 === snap.inertia ? 0 : change1),
                                                endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
                                                endScroll = Math.round(start + endValue * change),
                                                _snap = snap,
                                                onStart = _snap.onStart,
                                                _onInterrupt = _snap.onInterrupt,
                                                _onComplete = _snap.onComplete;
                                            if (scroll <= end && scroll >= start && endScroll !== scroll) {
                                                if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) return;
                                                !1 === snap.inertia && (change1 = endValue - progress), tweenTo(endScroll, {
                                                    duration: snapDurClamp(_abs(.185 * Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) / velocity / .05 || 0)),
                                                    ease: snap.ease || "power3",
                                                    data: _abs(endScroll - scroll),
                                                    onInterrupt: function onInterrupt() {
                                                        return snapDelayedCall.restart(!0) && _onInterrupt && _onInterrupt(self)
                                                    },
                                                    onComplete: function onComplete() {
                                                        self.update(), lastSnap = scrollFunc(), snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress, onSnapComplete && onSnapComplete(self), _onComplete && _onComplete(self)
                                                    }
                                                }, scroll, change1 * change, endScroll - scroll - change1 * change), onStart && onStart(self, tweenTo.tween)
                                            }
                                        }
                                    })).pause()), id && (_ids[id] = self), (customRevertReturn = (trigger = self.trigger = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin)) && trigger._gsap && trigger._gsap.stRevert) && (customRevertReturn = customRevertReturn(self)), pin = !0 === pin ? trigger : (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin), _isString(toggleClass) && (toggleClass = {
                                        targets: trigger,
                                        className: toggleClass
                                    }), pin && (!1 === pinSpacing || "margin" === pinSpacing || (pinSpacing = !(!pinSpacing && pin.parentNode && pin.parentNode.style && "flex" === _getComputedStyle(pin.parentNode).display) && _padding), self.pin = pin, (pinCache = gsap.core.getCache(pin)).spacer ? pinOriginalState = pinCache.pinState : (pinSpacer && ((pinSpacer = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer)) && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement), pinCache.spacerIsNative = !!pinSpacer, pinSpacer && (pinCache.spacerState = _getState(pinSpacer))), pinCache.spacer = spacer = pinSpacer || _doc.createElement("div"), spacer.classList.add("pin-spacer"), id && spacer.classList.add("pin-spacer-" + id), pinCache.pinState = pinOriginalState = _getState(pin)), !1 !== vars.force3D && gsap.set(pin, {
                                        force3D: !0
                                    }), self.spacer = spacer = pinCache.spacer, cs = _getComputedStyle(pin), spacingStart = cs[pinSpacing + direction.os2], pinGetter = gsap.getProperty(pin), pinSetter = gsap.quickSetter(pin, direction.a, _px), _swapPinIn(pin, spacer, cs), pinState = _getState(pin)), markers) {
                                    markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults, markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0), markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger), offset = markerStartTrigger["offset" + direction.op.d2];
                                    var content = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "content") || scroller);
                                    markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation), markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation), containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px)), useFixedPosition || _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && !0 === (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "fixedMarkers") || (! function _makePositionable(element) {
                                        var position = _getComputedStyle(element).position;
                                        element.style.position = "absolute" === position || "fixed" === position ? position : "relative"
                                    }(isViewport ? _body : scroller), gsap.set([markerStartTrigger, markerEndTrigger], {
                                        force3D: !0
                                    }), markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px), markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px))
                                }
                                if (containerAnimation) {
                                    var oldOnUpdate = containerAnimation.vars.onUpdate,
                                        oldParams = containerAnimation.vars.onUpdateParams;
                                    containerAnimation.eventCallback("onUpdate", (function() {
                                        self.update(0, 0, 1), oldOnUpdate && oldOnUpdate.apply(oldParams || [])
                                    }))
                                }
                                self.previous = function() {
                                    return _triggers[_triggers.indexOf(self) - 1]
                                }, self.next = function() {
                                    return _triggers[_triggers.indexOf(self) + 1]
                                }, self.revert = function(revert, temp) {
                                    if (!temp) return self.kill(!0);
                                    var r = !1 !== revert || !self.enabled,
                                        prevRefreshing = _refreshing;
                                    r !== self.isReverted && (r && (prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0), prevProgress = self.progress, prevAnimProgress = animation && animation.progress()), markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach((function(m) {
                                        return m.style.display = r ? "none" : "block"
                                    })), r && (_refreshing = 1, self.update(r)), pin && (r ? function _swapPinOut(pin, spacer, state) {
                                        _setState(state);
                                        var cache = pin._gsap;
                                        if (cache.spacerIsNative) _setState(cache.spacerState);
                                        else if (pin._gsap.swappedIn) {
                                            var parent = spacer.parentNode;
                                            parent && (parent.insertBefore(pin, spacer), parent.removeChild(spacer))
                                        }
                                        pin._gsap.swappedIn = !1
                                    }(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState)), r || self.update(r), _refreshing = prevRefreshing, self.isReverted = r)
                                }, self.refresh = function(soft, force) {
                                    if (!_refreshing && self.enabled || force)
                                        if (pin && soft && _lastScrollTime) _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
                                        else {
                                            !_refreshingAll && onRefreshInit && onRefreshInit(self), _refreshing = 1, lastRefresh = _getTime(), tweenTo.tween && (tweenTo.tween.kill(), tweenTo.tween = 0), scrubTween && scrubTween.pause(), invalidateOnRefresh && animation && animation.revert({
                                                kill: !1
                                            }).invalidate(), self.isReverted || self.revert(!0, !0), self._subPinOffset = !1;
                                            for (var cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), offset = 0, otherPinOffset = 0, parsedEnd = vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = vars.start || (0 !== vars.start && trigger ? pin ? "0 0" : "0 100%" : 0), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex; i--;)(curTrigger = _triggers[i]).end || curTrigger.refresh(0, 1) || (_refreshing = 1), !(curPin = curTrigger.pin) || curPin !== trigger && curPin !== pin || curTrigger.isReverted || (revertedPins || (revertedPins = []), revertedPins.unshift(curTrigger), curTrigger.revert(!0, !0)), curTrigger !== _triggers[i] && (triggerIndex--, i--);
                                            for (_isFunction(parsedStart) && (parsedStart = parsedStart(self)), start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -.001 : 0), _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self)), _isString(parsedEnd) && !parsedEnd.indexOf("+=") && (~parsedEnd.indexOf(" ") ? parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd : (offset = _offsetToPx(parsedEnd.substr(2), size), parsedEnd = _isString(parsedStart) ? parsedStart : start + offset, parsedEndTrigger = trigger)), end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -.001, change = end - start || (start -= .01) && .001, offset = 0, i = triggerIndex; i--;)(curPin = (curTrigger = _triggers[i]).pin) && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0 && (cs = curTrigger.end - curTrigger.start, (curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && !_isNumber(parsedStart) && (offset += cs * (1 - curTrigger.progress)), curPin === pin && (otherPinOffset += cs));
                                            if (start += offset, end += offset, self._pinPush = otherPinOffset, markerStart && offset && ((cs = {})[direction.a] = "+=" + offset, pinnedContainer && (cs[direction.p] = "-=" + scrollFunc()), gsap.set([markerStart, markerEnd], cs)), pin) cs = _getComputedStyle(pin), isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical, scroll = scrollFunc(), pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset, !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"), _swapPinIn(pin, spacer, cs), pinState = _getState(pin), bounds = _getBounds(pin, !0), oppositeScroll = useFixedPosition && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)(), pinSpacing && ((spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px]).t = spacer, (i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0) && spacerState.push(direction.d, i + _px), _setState(spacerState), pinnedContainer && _triggers.forEach((function(t) {
                                                t.pin === pinnedContainer && !1 !== t.vars.pinSpacing && (t._subPinOffset = !0)
                                            })), useFixedPosition && scrollFunc(prevScroll)), useFixedPosition && ((override = {
                                                top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                                                left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                                                boxSizing: "border-box",
                                                position: "fixed"
                                            }).width = override.maxWidth = Math.ceil(bounds.width) + _px, override.height = override.maxHeight = Math.ceil(bounds.height) + _px, override.margin = override.marginTop = override.marginRight = override.marginBottom = override.marginLeft = "0", override[_padding] = cs[_padding], override.paddingTop = cs.paddingTop, override.paddingRight = cs.paddingRight, override.paddingBottom = cs.paddingBottom, override.paddingLeft = cs.paddingLeft, pinActiveState = function _copyState(state, override, omitOffsets) {
                                                for (var p, result = [], l = state.length, i = omitOffsets ? 8 : 0; i < l; i += 2) p = state[i], result.push(p, p in override ? override[p] : state[i + 1]);
                                                return result.t = state.t, result
                                            }(pinOriginalState, override, pinReparent), _refreshingAll && scrollFunc(0)), animation ? (initted = animation._initted, _suppressOverwrites(1), animation.render(animation.duration(), !0, !0), pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset, change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2), animation.render(0, !0, !0), initted || animation.invalidate(!0), animation.parent || animation.totalTime(animation.totalTime()), _suppressOverwrites(0)) : pinChange = change;
                                            else if (trigger && scrollFunc() && !containerAnimation)
                                                for (bounds = trigger.parentNode; bounds && bounds !== _body;) bounds._pinOffset && (start -= bounds._pinOffset, end -= bounds._pinOffset), bounds = bounds.parentNode;
                                            revertedPins && revertedPins.forEach((function(t) {
                                                return t.revert(!1, !0)
                                            })), self.start = start, self.end = end, scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(), containerAnimation || _refreshingAll || (scroll1 < prevScroll && scrollFunc(prevScroll), self.scroll.rec = 0), self.revert(!1, !0), snapDelayedCall && (lastSnap = -1, self.isActive && scrollFunc(start + change * prevProgress), snapDelayedCall.restart(!0)), _refreshing = 0, animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, !0).render(animation.time(), !0, !0), (prevProgress !== self.progress || containerAnimation) && (animation && !isToggle && animation.totalProgress(prevProgress, !0), self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress), pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)), onRefresh && !_refreshingAll && onRefresh(self)
                                        }
                                }, self.getVelocity = function() {
                                    return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1e3 || 0
                                }, self.endAnimation = function() {
                                    _endAnimation(self.callbackAnimation), animation && (scrubTween ? scrubTween.progress(1) : animation.paused() ? isToggle || _endAnimation(animation, self.direction < 0, 1) : _endAnimation(animation, animation.reversed()))
                                }, self.labelToScroll = function(label) {
                                    return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0
                                }, self.getTrailing = function(name) {
                                    var i = _triggers.indexOf(self),
                                        a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
                                    return (_isString(name) ? a.filter((function(t) {
                                        return t.vars.preventOverlaps === name
                                    })) : a).filter((function(t) {
                                        return self.direction > 0 ? t.end <= start : t.start >= end
                                    }))
                                }, self.update = function(reset, recordVelocity, forceFake) {
                                    if (!containerAnimation || forceFake || reset) {
                                        var isActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction, scroll = _refreshingAll ? prevScroll : self.scroll(),
                                            p = reset ? 0 : (scroll - start) / change,
                                            clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
                                            prevProgress = self.progress;
                                        if (recordVelocity && (scroll2 = scroll1, scroll1 = containerAnimation ? scrollFunc() : scroll, snap && (snap2 = snap1, snap1 = animation && !isToggle ? animation.totalProgress() : clipped)), anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 1e-4), clipped !== prevProgress && self.enabled) {
                                            if (stateChanged = (toggled = (isActive = self.isActive = !!clipped && clipped < 1) !== (!!prevProgress && prevProgress < 1)) || !!clipped != !!prevProgress, self.direction = clipped > prevProgress ? 1 : -1, self.progress = clipped, stateChanged && !_refreshing && (toggleState = clipped && !prevProgress ? 0 : 1 === clipped ? 1 : 1 === prevProgress ? 2 : 3, isToggle && (action = !toggled && "none" !== toggleActions[toggleState + 1] && toggleActions[toggleState + 1] || toggleActions[toggleState], isTakingAction = animation && ("complete" === action || "reset" === action || action in animation))), preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach((function(t) {
                                                    return t.endAnimation()
                                                }))), isToggle || (!scrubTween || _refreshing || _startup ? animation && animation.totalProgress(clipped, !!_refreshing) : ((containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start), scrubTween.resetTo ? scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur) : (scrubTween.vars.totalProgress = clipped, scrubTween.invalidate().restart()))), pin)
                                                if (reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart), useFixedPosition) {
                                                    if (stateChanged) {
                                                        if (isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction), pinReparent)
                                                            if (reset || !isActive && !isAtMax) _reparent(pin, spacer);
                                                            else {
                                                                var bounds = _getBounds(pin, !0),
                                                                    _offset = scroll - start;
                                                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px)
                                                            } _setState(isActive || isAtMax ? pinActiveState : pinState), pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (1 !== clipped || isAtMax ? 0 : pinChange))
                                                    }
                                                } else pinSetter(_round(pinStart + pinChange * clipped));
                                            snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(!0), toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach((function(el) {
                                                return el.classList[isActive || once ? "add" : "remove"](toggleClass.className)
                                            })), onUpdate && !isToggle && !reset && onUpdate(self), stateChanged && !_refreshing ? (isToggle && (isTakingAction && ("complete" === action ? animation.pause().totalProgress(1) : "reset" === action ? animation.restart(!0).pause() : "restart" === action ? animation.restart(!0) : animation[action]()), onUpdate && onUpdate(self)), !toggled && _limitCallbacks || (onToggle && toggled && _callback(self, onToggle), callbacks[toggleState] && _callback(self, callbacks[toggleState]), once && (1 === clipped ? self.kill(!1, 1) : callbacks[toggleState] = 0), toggled || callbacks[toggleState = 1 === clipped ? 1 : 3] && _callback(self, callbacks[toggleState])), fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500) && (_endAnimation(self.callbackAnimation), scrubTween ? scrubTween.progress(1) : _endAnimation(animation, "reverse" === action ? 1 : !clipped, 1))) : isToggle && onUpdate && !_refreshing && onUpdate(self)
                                        }
                                        if (markerEndSetter) {
                                            var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
                                            markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0)), markerEndSetter(n)
                                        }
                                        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0))
                                    }
                                }, self.enable = function(reset, refresh) {
                                    self.enabled || (self.enabled = !0, _addListener(scroller, "resize", _onResize), _addListener(isViewport ? _doc : scroller, "scroll", _onScroll), onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit), !1 !== reset && (self.progress = prevProgress = 0, scroll1 = scroll2 = lastSnap = scrollFunc()), !1 !== refresh && self.refresh())
                                }, self.getTween = function(snap) {
                                    return snap && tweenTo ? tweenTo.tween : scrubTween
                                }, self.setPositions = function(newStart, newEnd) {
                                    pin && (pinStart += newStart - start, pinChange += newEnd - newStart - change, pinSpacing === _padding && self.adjustPinSpacing(newEnd - newStart - change)), self.start = start = newStart, self.end = end = newEnd, change = newEnd - newStart, self.update()
                                }, self.adjustPinSpacing = function(amount) {
                                    if (spacerState) {
                                        var i = spacerState.indexOf(direction.d) + 1;
                                        spacerState[i] = parseFloat(spacerState[i]) + amount + _px, spacerState[1] = parseFloat(spacerState[1]) + amount + _px, _setState(spacerState)
                                    }
                                }, self.disable = function(reset, allowAnimation) {
                                    if (self.enabled && (!1 !== reset && self.revert(!0, !0), self.enabled = self.isActive = !1, allowAnimation || scrubTween && scrubTween.pause(), prevScroll = 0, pinCache && (pinCache.uncache = 1), onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit), snapDelayedCall && (snapDelayedCall.pause(), tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0)), !isViewport)) {
                                        for (var i = _triggers.length; i--;)
                                            if (_triggers[i].scroller === scroller && _triggers[i] !== self) return;
                                        _removeListener(scroller, "resize", _onResize), _removeListener(scroller, "scroll", _onScroll)
                                    }
                                }, self.kill = function(revert, allowAnimation) {
                                    self.disable(revert, allowAnimation), scrubTween && !allowAnimation && scrubTween.kill(), id && delete _ids[id];
                                    var i = _triggers.indexOf(self);
                                    i >= 0 && _triggers.splice(i, 1), i === _i && _direction > 0 && _i--, i = 0, _triggers.forEach((function(t) {
                                        return t.scroller === self.scroller && (i = 1)
                                    })), i || _refreshingAll || (self.scroll.rec = 0), animation && (animation.scrollTrigger = null, revert && animation.revert({
                                        kill: !1
                                    }), allowAnimation || animation.kill()), markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach((function(m) {
                                        return m.parentNode && m.parentNode.removeChild(m)
                                    })), _primary === self && (_primary = 0), pin && (pinCache && (pinCache.uncache = 1), i = 0, _triggers.forEach((function(t) {
                                        return t.pin === pin && i++
                                    })), i || (pinCache.spacer = 0)), vars.onKill && vars.onKill(self)
                                }, self.enable(!1, !1), customRevertReturn && customRevertReturn(self), animation && animation.add && !change ? gsap.delayedCall(.01, (function() {
                                    return start || end || self.refresh()
                                })) && (change = .01) && (start = end = 0) : self.refresh(), pin && function _queueRefreshAll() {
                                    if (_queueRefreshID !== _refreshID) {
                                        var id = _queueRefreshID = _refreshID;
                                        requestAnimationFrame((function() {
                                            return id === _refreshID && _refreshAll(!0)
                                        }))
                                    }
                                }()
                            } else this.update = this.refresh = this.kill = _passThrough
                        }, ScrollTrigger.register = function register(core) {
                            return _coreInitted || (gsap = core || _getGSAP(), _windowExists() && window.document && ScrollTrigger.enable(), _coreInitted = _enabled), _coreInitted
                        }, ScrollTrigger.defaults = function defaults(config) {
                            if (config)
                                for (var p in config) _defaults[p] = config[p];
                            return _defaults
                        }, ScrollTrigger.disable = function disable(reset, kill) {
                            _enabled = 0, _triggers.forEach((function(trigger) {
                                return trigger[kill ? "kill" : "disable"](reset)
                            })), _removeListener(_win, "wheel", _onScroll), _removeListener(_doc, "scroll", _onScroll), clearInterval(_syncInterval), _removeListener(_doc, "touchcancel", _passThrough), _removeListener(_body, "touchstart", _passThrough), _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler), _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler), _resizeDelay.kill(), _iterateAutoRefresh(_removeListener);
                            for (var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]), _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2])
                        }, ScrollTrigger.enable = function enable() {
                            if (_win = window, _doc = document, _docEl = _doc.documentElement, _body = _doc.body, gsap && (_toArray = gsap.utils.toArray, _clamp = gsap.utils.clamp, _context = gsap.core.context || _passThrough, _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough, _scrollRestoration = _win.history.scrollRestoration || "auto", gsap.core.globals("ScrollTrigger", ScrollTrigger), _body)) {
                                _enabled = 1, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap), ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch, _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), _addListener(_win, "wheel", _onScroll), _root = [_win, _doc, _docEl, _body], gsap.matchMedia ? (ScrollTrigger.matchMedia = function(vars) {
                                    var p, mm = gsap.matchMedia();
                                    for (p in vars) mm.add(p, vars[p]);
                                    return mm
                                }, gsap.addEventListener("matchMediaInit", (function() {
                                    return _revertAll()
                                })), gsap.addEventListener("matchMediaRevert", (function() {
                                    return _revertRecorded()
                                })), gsap.addEventListener("matchMedia", (function() {
                                    _refreshAll(0, 1), _dispatch("matchMedia")
                                })), gsap.matchMedia("(orientation: portrait)", (function() {
                                    return _setBaseDimensions(), _setBaseDimensions
                                }))) : console.warn("Requires GSAP 3.11.0 or later"), _setBaseDimensions(), _addListener(_doc, "scroll", _onScroll);
                                var bounds, i, bodyStyle = _body.style,
                                    border = bodyStyle.borderTopStyle,
                                    AnimationProto = gsap.core.Animation.prototype;
                                for (AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
                                        value: function value() {
                                            return this.time(-.01, !0)
                                        }
                                    }), bodyStyle.borderTopStyle = "solid", bounds = _getBounds(_body), _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0, border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"), _syncInterval = setInterval(_sync, 250), gsap.delayedCall(.5, (function() {
                                        return _startup = 0
                                    })), _addListener(_doc, "touchcancel", _passThrough), _addListener(_body, "touchstart", _passThrough), _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler), _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler), _transformProp = gsap.utils.checkPrefix("transform"), _stateProps.push(_transformProp), _coreInitted = _getTime(), _resizeDelay = gsap.delayedCall(.2, _refreshAll).pause(), _autoRefresh = [_doc, "visibilitychange", function() {
                                        var w = _win.innerWidth,
                                            h = _win.innerHeight;
                                        _doc.hidden ? (_prevWidth = w, _prevHeight = h) : _prevWidth === w && _prevHeight === h || _onResize()
                                    }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize], _iterateAutoRefresh(_addListener), _triggers.forEach((function(trigger) {
                                        return trigger.enable(0, 1)
                                    })), i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]), _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2])
                            }
                        }, ScrollTrigger.config = function config(vars) {
                            "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
                            var ms = vars.syncInterval;
                            ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms), "ignoreMobileResize" in vars && (_ignoreMobileResize = 1 === ScrollTrigger.isTouch && vars.ignoreMobileResize), "autoRefreshEvents" in vars && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none"), _ignoreResize = -1 === (vars.autoRefreshEvents + "").indexOf("resize"))
                        }, ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
                            var t = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target),
                                i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t),
                                isViewport = _isViewport(t);
                            ~i && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2), vars && (isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars))
                        }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
                            _triggers.forEach((function(t) {
                                return t._ctx && t._ctx.query === query && t._ctx.kill(!0, !0)
                            }))
                        }, ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
                            var bounds = (_isString(element) ? (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(),
                                offset = bounds[horizontal ? "width" : "height"] * ratio || 0;
                            return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight
                        }, ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
                            _isString(element) && (element = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));
                            var bounds = element.getBoundingClientRect(),
                                size = bounds[horizontal ? "width" : "height"],
                                offset = null == referencePoint ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
                            return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight
                        }, ScrollTrigger.killAll = function killAll(allowListeners) {
                            if (_triggers.forEach((function(t) {
                                    return "ScrollSmoother" !== t.vars.id && t.kill()
                                })), !0 !== allowListeners) {
                                var listeners = _listeners.killAll || [];
                                _listeners = {}, listeners.forEach((function(f) {
                                    return f()
                                }))
                            }
                        }, ScrollTrigger
                    }();
                ScrollTrigger.version = "3.11.3", ScrollTrigger.saveStyles = function(targets) {
                    return targets ? _toArray(targets).forEach((function(target) {
                        if (target && target.style) {
                            var i = _savedStyles.indexOf(target);
                            i >= 0 && _savedStyles.splice(i, 5), _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _context())
                        }
                    })) : _savedStyles
                }, ScrollTrigger.revert = function(soft, media) {
                    return _revertAll(!soft, media)
                }, ScrollTrigger.create = function(vars, animation) {
                    return new ScrollTrigger(vars, animation)
                }, ScrollTrigger.refresh = function(safe) {
                    return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(!0)
                }, ScrollTrigger.update = _updateAll, ScrollTrigger.clearScrollMemory = _clearScrollMemory, ScrollTrigger.maxScroll = function(element, horizontal) {
                    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)
                }, ScrollTrigger.getScrollFunc = function(element, horizontal) {
                    return (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)
                }, ScrollTrigger.getById = function(id) {
                    return _ids[id]
                }, ScrollTrigger.getAll = function() {
                    return _triggers.filter((function(t) {
                        return "ScrollSmoother" !== t.vars.id
                    }))
                }, ScrollTrigger.isScrolling = function() {
                    return !!_lastScrollTime
                }, ScrollTrigger.snapDirectional = _snapDirectional, ScrollTrigger.addEventListener = function(type, callback) {
                    var a = _listeners[type] || (_listeners[type] = []);
                    ~a.indexOf(callback) || a.push(callback)
                }, ScrollTrigger.removeEventListener = function(type, callback) {
                    var a = _listeners[type],
                        i = a && a.indexOf(callback);
                    i >= 0 && a.splice(i, 1)
                }, ScrollTrigger.batch = function(targets, vars) {
                    var p, result = [],
                        varsCopy = {},
                        interval = vars.interval || .016,
                        batchMax = vars.batchMax || 1e9,
                        proxyCallback = function proxyCallback(type, callback) {
                            var elements = [],
                                triggers = [],
                                delay = gsap.delayedCall(interval, (function() {
                                    callback(elements, triggers), elements = [], triggers = []
                                })).pause();
                            return function(self) {
                                elements.length || delay.restart(!0), elements.push(self.trigger), triggers.push(self), batchMax <= elements.length && delay.progress(1)
                            }
                        };
                    for (p in vars) varsCopy[p] = "on" === p.substr(0, 2) && _isFunction(vars[p]) && "onRefreshInit" !== p ? proxyCallback(0, vars[p]) : vars[p];
                    return _isFunction(batchMax) && (batchMax = batchMax(), _addListener(ScrollTrigger, "refresh", (function() {
                        return batchMax = vars.batchMax()
                    }))), _toArray(targets).forEach((function(target) {
                        var config = {};
                        for (p in varsCopy) config[p] = varsCopy[p];
                        config.trigger = target, result.push(ScrollTrigger.create(config))
                    })), result
                };
                var _inputIsFocused, _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
                        return current > max ? scrollFunc(max) : current < 0 && scrollFunc(0), end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1
                    },
                    _allowNativePanning = function _allowNativePanning(target, direction) {
                        !0 === direction ? target.style.removeProperty("touch-action") : target.style.touchAction = !0 === direction ? "auto" : direction ? "pan-" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? " pinch-zoom" : "") : "none", target === _docEl && _allowNativePanning(_body, direction)
                    },
                    _overflow = {
                        auto: 1,
                        scroll: 1
                    },
                    _nestedScroll = function _nestedScroll(_ref5) {
                        var cs, event = _ref5.event,
                            target = _ref5.target,
                            axis = _ref5.axis,
                            node = (event.changedTouches ? event.changedTouches[0] : event).target,
                            cache = node._gsap || gsap.core.getCache(node),
                            time = _getTime();
                        if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
                            for (; node && node.scrollHeight <= node.clientHeight;) node = node.parentNode;
                            cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]), cache._isScrollT = time
                        }(cache._isScroll || "x" === axis) && (event.stopPropagation(), event._gsapAllow = !0)
                    },
                    _inputObserver = function _inputObserver(target, type, inputs, nested) {
                        return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({
                            target: target,
                            capture: !0,
                            debounce: !1,
                            lockAxis: !0,
                            type: type,
                            onWheel: nested = nested && _nestedScroll,
                            onPress: nested,
                            onDrag: nested,
                            onScroll: nested,
                            onEnable: function onEnable() {
                                return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, !1, !0)
                            },
                            onDisable: function onDisable() {
                                return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, !0)
                            }
                        })
                    },
                    _inputExp = /(input|label|select|textarea)/i,
                    _captureInputs = function _captureInputs(e) {
                        var isInput = _inputExp.test(e.target.tagName);
                        (isInput || _inputIsFocused) && (e._gsapAllow = !0, _inputIsFocused = isInput)
                    },
                    _getScrollNormalizer = function _getScrollNormalizer(vars) {
                        _isObject(vars) || (vars = {}), vars.preventDefault = vars.isNormalizer = vars.allowClicks = !0, vars.type || (vars.type = "wheel,touch"), vars.debounce = !!vars.debounce, vars.id = vars.id || "normalizer";
                        var self, maxY, lastRefreshID, skipTouchMove, tween, startScrollX, startScrollY, onStopDelayedCall, _vars2 = vars,
                            normalizeScrollX = _vars2.normalizeScrollX,
                            momentum = _vars2.momentum,
                            allowNestedScroll = _vars2.allowNestedScroll,
                            target = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl,
                            smoother = gsap.core.globals().ScrollSmoother,
                            smootherInstance = smoother && smoother.get(),
                            content = _fixIOSBug && (vars.content && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && !1 !== vars.content && !smootherInstance.smooth() && smootherInstance.content()),
                            scrollFuncY = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),
                            scrollFuncX = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal),
                            scale = 1,
                            initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
                            wheelRefresh = 0,
                            resolveMomentumDuration = _isFunction(momentum) ? function() {
                                return momentum(self)
                            } : function() {
                                return momentum || 2.8
                            },
                            inputObserver = _inputObserver(target, vars.type, !0, allowNestedScroll),
                            resumeTouchMove = function resumeTouchMove() {
                                return skipTouchMove = !1
                            },
                            scrollClampX = _passThrough,
                            scrollClampY = _passThrough,
                            updateClamps = function updateClamps() {
                                maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical), scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY), normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal))), lastRefreshID = _refreshID
                            },
                            removeContentOffset = function removeContentOffset() {
                                content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px", content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)", scrollFuncY.offset = scrollFuncY.cacheID = 0
                            },
                            onResize = function onResize() {
                                updateClamps(), tween.isActive() && tween.vars.scrollY > maxY && (scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY))
                            };
                        return content && gsap.set(content, {
                            y: "+=0"
                        }), vars.ignoreCheck = function(e) {
                            return _fixIOSBug && "touchmove" === e.type && function ignoreDrag() {
                                if (skipTouchMove) {
                                    requestAnimationFrame(resumeTouchMove);
                                    var offset = _round(self.deltaY / 2),
                                        scroll = scrollClampY(scrollFuncY.v - offset);
                                    if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
                                        scrollFuncY.offset = scroll - scrollFuncY.v;
                                        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
                                        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)", content._gsap.y = y + "px", scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache, _updateAll()
                                    }
                                    return !0
                                }
                                scrollFuncY.offset && removeContentOffset(), skipTouchMove = !0
                            }() || scale > 1.05 && "touchstart" !== e.type || self.isGesturing || e.touches && e.touches.length > 1
                        }, vars.onPress = function() {
                            var prevScale = scale;
                            scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale), tween.pause(), prevScale !== scale && _allowNativePanning(target, scale > 1.01 || !normalizeScrollX && "x"), startScrollX = scrollFuncX(), startScrollY = scrollFuncY(), updateClamps(), lastRefreshID = _refreshID
                        }, vars.onRelease = vars.onGestureStart = function(self, wasDragging) {
                            if (scrollFuncY.offset && removeContentOffset(), wasDragging) {
                                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                                var currentScroll, endScroll, dur = resolveMomentumDuration();
                                normalizeScrollX && (endScroll = (currentScroll = scrollFuncX()) + .05 * dur * -self.velocityX / .227, dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)), tween.vars.scrollX = scrollClampX(endScroll)), endScroll = (currentScroll = scrollFuncY()) + .05 * dur * -self.velocityY / .227, dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)), tween.vars.scrollY = scrollClampY(endScroll), tween.invalidate().duration(dur).play(.01), (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) && gsap.to({}, {
                                    onUpdate: onResize,
                                    duration: dur
                                })
                            } else onStopDelayedCall.restart(!0)
                        }, vars.onWheel = function() {
                            tween._ts && tween.pause(), _getTime() - wheelRefresh > 1e3 && (lastRefreshID = 0, wheelRefresh = _getTime())
                        }, vars.onChange = function(self, dx, dy, xArray, yArray) {
                            if (_refreshID !== lastRefreshID && updateClamps(), dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])), dy) {
                                scrollFuncY.offset && removeContentOffset();
                                var isTouch = yArray[2] === dy,
                                    y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
                                    yClamped = scrollClampY(y);
                                isTouch && y !== yClamped && (startScrollY += yClamped - y), scrollFuncY(yClamped)
                            }(dy || dx) && _updateAll()
                        }, vars.onEnable = function() {
                            _allowNativePanning(target, !normalizeScrollX && "x"), ScrollTrigger.addEventListener("refresh", onResize), _addListener(_win, "resize", onResize), scrollFuncY.smooth && (scrollFuncY.target.style.scrollBehavior = "auto", scrollFuncY.smooth = scrollFuncX.smooth = !1), inputObserver.enable()
                        }, vars.onDisable = function() {
                            _allowNativePanning(target, !0), _removeListener(_win, "resize", onResize), ScrollTrigger.removeEventListener("refresh", onResize), inputObserver.kill()
                        }, vars.lockAxis = !1 !== vars.lockAxis, (self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars)).iOS = _fixIOSBug, _fixIOSBug && !scrollFuncY() && scrollFuncY(1), _fixIOSBug && gsap.ticker.add(_passThrough), onStopDelayedCall = self._dc, tween = gsap.to(self, {
                            ease: "power4",
                            paused: !0,
                            scrollX: normalizeScrollX ? "+=0.1" : "+=0",
                            scrollY: "+=0.1",
                            onComplete: onStopDelayedCall.vars.onComplete
                        }), self
                    };
                ScrollTrigger.sort = function(func) {
                    return _triggers.sort(func || function(a, b) {
                        return -1e6 * (a.vars.refreshPriority || 0) + a.start - (b.start + -1e6 * (b.vars.refreshPriority || 0))
                    })
                }, ScrollTrigger.observe = function(vars) {
                    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars)
                }, ScrollTrigger.normalizeScroll = function(vars) {
                    if (void 0 === vars) return _normalizer;
                    if (!0 === vars && _normalizer) return _normalizer.enable();
                    if (!1 === vars) return _normalizer && _normalizer.kill();
                    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);
                    return _normalizer && _normalizer.target === normalizer.target && _normalizer.kill(), _isViewport(normalizer.target) && (_normalizer = normalizer), normalizer
                }, ScrollTrigger.core = {
                    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,
                    _inputObserver: _inputObserver,
                    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,
                    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,
                    bridge: {
                        ss: function ss() {
                            _lastScrollTime || _dispatch("scrollStart"), _lastScrollTime = _getTime()
                        },
                        ref: function ref() {
                            return _refreshing
                        }
                    }
                }, _getGSAP() && gsap.registerPlugin(ScrollTrigger)
            },
            "./src/js/plugins/gsap/SplitText.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    SplitText: () => SplitText,
                    default: () => SplitText
                });
                var _doc, _win, _coreInitted, _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/js/plugins/gsap/utils/strings.js"),
                    _stripExp = /(?:\r|\n|\t\t)/g,
                    _multipleSpacesExp = /(?:\s\s+)/g,
                    _getComputedStyle = function _getComputedStyle(element) {
                        return _win.getComputedStyle(element)
                    },
                    _isArray = Array.isArray,
                    _slice = [].slice,
                    _toArray = function _toArray(value, leaveStrings) {
                        var type;
                        return _isArray(value) ? value : "string" == (type = typeof value) && !leaveStrings && value ? _slice.call(_doc.querySelectorAll(value), 0) : value && "object" === type && "length" in value ? _slice.call(value, 0) : value ? [value] : []
                    },
                    _isAbsolute = function _isAbsolute(vars) {
                        return "absolute" === vars.position || !0 === vars.absolute
                    },
                    _findSpecialChars = function _findSpecialChars(text, chars) {
                        for (var s, i = chars.length; --i > -1;)
                            if (s = chars[i], text.substr(0, s.length) === s) return s.length
                    },
                    _cssClassFunc = function _cssClassFunc(cssClass, tag) {
                        void 0 === cssClass && (cssClass = "");
                        var iterate = ~cssClass.indexOf("++"),
                            num = 1;
                        return iterate && (cssClass = cssClass.split("++").join("")),
                            function() {
                                return "<" + tag + " style='position:relative;display:inline-block;'" + (cssClass ? " class='" + cssClass + (iterate ? num++ : "") + "'>" : ">")
                            }
                    },
                    _swapText = function _swapText(element, oldText, newText) {
                        var type = element.nodeType;
                        if (1 === type || 9 === type || 11 === type)
                            for (element = element.firstChild; element; element = element.nextSibling) _swapText(element, oldText, newText);
                        else 3 !== type && 4 !== type || (element.nodeValue = element.nodeValue.split(oldText).join(newText))
                    },
                    _pushReversed = function _pushReversed(a, merge) {
                        for (var i = merge.length; --i > -1;) a.push(merge[i])
                    },
                    _isBeforeWordDelimiter = function _isBeforeWordDelimiter(e, root, wordDelimiter) {
                        for (var next; e && e !== root;) {
                            if (next = e._next || e.nextSibling) return next.textContent.charAt(0) === wordDelimiter;
                            e = e.parentNode || e._parent
                        }
                    },
                    _deWordify = function _deWordify(e) {
                        var i, child, children = _toArray(e.childNodes),
                            l = children.length;
                        for (i = 0; i < l; i++)(child = children[i])._isSplit ? _deWordify(child) : i && child.previousSibling && 3 === child.previousSibling.nodeType ? (child.previousSibling.nodeValue += 3 === child.nodeType ? child.nodeValue : child.firstChild.nodeValue, e.removeChild(child)) : 3 !== child.nodeType && (e.insertBefore(child.firstChild, child), e.removeChild(child))
                    },
                    _getStyleAsNumber = function _getStyleAsNumber(name, computedStyle) {
                        return parseFloat(computedStyle[name]) || 0
                    },
                    _setPositionsAfterSplit = function _setPositionsAfterSplit(element, vars, allChars, allWords, allLines, origWidth, origHeight) {
                        var i, j, l, node, nodes, isChild, curLine, addWordSpaces, style, lineNode, lineWidth, offset, cs = _getComputedStyle(element),
                            paddingLeft = _getStyleAsNumber("paddingLeft", cs),
                            lineOffsetY = -999,
                            borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs),
                            borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs),
                            padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs),
                            padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs),
                            lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || .2),
                            textAlign = cs.textAlign,
                            charArray = [],
                            wordArray = [],
                            lineArray = [],
                            wordDelimiter = vars.wordDelimiter || " ",
                            tag = vars.tag ? vars.tag : vars.span ? "span" : "div",
                            types = vars.type || vars.split || "chars,words,lines",
                            lines = allLines && ~types.indexOf("lines") ? [] : null,
                            words = ~types.indexOf("words"),
                            chars = ~types.indexOf("chars"),
                            absolute = _isAbsolute(vars),
                            linesClass = vars.linesClass,
                            iterateLine = ~(linesClass || "").indexOf("++"),
                            spaceNodesToRemove = [],
                            isFlex = "flex" === cs.display,
                            prevInlineDisplay = element.style.display;
                        for (iterateLine && (linesClass = linesClass.split("++").join("")), isFlex && (element.style.display = "block"), l = (j = element.getElementsByTagName("*")).length, nodes = [], i = 0; i < l; i++) nodes[i] = j[i];
                        if (lines || absolute)
                            for (i = 0; i < l; i++)((isChild = (node = nodes[i]).parentNode === element) || absolute || chars && !words) && (offset = node.offsetTop, lines && isChild && Math.abs(offset - lineOffsetY) > lineThreshold && ("BR" !== node.nodeName || 0 === i) && (curLine = [], lines.push(curLine), lineOffsetY = offset), absolute && (node._x = node.offsetLeft, node._y = offset, node._w = node.offsetWidth, node._h = node.offsetHeight), lines && ((node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) && (curLine.push(node), node._x -= paddingLeft, _isBeforeWordDelimiter(node, element, wordDelimiter) && (node._wordEnd = !0)), "BR" === node.nodeName && (node.nextSibling && "BR" === node.nextSibling.nodeName || 0 === i) && lines.push([])));
                        for (i = 0; i < l; i++)
                            if (isChild = (node = nodes[i]).parentNode === element, "BR" !== node.nodeName)
                                if (absolute && (style = node.style, words || isChild || (node._x += node.parentNode._x, node._y += node.parentNode._y), style.left = node._x + "px", style.top = node._y + "px", style.position = "absolute", style.display = "block", style.width = node._w + 1 + "px", style.height = node._h + "px"), !words && chars)
                                    if (node._isSplit)
                                        for (node._next = j = node.nextSibling, node.parentNode.appendChild(node); j && 3 === j.nodeType && " " === j.textContent;) node._next = j.nextSibling, node.parentNode.appendChild(j), j = j.nextSibling;
                                    else node.parentNode._isSplit ? (node._parent = node.parentNode, !node.previousSibling && node.firstChild && (node.firstChild._isFirst = !0), node.nextSibling && " " === node.nextSibling.textContent && !node.nextSibling.nextSibling && spaceNodesToRemove.push(node.nextSibling), node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling, node.parentNode.removeChild(node), nodes.splice(i--, 1), l--) : isChild || (offset = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter), node.parentNode._parent && node.parentNode._parent.appendChild(node), offset && node.parentNode.appendChild(_doc.createTextNode(" ")), "span" === tag && (node.style.display = "inline"), charArray.push(node));
                        else node.parentNode._isSplit && !node._isSplit && "" !== node.innerHTML ? wordArray.push(node) : chars && !node._isSplit && ("span" === tag && (node.style.display = "inline"), charArray.push(node));
                        else lines || absolute ? (node.parentNode && node.parentNode.removeChild(node), nodes.splice(i--, 1), l--) : words || element.appendChild(node);
                        for (i = spaceNodesToRemove.length; --i > -1;) spaceNodesToRemove[i].parentNode.removeChild(spaceNodesToRemove[i]);
                        if (lines) {
                            for (absolute && (lineNode = _doc.createElement(tag), element.appendChild(lineNode), lineWidth = lineNode.offsetWidth + "px", offset = lineNode.offsetParent === element ? 0 : element.offsetLeft, element.removeChild(lineNode)), style = element.style.cssText, element.style.cssText = "display:none;"; element.firstChild;) element.removeChild(element.firstChild);
                            for (addWordSpaces = " " === wordDelimiter && (!absolute || !words && !chars), i = 0; i < lines.length; i++) {
                                for (curLine = lines[i], (lineNode = _doc.createElement(tag)).style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;"), linesClass && (lineNode.className = linesClass + (iterateLine ? i + 1 : "")), lineArray.push(lineNode), l = curLine.length, j = 0; j < l; j++) "BR" !== curLine[j].nodeName && (node = curLine[j], lineNode.appendChild(node), addWordSpaces && node._wordEnd && lineNode.appendChild(_doc.createTextNode(" ")), absolute && (0 === j && (lineNode.style.top = node._y + "px", lineNode.style.left = paddingLeft + offset + "px"), node.style.top = "0px", offset && (node.style.left = node._x - offset + "px")));
                                0 === l ? lineNode.innerHTML = "&nbsp;" : words || chars || (_deWordify(lineNode), _swapText(lineNode, String.fromCharCode(160), " ")), absolute && (lineNode.style.width = lineWidth, lineNode.style.height = node._h + "px"), element.appendChild(lineNode)
                            }
                            element.style.cssText = style
                        }
                        absolute && (origHeight > element.clientHeight && (element.style.height = origHeight - padTopAndBottom + "px", element.clientHeight < origHeight && (element.style.height = origHeight + borderTopAndBottom + "px")), origWidth > element.clientWidth && (element.style.width = origWidth - padLeftAndRight + "px", element.clientWidth < origWidth && (element.style.width = origWidth + borderLeftAndRight + "px"))), isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display")), _pushReversed(allChars, charArray), words && _pushReversed(allWords, wordArray), _pushReversed(allLines, lineArray)
                    },
                    _split = function _split(element, vars, wordStart, charStart) {
                        var i, child, children = _toArray(element.childNodes),
                            l = children.length,
                            absolute = _isAbsolute(vars);
                        if (3 !== element.nodeType || l > 1) {
                            for (vars.absolute = !1, i = 0; i < l; i++)(child = children[i])._next = child._isFirst = child._parent = child._wordEnd = null, (3 !== child.nodeType || /\S+/.test(child.nodeValue)) && (absolute && 3 !== child.nodeType && "inline" === _getComputedStyle(child).display && (child.style.display = "inline-block", child.style.position = "relative"), child._isSplit = !0, _split(child, vars, wordStart, charStart));
                            return vars.absolute = absolute, void(element._isSplit = !0)
                        }! function _splitRawText(element, vars, wordStart, charStart) {
                            var text, splitText, i, j, l, character, hasTagStart, testResult, tag = vars.tag ? vars.tag : vars.span ? "span" : "div",
                                chars = ~(vars.type || vars.split || "chars,words,lines").indexOf("chars"),
                                absolute = _isAbsolute(vars),
                                wordDelimiter = vars.wordDelimiter || " ",
                                space = " " !== wordDelimiter ? "" : absolute ? "&#173; " : " ",
                                wordEnd = "</" + tag + ">",
                                wordIsOpen = 1,
                                specialChars = vars.specialChars ? "function" == typeof vars.specialChars ? vars.specialChars : _findSpecialChars : null,
                                container = _doc.createElement("div"),
                                parent = element.parentNode;
                            for (parent.insertBefore(container, element), container.textContent = element.nodeValue, parent.removeChild(element), element = container, hasTagStart = -1 !== (text = (0, _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText)(element)).indexOf("<"), !1 !== vars.reduceWhiteSpace && (text = text.replace(_multipleSpacesExp, " ").replace(_stripExp, "")), hasTagStart && (text = text.split("<").join("{{LT}}")), l = text.length, splitText = (" " === text.charAt(0) ? space : "") + wordStart(), i = 0; i < l; i++)
                                if (character = text.charAt(i), specialChars && (testResult = specialChars(text.substr(i), vars.specialChars))) character = text.substr(i, testResult || 1), splitText += chars && " " !== character ? charStart() + character + "</" + tag + ">" : character, i += testResult - 1;
                                else if (character === wordDelimiter && text.charAt(i - 1) !== wordDelimiter && i) {
                                for (splitText += wordIsOpen ? wordEnd : "", wordIsOpen = 0; text.charAt(i + 1) === wordDelimiter;) splitText += space, i++;
                                i === l - 1 ? splitText += space : ")" !== text.charAt(i + 1) && (splitText += space + wordStart(), wordIsOpen = 1)
                            } else "{" === character && "{{LT}}" === text.substr(i, 6) ? (splitText += chars ? charStart() + "{{LT}}</" + tag + ">" : "{{LT}}", i += 5) : character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text.charCodeAt(i + 1) >= 65024 && text.charCodeAt(i + 1) <= 65039 ? (j = ((text.substr(i, 12).split(_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiExp) || [])[1] || "").length || 2, splitText += chars && " " !== character ? charStart() + text.substr(i, j) + "</" + tag + ">" : text.substr(i, j), i += j - 1) : splitText += chars && " " !== character ? charStart() + character + "</" + tag + ">" : character;
                            element.outerHTML = splitText + (wordIsOpen ? wordEnd : ""), hasTagStart && _swapText(parent, "{{LT}}", "<")
                        }(element, vars, wordStart, charStart)
                    },
                    SplitText = function() {
                        function SplitText(element, vars) {
                            _coreInitted || function _initCore() {
                                _doc = document, _win = window, _coreInitted = 1
                            }(), this.elements = _toArray(element), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = vars || {}, this.split(vars)
                        }
                        var _proto = SplitText.prototype;
                        return _proto.split = function split(vars) {
                            this.isSplit && this.revert(), this.vars = vars = vars || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                            for (var origHeight, origWidth, e, i = this.elements.length, tag = vars.tag ? vars.tag : vars.span ? "span" : "div", wordStart = _cssClassFunc(vars.wordsClass, tag), charStart = _cssClassFunc(vars.charsClass, tag); --i > -1;) e = this.elements[i], this._originals[i] = e.innerHTML, origHeight = e.clientHeight, origWidth = e.clientWidth, _split(e, vars, wordStart, charStart), _setPositionsAfterSplit(e, vars, this.chars, this.words, this.lines, origWidth, origHeight);
                            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                        }, _proto.revert = function revert() {
                            var originals = this._originals;
                            if (!originals) throw "revert() call wasn't scoped properly.";
                            return this.elements.forEach((function(e, i) {
                                return e.innerHTML = originals[i]
                            })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                        }, SplitText.create = function create(element, vars) {
                            return new SplitText(element, vars)
                        }, SplitText
                    }();
                SplitText.version = "3.11.3"
            },
            "./src/js/plugins/gsap/utils/strings.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
                    emojiExp: () => emojiExp,
                    emojiSafeSplit: () => emojiSafeSplit,
                    getText: () => getText,
                    splitInnerHTML: () => splitInnerHTML
                });
                var _trimExp = /(?:^\s+|\s+$)/g,
                    emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

                function getText(e) {
                    var type = e.nodeType,
                        result = "";
                    if (1 === type || 9 === type || 11 === type) {
                        if ("string" == typeof e.textContent) return e.textContent;
                        for (e = e.firstChild; e; e = e.nextSibling) result += getText(e)
                    } else if (3 === type || 4 === type) return e.nodeValue;
                    return result
                }

                function splitInnerHTML(element, delimiter, trim, preserveSpaces) {
                    for (var s, node = element.firstChild, result = []; node;) 3 === node.nodeType ? (s = (node.nodeValue + "").replace(/^\n+/g, ""), preserveSpaces || (s = s.replace(/\s+/g, " ")), result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces))) : "br" === (node.nodeName + "").toLowerCase() ? result[result.length - 1] += "<br>" : result.push(node.outerHTML), node = node.nextSibling;
                    for (s = result.length; s--;) "&" === result[s] && result.splice(s, 1, "&amp;");
                    return result
                }

                function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
                    if (text += "", trim && (text = text.trim ? text.trim() : text.replace(_trimExp, "")), delimiter && "" !== delimiter) return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
                    for (var j, character, result = [], l = text.length, i = 0; i < l; i++)((character = text.charAt(i)).charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text.charCodeAt(i + 1) >= 65024 && text.charCodeAt(i + 1) <= 65039) && (j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2, character = text.substr(i, j), result.emoji = 1, i += j - 1), result.push(">" === character ? "&gt;" : "<" === character ? "&lt;" : !preserveSpaces || " " !== character || " " !== text.charAt(i - 1) && " " !== text.charAt(i + 1) ? character : "&nbsp;");
                    return result
                }
            }
        },
        __webpack_module_cache__ = {};

    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.exports
    }
    __webpack_require__.amdO = {}, __webpack_require__.d = (exports, definition) => {
        for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
            enumerable: !0,
            get: definition[key]
        })
    }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.r = exports => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(exports, "__esModule", {
            value: !0
        })
    };
    var __webpack_exports__ = {};
    (() => {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/gsap/index.js"),
            _plugins_gsap_ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/js/plugins/gsap/ScrollTrigger.js"),
            _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/js/plugins/gsap/SplitText.js"),
            _plugins_gsap_CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/js/plugins/gsap/CSSRulePlugin.js"),
            lottie_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/lottie-web/build/player/lottie.js");
        gsap__WEBPACK_IMPORTED_MODULE_3__.default.registerPlugin(_plugins_gsap_ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_0__.default, _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default, _plugins_gsap_CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_2__.default);
        lottie_web__WEBPACK_IMPORTED_MODULE_4__.loadAnimation({
            container: document.getElementById("lottie-animation"),
            renderer: "svg",
            loop: !0,
            autoplay: !0,
            path: "./files/data.json"
        });

        if (window.innerWidth > 1200) {
            const headerLogo = document.querySelector(".header__logo"),
                headerNav = document.querySelector(".header__nav"),
                headerNavLinks = document.querySelectorAll(".header__nav a"),
                headerButton = document.querySelector(".header .button"),
                langSwitcher = document.querySelector(".lang-switcher");
            gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline().from(headerLogo, {
                opacity: 0,
                x: -20,
                duration: .5
            }, "<").from(headerNav, {
                opacity: 0,
                scaleX: 0,
                duration: .5
            }, "<").from(headerNavLinks, {
                yPercent: 100,
                duration: .5,
                stagger: .1
            }, "<+=0.5").from(headerButton, {
                opacity: 0,
                x: 20,
                duration: .5
            }, "<");
            const hero = document.querySelector(".hero");
            
            if (hero) {
                const heroPlayIcon = document.querySelector(".hero-section .play-button__icon"),
                    heroPlayText = document.querySelector(".hero-section .play-button__text"),
                    heroPlayTextSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(heroPlayText, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    heroTitle = hero.querySelector(".hero-section__title"),
                    heroTitleSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(heroTitle, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    heroText = hero.querySelector(".hero-section__text"),
                    heroTextSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(heroText, {
                        type: "lines, chars",
                        linesClass: "line"
                    }),
                    heroButton = hero.querySelector(".hero-section__button");
                gsap__WEBPACK_IMPORTED_MODULE_3__.default.utils.toArray(".benefits-list__item").forEach(((item, index) => {
                    console.log(item);
                    const icon = item.querySelector(".benefits-list__item-icon"),
                        text = item.querySelector(".benefits-list__item-text");
                    gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline().from(icon, {
                        opacity: 0,
                        duration: .5,
                        delay: .2 * index
                    }).from(text, {
                        opacity: 0,
                        y: 10,
                        duration: .5,
                        delay: .2 * index
                    })
                }));
                gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline().from(heroPlayIcon, {
                    opacity: 0,
                    scaleX: 0,
                    duration: .5
                }, "<").from(heroPlayTextSplit.words, {
                    y: 100,
                    opacity: 0,
                    duration: 1,
                    stagger: .1
                }, "<+=0.25").from(heroTitleSplit.words, {
                    y: 100,
                    opacity: 0,
                    duration: 1,
                    stagger: .1
                }, "<").from(heroTextSplit.chars, {
                    y: 100,
                    opacity: 0,
                    duration: .5,
                    stagger: .01
                }, "<").from(heroButton, {
                    scale: 0,
                    opacity: 0,
                    duration: .5
                }, "<+=0.5")
            }

            
            const referral = document.querySelector(".referral-section");
            if (referral) {
                const referralBg = document.querySelector(".referral-section__bg"),
                    referralBgAfter = _plugins_gsap_CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_2__.default.getRule(".referral-section__bg:after"),
                    referralBgImg = document.querySelector(".referral-section__img"),
                    referralTitle = document.querySelector(".referral-section__title"),
                    referralTitleSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(referralTitle, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    referralText = document.querySelector(".referral-section__text"),
                    referralTextSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(referralText, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    referralStatsItems = document.querySelectorAll(".referral-section__stats-item"),
                    referralButton = document.querySelector(".referral-section .button");
                gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline({
                    scrollTrigger: {
                        trigger: referral,
                        start: "top 70%",
                        toggleActions: "play none none reverse"
                    }
                }).from(referralBg, {
                    scaleY: 0,
                    transformOrigin: "top",
                    duration: 1
                }, 0).from(referralBgAfter, {
                    cssRule: {
                        scaleX: 0,
                        transformOrigin: "right"
                    },
                    duration: 1
                }, 1).from(referralBgImg, {
                    opacity: 0,
                    x: 20,
                    duration: .5
                }, .5).from(referralTitleSplit.words, {
                    y: 20,
                    opacity: 0,
                    duration: .5,
                    stagger: .1
                }, .5).from(referralTextSplit.words, {
                    y: 20,
                    opacity: 0,
                    duration: .5,
                    stagger: .1
                }, .5).from(referralStatsItems, {
                    opacity: 0,
                    y: 20,
                    duration: .5,
                    stagger: .1
                }, .5).from(referralButton, {
                    scale: 0,
                    opacity: 0,
                    duration: .5
                }, 1)
            }
            const about = document.querySelector(".about-section");
            if (about) {
                const aboutBg = document.querySelector(".about-section__bg"),
                    aboutTitle = document.querySelector(".about-section__title"),
                    aboutTitleSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(aboutTitle, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    aboutText = document.querySelector(".about-section__text"),
                    aboutTextSplit = new _plugins_gsap_SplitText_js__WEBPACK_IMPORTED_MODULE_1__.default(aboutText, {
                        type: "lines, words",
                        linesClass: "line"
                    }),
                    aboutButton = document.querySelector(".about-section .button"),
                    aboutVideo = document.querySelector(".about-section__video");
                gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline({
                    scrollTrigger: {
                        trigger: about,
                        start: "top 70%",
                        toggleActions: "play none none reverse"
                    }
                }).from(aboutBg, {
                    scaleY: 0,
                    transformOrigin: "top",
                    duration: 1
                }, 0).from(aboutTitleSplit.words, {
                    y: 20,
                    opacity: 0,
                    duration: .5,
                    stagger: .1
                }, .5).from(aboutTextSplit.words, {
                    y: 20,
                    opacity: 0,
                    duration: .5,
                    stagger: .01
                }, .5).from(aboutButton, {
                    scale: 0,
                    opacity: 0,
                    duration: .5
                }, 1).from(aboutVideo, {
                    opacity: 0,
                    y: 20,
                    duration: .5
                }, 1)
            }
            const footer = document.querySelector(".footer");
            if (footer) {
                const footerCols = document.querySelectorAll(".footer__col");
                gsap__WEBPACK_IMPORTED_MODULE_3__.default.timeline({
                    scrollTrigger: {
                        trigger: footer,
                        start: "top 80%",
                        toggleActions: "play none none reverse"
                    }
                }).from(footerCols, {
                    opacity: 0,
                    y: 20,
                    duration: .5,
                    stagger: .1
                }, 0)
            }
        }
    })()
})();
